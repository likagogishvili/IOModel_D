{"ast":null,"code":"import { isNumber } from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\n\nexport function round(value, precision, floor) {\n  if (!isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\n\nexport function ceil(value, precision) {\n  if (!isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\nexport function fitToRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Returns sine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function sin(angle) {\n  return Math.sin(RADIANS * angle);\n}\n/**\r\n * Returns tan of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function tan(angle) {\n  return Math.tan(RADIANS * angle);\n}\n/**\r\n * Returns cosine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\n\nexport function cos(angle) {\n  return Math.cos(RADIANS * angle);\n} // 0 to 360\n\nexport function normalizeAngle(value) {\n  value = value % 360;\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return value;\n} // TODO this doesn't work properly for skewing, and it's probably broken for rotation too\n\nexport function getArcBounds(cx, cy, startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    left: cx + minX,\n    top: cy + minY,\n    right: cx + maxX,\n    bottom: cy + maxY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\n\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\nexport function mergeBounds(bounds) {\n  var len = bounds.length;\n\n  if (len > 0) {\n    var bound = bounds[0];\n    var left = bound.left;\n    var top_1 = bound.top;\n    var right = bound.right;\n    var bottom = bound.bottom;\n\n    if (len > 1) {\n      for (var i = 1; i < len; i++) {\n        bound = bounds[i];\n        left = Math.min(bound.left, left);\n        right = Math.max(bound.right, right);\n        top_1 = Math.min(bound.top, top_1);\n        bottom = Math.max(bound.bottom, bottom);\n      }\n    }\n\n    return {\n      left: left,\n      right: right,\n      top: top_1,\n      bottom: bottom\n    };\n  }\n\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n}\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n\n  return value;\n}\nexport function inBounds(point, bounds) {\n  if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n    return true;\n  }\n\n  return false;\n}\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return normalizeAngle(angle);\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nexport function getPointOnLine(pointA, pointB, position) {\n  return {\n    x: pointA.x + (pointB.x - pointA.x) * position,\n    y: pointA.y + (pointB.y - pointA.y) * position\n  };\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\n\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\nexport function boundsOverlap(bounds1, bounds2) {\n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}","map":{"version":3,"mappings":"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","names":["isNumber","PI","Math","HALFPI","RADIANS","DEGREES","round","value","precision","floor","rounded","d","pow","ceil","getCubicControlPointA","p0","p1","p2","tensionX","tensionY","x","y","getCubicControlPointB","p3","fitToRange","min","max","sin","angle","tan","cos","normalizeAngle","getArcBounds","cx","cy","startAngle","endAngle","radius","minX","Number","MAX_VALUE","minY","maxX","maxY","bpoints","push","getArcPoint","fromAngle","toAngle","i","length","pt","left","top","right","bottom","arc","mergeBounds","bounds","len","bound","top_1","fitAngleToRange","temp","count","maxEnd","maxStart","inBounds","point","getAngle","point1","point2","diffX","diffY","atan2","getPointOnQuadraticCurve","pointA","pointB","controlPoint","position","getPointOnLine","closest","values","referenceValue","reduce","prev","curr","abs","boundsOverlap","bounds1","bounds2"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/Math.ts"],"sourcesContent":["import type { IPoint } from \"./IPoint\";\nimport { isNumber } from \"./Type\";\nimport type { IBounds } from \"./IBounds\";\n\n/**\n * ============================================================================\n * CONSTANTS\n * ============================================================================\n * @hidden\n */\nexport const PI = Math.PI;\nexport const HALFPI = PI / 2;\nexport const RADIANS = PI / 180;\nexport const DEGREES = 180 / PI;\n\n/**\n * Rounds the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\n * @return Rounded value\n */\nexport function round(value: number, precision?: number, floor?: boolean): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\n\t\tlet rounded = Math.round(value);\n\t\tif (floor) {\n\t\t\tif (rounded - value == 0.5) {\n\t\t\t\trounded--;\n\t\t\t}\n\t\t}\n\t\treturn rounded;\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.round(value * d) / d;\n\t}\n}\n\n\n/**\n * Ceils the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @return Rounded value\n */\nexport function ceil(value: number, precision: number): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\t\treturn Math.ceil(value);\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.ceil(value * d) / d;\n\t}\n}\n\n\n/**\n * [getCubicControlPointA description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\n}\n\n/**\n * [getCubicControlPointB description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointB(p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\n}\n\n\nexport function fitToRange(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns sine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function sin(angle: number): number {\n\treturn Math.sin(RADIANS * angle);\n}\n\n/**\n * Returns tan of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function tan(angle: number): number {\n\treturn Math.tan(RADIANS * angle);\n}\n\n/**\n * Returns cosine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Cosine\n */\nexport function cos(angle: number): number {\n\treturn Math.cos(RADIANS * angle);\n}\n\n// 0 to 360\nexport function normalizeAngle(value: number): number {\n\tvalue = value % 360;\n\tif (value < 0) {\n\t\tvalue += 360;\n\t}\n\treturn value;\n}\n\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx: number, cy: number, startAngle: number, endAngle: number, radius: number): IBounds {\n\n\tlet minX = Number.MAX_VALUE;\n\tlet minY = Number.MAX_VALUE;\n\tlet maxX = -Number.MAX_VALUE;\n\tlet maxY = -Number.MAX_VALUE;\n\n\tlet bpoints = [];\n\n\tbpoints.push(getArcPoint(radius, startAngle));\n\tbpoints.push(getArcPoint(radius, endAngle));\n\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\n\t\tif (angle >= startAngle && angle <= endAngle) {\n\t\t\tbpoints.push(getArcPoint(radius, angle));\n\t\t}\n\t}\n\n\tfor (let i = 0; i < bpoints.length; i++) {\n\t\tlet pt = bpoints[i];\n\t\tif (pt.x < minX) { minX = pt.x; }\n\t\tif (pt.y < minY) { minY = pt.y; }\n\t\tif (pt.x > maxX) { maxX = pt.x; }\n\t\tif (pt.y > maxY) { maxY = pt.y; }\n\t}\n\n\treturn ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });\n}\n\n/**\n * Returns point on arc\n *\n * @param center point\n * @param radius\n * @param arc\n * @return {boolean}\n */\nexport function getArcPoint(radius: number, arc: number) {\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\n}\n\n\nexport function mergeBounds(bounds: IBounds[]): IBounds {\n\tconst len = bounds.length;\n\n\tif (len > 0) {\n\t\tlet bound = bounds[0];\n\t\tlet left = bound.left;\n\t\tlet top = bound.top;\n\t\tlet right = bound.right;\n\t\tlet bottom = bound.bottom;\n\n\t\tif (len > 1) {\n\t\t\tfor (let i = 1; i < len; i++) {\n\t\t\t\tbound = bounds[i];\n\t\t\t\tleft = Math.min(bound.left, left);\n\t\t\t\tright = Math.max(bound.right, right);\n\t\t\t\ttop = Math.min(bound.top, top);\n\t\t\t\tbottom = Math.max(bound.bottom, bottom);\n\t\t\t}\n\t\t}\n\n\t\treturn { left, right, top, bottom };\n\t}\n\treturn { left: 0, right: 0, top: 0, bottom: 0 };\n}\n\n\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\n\n\tif (startAngle > endAngle) {\n\t\tlet temp: number = startAngle;\n\t\tstartAngle = endAngle;\n\t\tendAngle = temp;\n\t}\n\n\tvalue = normalizeAngle(value);\n\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n\tif (value < startAngle) {\n\t\tvalue += 360 * (count + 1);\n\t}\n\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\n\n\tif (value > endAngle) {\n\n\t\tif (value - 360 > startAngle) {\n\t\t\tvalue -= 360;\n\t\t}\n\t\telse {\n\t\t\tif (value < maxEnd) {\n\t\t\t\tvalue = endAngle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = startAngle;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value < startAngle) {\n\t\tif (value > maxStart) {\n\t\t\tvalue = startAngle;\n\t\t}\n\t\telse {\n\t\t\tvalue = endAngle;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nexport function inBounds(point: IPoint, bounds: IBounds) {\n\tif (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\n\tif (!point2) {\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\n\t}\n\tlet diffX: number = point2.x - point1.x;\n\tlet diffY: number = point2.y - point1.y;\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\n\tif (angle < 0) {\n\t\tangle += 360;\n\t}\n\treturn normalizeAngle(angle);\n}\n\n/**\n * [getPointOnQuadraticCurve description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param pointA        [description]\n * @param pointB        [description]\n * @param controlPoint  [description]\n * @param position      [description]\n * @return [description]\n */\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n\treturn { x: x, y: y };\n}\n\nexport function getPointOnLine(pointA: IPoint, pointB: IPoint, position: number): IPoint {\n\treturn { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };\n}\n\n\n/**\n * Returns the closest value from the array of values to the reference value.\n *\n * @param values  Array of values\n * @param value   Reference value\n * @return Closes value from the array\n */\nexport function closest(values: number[], referenceValue: number): number {\n\treturn values.reduce(function(prev, curr) {\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\n\t});\n}\n\nexport function boundsOverlap (bounds1:IBounds, bounds2:IBounds) {  \n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}"]},"metadata":{},"sourceType":"module"}