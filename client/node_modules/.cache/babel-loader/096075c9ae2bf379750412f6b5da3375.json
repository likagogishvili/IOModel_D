{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n\n      return points;\n    },\n\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n\n      return this._currentPoints;\n    },\n\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        } // hole\n\n\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n\n      if (path) {\n        path += $path.closePath();\n      }\n\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n\n\n  Polygon.prototype.measureElement = function () {// Overriding to avoid extra measurement.\n  };\n\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function () {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function () {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n\n        this._disposers.push(this._morpher);\n      }\n\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\n\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"mappings":"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","names":["Sprite","Morpher","registry","$path","$type","__extends","_super","_this","className","element","paper","add","shapeRendering","_currentPoints","applyTheme","Object","Polygon","points","getPropertyValue","path","length","valueStr","slice","segments","split","s","segment","areaHole","areaArr","holeArr","pointsArr","area","areaAndHole","push","p","coords","x","y","pointsArr_1","hole","setPropertyValue","draw","left","right","top","bottom","i","len","surface","point","moveTo","lineTo","isNumber","h","hlen","closePath","bbox","width","height","setPath","call","value","_bbox","group","getBBox","_morpher","_disposers","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/core/elements/Polygon.ts"],"sourcesContent":["/**\r\n * Polygon module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents } from \"../Sprite\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polygon]].\r\n */\r\nexport interface IPolygonProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t */\r\n\tpoints?: Array<Array<Array<IPoint>>>;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polygon]].\r\n */\r\nexport interface IPolygonEvents extends ISpriteEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Polygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolygonAdapters extends ISpriteAdapters, IPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class Polygon extends Sprite implements IMorphable {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolygonEvents;\r\n\r\n\t/**\r\n\t * A morpher instance that is used to morph polygon into some other shape.\r\n\t */\r\n\tprotected _morpher: $type.Optional<Morpher>;\r\n\r\n\t/**\r\n\t * Current points that morpher uses. This is needed so that we don't\r\n\t * overwrite polygons original points.\r\n\t */\r\n\tprotected _currentPoints: Array<Array<Array<IPoint>>>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polygon\";\r\n\t\tthis.element = this.paper.add(\"path\");\r\n\t\tthis.shapeRendering = \"auto\";\r\n\t\tthis._currentPoints = [];\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t *\r\n\t * @todo Example\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set points(points: Array<Array<Array<IPoint>>>) {\r\n\t\tthis.setPropertyValue(\"points\", points, true);\r\n\t\tthis._currentPoints = points;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get points(): Array<Array<Array<IPoint>>> {\r\n\t\tlet points = this.getPropertyValue(\"points\");\r\n\t\tlet path = this.path;\r\n\r\n\t\tif (path && (!points || points.length == 0)) {\r\n\r\n\t\t\tlet valueStr = path.slice(1, path.length - 1);\r\n\r\n\t\t\tlet segments: string[] = valueStr.split(\"ZM\");\r\n\r\n\t\t\tfor (let s = 0; s < segments.length; s++) {\r\n\t\t\t\tlet segment = segments[s];\r\n\t\t\t\tif (segment.length > 0) {\r\n\t\t\t\t\tlet areaHole = segment.split(\"M\");\r\n\r\n\t\t\t\t\tlet areaArr = areaHole[0];\r\n\t\t\t\t\tlet holeArr = areaHole[1];\r\n\r\n\t\t\t\t\tif (areaArr && areaArr.length > 0) {\r\n\r\n\t\t\t\t\t\tlet pointsArr = areaArr.split(\"L\");\r\n\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\r\n\t\t\t\t\t\t\tlet area: IPoint[] = [];\r\n\r\n\t\t\t\t\t\t\tlet areaAndHole: Array<Array<IPoint>> = [area];\r\n\t\t\t\t\t\t\tpoints.push(areaAndHole);\r\n\r\n\t\t\t\t\t\t\tfor (let p = 0; p < pointsArr.length; p++) {\r\n\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\tarea.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (holeArr && holeArr.length > 0) {\r\n\t\t\t\t\t\t\t\tlet pointsArr = holeArr.split(\"L\");\r\n\t\t\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet hole: IPoint[] = [];\r\n\t\t\t\t\t\t\t\t\tareaAndHole.push(hole);\r\n\t\t\t\t\t\t\t\t\tfor (let p = pointsArr.length - 1; p >= 0; p--) {\r\n\t\t\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\t\t\thole.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setPropertyValue(\"points\", points);\r\n\t\t\tthis._currentPoints = points;\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\t/**\r\n\t * Current points. Used when morphing the element, so that original `points`\r\n\t * are not overwritten.\r\n\t *\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set currentPoints(points: Array<Array<Array<IPoint>>>) {\r\n\t\tif (this._currentPoints != points) {\r\n\t\t\tthis._currentPoints = points;\r\n\t\t\tthis.draw();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get currentPoints(): Array<Array<Array<IPoint>>> {\r\n\t\tif((!this._currentPoints || this._currentPoints.length == 0) && this.path){\r\n\t\t\tthis._currentPoints = this.points;\r\n\t\t}\r\n\t\treturn this._currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tlet path: string = \"\";\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this._currentPoints;\r\n\r\n\t\tlet left: $type.Optional<number>;\r\n\t\tlet right: $type.Optional<number>;\r\n\t\tlet top: $type.Optional<number>;\r\n\t\tlet bottom: $type.Optional<number>;\r\n\r\n\t\tif (points.length > 0) {\r\n\t\t\t// separate areas\r\n\t\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\t\t// surface\r\n\t\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\t\tif (surface && surface.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = surface[0];\r\n\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let s: number = 0; s < surface.length; s++) {\r\n\t\t\t\t\t\tpoint = surface[s];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(right) || (right < point.x)) {\r\n\t\t\t\t\t\t\tright = point.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(left) || (left > point.x)) {\r\n\t\t\t\t\t\t\tleft = point.x;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(top) || (top > point.y)) {\r\n\t\t\t\t\t\t\ttop = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n\t\t\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// hole\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = hole[0];\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let h = 0, hlen = hole.length; h < hlen; h++) {\r\n\t\t\t\t\t\tpoint = hole[h];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (path) {\r\n\t\t\t\tpath += $path.closePath();\r\n\t\t\t}\r\n\r\n\t\t\tthis.bbox.x = left;\r\n\t\t\tthis.bbox.y = top;\r\n\t\t\tthis.bbox.width = right - left;\r\n\t\t\tthis.bbox.height = bottom - top;\r\n\r\n\t\t\tsuper.setPath(path);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected setPath(value: string): boolean {\r\n\t\tif (super.setPath(value)) {\r\n\t\t\tthis.points = [];\r\n\t\t\tthis._bbox = this.group.getBBox();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Measures element\r\n\t */\r\n\tprotected measureElement(): void {\r\n\r\n\t\t// Overriding to avoid extra measurement.\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A calculated center point for the shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center\r\n\t */\r\n\tpublic get centerPoint(): IPoint {\r\n\t\treturn { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Morpher]] instance that is used to morph polygon into some other\r\n\t * shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Morpher instance\r\n\t */\r\n\tpublic get morpher(): Morpher {\r\n\t\tif (!this._morpher) {\r\n\t\t\tthis._morpher = new Morpher(this);\r\n\t\t\tthis._disposers.push(this._morpher);\r\n\t\t}\r\n\t\treturn this._morpher;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"]},"metadata":{},"sourceType":"module"}