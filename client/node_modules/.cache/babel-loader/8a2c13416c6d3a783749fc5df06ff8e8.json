{"ast":null,"code":"import * as $array from \"./Array\";\nexport function keys(object) {\n  return Object.keys(object);\n}\n/**\r\n * Returns an array of object's property names ordered using specific ordering\r\n * function.\r\n *\r\n * @param object  Source object\r\n * @param order   Ordering function\r\n * @returns Object property names\r\n */\n\nexport function keysOrdered(object, order) {\n  return keys(object).sort(order);\n}\nexport function copy(object) {\n  return Object.assign({}, object);\n}\nexport function each(object, f) {\n  keys(object).forEach(function (key) {\n    f(key, object[key]);\n  });\n}\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * If return value of the function evaluates to `false` further iteration is\r\n * cancelled.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\n\nexport function eachContinue(object, fn) {\n  for (var key in object) {\n    if (hasKey(object, key)) {\n      if (!fn(key, object[key])) {\n        break;\n      }\n    }\n  }\n}\n/**\r\n * Orders object properties using custom `ord` function and iterates through\r\n * them calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n * @param order   Ordering function\r\n */\n\nexport function eachOrdered(object, fn, ord) {\n  $array.each(keysOrdered(object, ord), function (key) {\n    fn(key, object[key]);\n  });\n}\n/**\r\n * Checks if `object` has a specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Has key?\r\n */\n\nexport function hasKey(object, key) {\n  return {}.hasOwnProperty.call(object, key);\n}\n/**\r\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.\r\n *\r\n * @param fromObject  Source object\r\n * @param toObject    Target object\r\n * @return Updated target object\r\n * @todo Maybe consolidate with utils.copy?\r\n */\n\nexport function softCopyProperties(source, target) {\n  each(source, function (key, value) {\n    // only if value is set\n    //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n    if (value != null && target[key] == null) {\n      target[key] = value;\n    }\n  });\n  return target;\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,MAAZ,MAAwB,SAAxB;AAGA,OAAM,SAAUC,IAAV,CAAkBC,MAAlB,EAA2B;EAChC,OAAOC,MAAM,CAACF,IAAP,CAAYC,MAAZ,CAAP;AACA;AAED;;;;;;;;;AAQA,OAAM,SAAUE,WAAV,CAA8BF,MAA9B,EAA8CG,KAA9C,EAAmG;EACxG,OAAOJ,IAAI,CAACC,MAAD,CAAJ,CAAaI,IAAb,CAAkBD,KAAlB,CAAP;AACA;AAED,OAAM,SAAUE,IAAV,CAAkBL,MAAlB,EAA2B;EAChC,OAAOC,MAAM,CAACK,MAAP,CAAc,EAAd,EAAkBN,MAAlB,CAAP;AACA;AAED,OAAM,SAAUO,IAAV,CAAkBP,MAAlB,EAA6BQ,CAA7B,EAAoG;EACzGT,IAAI,CAACC,MAAD,CAAJ,CAAaS,OAAb,CAAqB,UAACC,GAAD,EAAI;IACxBF,CAAC,CAACE,GAAD,EAAMV,MAAM,CAACU,GAAD,CAAZ,CAAD;EACA,CAFD;AAGA;AAED;;;;;;;;;;AASA,OAAM,SAAUC,YAAV,CAA+BX,MAA/B,EAA+CY,EAA/C,EAAuH;EAC5H,KAAK,IAAIF,GAAT,IAAgBV,MAAhB,EAAwB;IACvB,IAAIa,MAAM,CAACb,MAAD,EAASU,GAAT,CAAV,EAAyB;MACxB,IAAI,CAACE,EAAE,CAACF,GAAD,EAAuBV,MAAM,CAACU,GAAD,CAA7B,CAAP,EAAqE;QACpE;MACA;IACD;EACD;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAUI,WAAV,CAA8Bd,MAA9B,EAA8CY,EAA9C,EAAqHG,GAArH,EAAwK;EAC7KjB,MAAM,CAACS,IAAP,CAAYL,WAAW,CAACF,MAAD,EAASe,GAAT,CAAvB,EAAsC,UAACL,GAAD,EAAI;IACzCE,EAAE,CAACF,GAAD,EAAMV,MAAM,CAACU,GAAD,CAAZ,CAAF;EACA,CAFD;AAGA;AAED;;;;;;;;AAOA,OAAM,SAAUG,MAAV,CAAmDb,MAAnD,EAAmEU,GAAnE,EAA2E;EAChF,OAAO,GAAGM,cAAH,CAAkBC,IAAlB,CAAuBjB,MAAvB,EAA+BU,GAA/B,CAAP;AACA;AAED;;;;;;;;;AAQA,OAAM,SAAUQ,kBAAV,CAA6BC,MAA7B,EAA6CC,MAA7C,EAA2D;EAChEb,IAAI,CAACY,MAAD,EAAS,UAACT,GAAD,EAAMW,KAAN,EAAW;IACvB;IACA;IACA,IAAIA,KAAK,IAAI,IAAT,IAAuBD,MAAO,CAACV,GAAD,CAAP,IAAgB,IAA3C,EAAiD;MAC1CU,MAAO,CAACV,GAAD,CAAP,GAAeW,KAAf;IACN;EACD,CANG,CAAJ;EAOA,OAAOD,MAAP;AACA","names":["$array","keys","object","Object","keysOrdered","order","sort","copy","assign","each","f","forEach","key","eachContinue","fn","hasKey","eachOrdered","ord","hasOwnProperty","call","softCopyProperties","source","target","value"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/Object.ts"],"sourcesContent":["import * as $array from \"./Array\";\nimport type { Keyof } from \"./Type\";\n\nexport function keys<O>(object: O): Array<Keyof<O>> {\n\treturn Object.keys(object) as Array<Keyof<O>>;\n}\n\n/**\n * Returns an array of object's property names ordered using specific ordering\n * function.\n *\n * @param object  Source object\n * @param order   Ordering function\n * @returns Object property names\n */\nexport function keysOrdered<Object>(object: Object, order: (a: Keyof<Object>, b: Keyof<Object>) => number): Array<Keyof<Object>> {\n\treturn keys(object).sort(order);\n}\n\nexport function copy<O>(object: O): O {\n\treturn Object.assign({}, object);\n}\n\nexport function each<O>(object: O, f: <K extends keyof O>(key: K, value: Exclude<O[K], undefined>) => void): void {\n\tkeys(object).forEach((key) => {\n\t\tf(key, object[key] as any);\n\t});\n}\n\n/**\n * Iterates through all properties of the object calling `fn` for each of them.\n *\n * If return value of the function evaluates to `false` further iteration is\n * cancelled.\n *\n * @param object  Source object\n * @param fn      Callback function\n */\nexport function eachContinue<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => boolean): void {\n\tfor (let key in object) {\n\t\tif (hasKey(object, key)) {\n\t\t\tif (!fn(key as Keyof<Object>, object[key] as Object[Keyof<Object>])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Orders object properties using custom `ord` function and iterates through\n * them calling `fn` for each of them.\n *\n * @param object  Source object\n * @param fn      Callback function\n * @param order   Ordering function\n */\nexport function eachOrdered<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => void, ord: (a: Keyof<Object>, b: Keyof<Object>) => number): void {\n\t$array.each(keysOrdered(object, ord), (key) => {\n\t\tfn(key, object[key]);\n\t});\n}\n\n/**\n * Checks if `object` has a specific `key`.\n *\n * @param object  Source object\n * @param key     Property name\n * @returns Has key?\n */\nexport function hasKey<Object, Key extends keyof Object>(object: Object, key: Key): boolean {\n\treturn {}.hasOwnProperty.call(object, key);\n}\n\n/**\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.\n *\n * @param fromObject  Source object\n * @param toObject    Target object\n * @return Updated target object\n * @todo Maybe consolidate with utils.copy?\n */\nexport function softCopyProperties(source: Object, target: Object): Object {\n\teach(source, (key, value) => {\n\t\t// only if value is set\n\t\t//if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n\t\tif (value != null && (<any>target)[key] == null) {\n\t\t\t(<any>target)[key] = value;\n\t\t}\n\t});\n\treturn target;\n}\n"]},"metadata":{},"sourceType":"module"}