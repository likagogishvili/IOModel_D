{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  __extends(DateAxis, _super);\n\n  function DateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_seriesDataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_baseDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_intervalMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_intervalMin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n\n      this._setBaseInterval(this.get(\"baseInterval\"));\n\n      this.on(\"baseInterval\", function () {\n        _this._setBaseInterval(_this.get(\"baseInterval\"));\n      });\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_setBaseInterval\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      this.setPrivateRaw(\"baseInterval\", interval);\n      this._baseDuration = $time.getIntervalDuration(interval);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixZoomFactor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        this._fixZoomFactor();\n\n        var groupInterval = this.getPrivate(\"groupInterval\");\n\n        if (groupInterval) {\n          this._setBaseInterval(groupInterval);\n        } else {\n          this._setBaseInterval(this.get(\"baseInterval\"));\n        }\n\n        if (this.isDirty(\"groupInterval\")) {\n          var groupInterval_1 = this.get(\"groupInterval\");\n\n          if (groupInterval_1) {\n            this.setRaw(\"groupIntervals\", [groupInterval_1]);\n          }\n        }\n\n        if (this.isDirty(\"groupData\")) {\n          if (!this._dataGrouped) {\n            if (this.get(\"groupData\")) {\n              $array.each(this.series, function (series) {\n                _this._groupSeriesData(series);\n              });\n\n              this._handleRangeChange();\n            } else {\n              var baseInterval = this.get(\"baseInterval\");\n              var mainDataSetId_1 = baseInterval.timeUnit + baseInterval.count;\n              $array.each(this.series, function (series) {\n                series.setDataSet(mainDataSetId_1);\n              });\n\n              this._setBaseInterval(baseInterval);\n\n              this.setPrivateRaw(\"groupInterval\", undefined);\n              this.markDirtyExtremes();\n            }\n\n            this._dataGrouped = true;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupSeriesData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      var _this = this;\n\n      if (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n        this._dataGrouped = true; // helps to avoid double grouping\n\n        this._seriesDataGrouped = true; // make array of intervals which will be used;\n\n        var intervals_1 = [];\n        var baseDuration_1 = this.baseMainDuration();\n        var groupIntervals = this.get(\"groupIntervals\");\n\n        if (groupIntervals) {}\n\n        $array.each(groupIntervals, function (interval) {\n          var intervalDuration = $time.getIntervalDuration(interval);\n\n          if (intervalDuration > baseDuration_1) {\n            intervals_1.push(interval);\n          }\n        });\n        series._dataSets = {};\n        var key_1 = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n        var fields_1;\n        var baseAxis = series.get(\"baseAxis\");\n\n        if (series.get(\"xAxis\") === baseAxis) {\n          fields_1 = series._valueYFields;\n        } else if (series.get(\"yAxis\") === baseAxis) {\n          fields_1 = series._valueXFields;\n        }\n\n        var dataItems_1 = series._mainDataItems;\n        var baseInterval = this.get(\"baseInterval\");\n        var mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n        series._dataSets[mainDataSetId] = dataItems_1;\n        var groupCallback_1 = series.get(\"groupDataCallback\");\n        var groupOriginals_1 = series.get(\"groupDataWithOriginals\", false);\n\n        if (groupCallback_1) {\n          groupOriginals_1 = true;\n        }\n\n        $array.each(intervals_1, function (interval) {\n          var previousTime = -Infinity;\n          var dataSetId = interval.timeUnit + interval.count;\n          series._dataSets[dataSetId] = [];\n          var newDataItem;\n          var sum = {};\n          var count = {};\n          var groupFieldValues = {};\n          var workingFields = {};\n          $array.each(fields_1, function (field) {\n            sum[field] = 0;\n            count[field] = 0;\n            groupFieldValues[field] = series.get(field + \"Grouped\");\n            workingFields[field] = field + \"Working\";\n          });\n          var intervalDuration = $time.getDuration(interval.timeUnit);\n          var firstItem = dataItems_1[0];\n          var firstDate;\n\n          if (firstItem) {\n            firstDate = new Date(dataItems_1[0].get(key_1));\n          }\n\n          var prevNewDataItem;\n          $array.each(dataItems_1, function (dataItem) {\n            var time = dataItem.get(key_1);\n            var roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, _this._root.locale.firstDayOfWeek, _this._root.utc, firstDate, _this._root.timezone).getTime();\n            var dataContext;\n\n            if (previousTime < roundedTime - intervalDuration / 24) {\n              dataContext = $object.copy(dataItem.dataContext);\n              newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n              newDataItem.setRaw(key_1, roundedTime);\n\n              series._dataSets[dataSetId].push(newDataItem);\n\n              $array.each(fields_1, function (field) {\n                var value = dataItem.get(field);\n\n                if ($type.isNumber(value)) {\n                  newDataItem.setRaw(field, value);\n                  newDataItem.setRaw(workingFields[field], value);\n                  count[field]++;\n                  sum[field] += value;\n                }\n              });\n\n              if (groupOriginals_1) {\n                newDataItem.set(\"originals\", [dataItem]);\n              }\n\n              if (groupCallback_1 && prevNewDataItem) {\n                groupCallback_1(prevNewDataItem, interval);\n              }\n\n              prevNewDataItem = newDataItem;\n            } else {\n              $array.each(fields_1, function (field) {\n                var groupKey = groupFieldValues[field];\n                var value = dataItem.get(field);\n\n                if (value !== undefined) {\n                  var currentValue = newDataItem.get(field);\n\n                  switch (groupKey) {\n                    case \"close\":\n                      newDataItem.setRaw(field, value);\n                      break;\n\n                    case \"sum\":\n                      newDataItem.setRaw(field, currentValue + value);\n                      break;\n\n                    case \"open\":\n                      break;\n\n                    case \"low\":\n                      if (value < currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"high\":\n                      if (value > currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"average\":\n                      count[field]++;\n                      sum[field] += value;\n                      var average = sum[field] / count[field];\n                      newDataItem.setRaw(field, average);\n                      break;\n\n                    case \"extreme\":\n                      if (Math.abs(value) > Math.abs(currentValue)) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n                  }\n\n                  newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                  var dataContext_1 = $object.copy(dataItem.dataContext);\n                  dataContext_1[key_1] = roundedTime;\n                  newDataItem.dataContext = dataContext_1;\n                }\n              });\n\n              if (groupOriginals_1) {\n                newDataItem.get(\"originals\").push(dataItem);\n              }\n            }\n\n            previousTime = roundedTime;\n          });\n\n          if (groupCallback_1 && prevNewDataItem) {\n            groupCallback_1(prevNewDataItem, interval);\n          }\n        });\n\n        if (series._dataSetId) {\n          series.setDataSet(series._dataSetId);\n        }\n\n        this.markDirtySize();\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._clearDirty.call(this);\n\n      this._groupingCalculated = false;\n      this._dataGrouped = false;\n    }\n  });\n  /**\r\n   * Returns a time interval axis would group data to for a specified duration.\r\n   *\r\n   * @since 5.2.1\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getGroupInterval\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (duration) {\n      var baseInterval = this.get(\"baseInterval\");\n      var groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\"));\n\n      if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n        groupInterval = __assign({}, baseInterval);\n      }\n\n      return groupInterval;\n    }\n  });\n  /**\r\n   * Return `max` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Max\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getIntervalMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      return this._intervalMax[interval.timeUnit + interval.count];\n    }\n  });\n  /**\r\n   * Return `min` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Min\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getIntervalMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      return this._intervalMin[interval.timeUnit + interval.count];\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._handleRangeChange.call(this);\n\n      var selectionMin = this.getPrivate(\"selectionMin\");\n      var selectionMax = this.getPrivate(\"selectionMax\");\n\n      if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n        if (this.get(\"groupData\") && !this._groupingCalculated) {\n          this._groupingCalculated = true;\n          var modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n          var groupInterval = this.get(\"groupInterval\");\n\n          if (!groupInterval) {\n            groupInterval = this.getGroupInterval(modifiedDifference);\n          }\n\n          var current = this.getPrivate(\"groupInterval\");\n\n          if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count || this._seriesDataGrouped)) {\n            this._seriesDataGrouped = false;\n            this.setPrivateRaw(\"groupInterval\", groupInterval);\n\n            this._setBaseInterval(groupInterval);\n\n            if (groupInterval) {\n              var newId_1 = groupInterval.timeUnit + groupInterval.count;\n              $array.each(this.series, function (series) {\n                if (series.get(\"baseAxis\") === _this) {\n                  series.setDataSet(newId_1);\n                }\n              });\n              this.markDirtyExtremes();\n            }\n          }\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.get(\"baseAxis\") === _this) {\n            var fieldName_1 = _this.getPrivate(\"name\") + _this.get(\"renderer\").getPrivate(\"letter\");\n\n            var start = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMin);\n            });\n            var startIndex = start.index;\n\n            if (startIndex > 0) {\n              startIndex -= 1;\n            }\n\n            var end = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMax);\n            });\n            var endIndex = end.index;\n            var endIndex2 = endIndex;\n\n            if (endIndex2 > 0) {\n              endIndex2--;\n            }\n\n            var firstDataItem = series.dataItems[startIndex];\n            var lastDataItem = series.dataItems[endIndex2];\n            var lastDate = void 0;\n            var firstDate = void 0;\n\n            if (firstDataItem) {\n              firstDate = firstDataItem.get(fieldName_1);\n            }\n\n            if (lastDataItem) {\n              lastDate = lastDataItem.get(fieldName_1);\n            }\n\n            var outOfSelection = false;\n\n            if (lastDate != null && firstDate != null) {\n              if (lastDate < selectionMin || firstDate > selectionMax) {\n                outOfSelection = true;\n              }\n            }\n\n            series.setPrivate(\"outOfSelection\", outOfSelection);\n            series.setPrivate(\"startIndex\", startIndex);\n            series.setPrivate(\"endIndex\", endIndex);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, _strictMode) {\n      return {\n        min: min,\n        max: max,\n        step: (max - min) / gridCount\n      };\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"intervalDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._intervalDuration;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_saveMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max) {\n      var groupInterval = this.getPrivate(\"groupInterval\");\n\n      if (!groupInterval) {\n        groupInterval = this.get(\"baseInterval\");\n      }\n\n      var id = groupInterval.timeUnit + groupInterval.count;\n      this._intervalMin[id] = min;\n      this._intervalMax[id] = max;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin = this.getPrivate(\"selectionMin\");\n        var selectionMax = this.getPrivate(\"selectionMax\");\n        var renderer = this.get(\"renderer\");\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var value = selectionMin;\n        var i = 0;\n        var intervals = this.get(\"gridIntervals\");\n        var gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n        if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n          gridInterval = __assign({}, baseInterval);\n        }\n\n        var intervalDuration = $time.getIntervalDuration(gridInterval);\n        this._intervalDuration = intervalDuration;\n        var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n        value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min), this._root.timezone).getTime();\n        var previousValue = value - intervalDuration;\n        var format = void 0;\n        var formats = this.get(\"dateFormats\");\n        this.setPrivateRaw(\"gridInterval\", gridInterval);\n\n        while (value < selectionMax + intervalDuration) {\n          var dataItem = void 0;\n\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n\n            this._dataItems.push(dataItem);\n\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n\n          this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          dataItem.setRaw(\"value\", value);\n          dataItem.setRaw(\"endValue\", $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime()); //$time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n\n          var date = new Date(value);\n          format = formats[gridInterval.timeUnit];\n\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if (gridInterval.timeUnit != \"year\") {\n              if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\n                format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n              }\n            }\n          }\n\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", this._root.dateFormatter.format(date, format));\n          }\n\n          this._prepareDataItem(dataItem, gridInterval.count);\n\n          previousValue = value;\n          value = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n          i++;\n        }\n\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n    }\n  });\n  /* goes up to the year\r\n  protected _getFormat(timeUnit: TimeUnit, value: number, previousValue: number) {\r\n      const formats = this.get(\"dateFormats\")!;\r\n      let format = formats[timeUnit];\r\n        if (this.get(\"markUnitChange\")) {\r\n          let nextGridUnit = $time.getNextUnit(timeUnit);\r\n            while (nextGridUnit != undefined) {\r\n                if (nextGridUnit) {\r\n                  if (timeUnit != \"year\") {\r\n                      if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\r\n                          format = this.get(\"periodChangeDateFormats\")![timeUnit];\r\n                          timeUnit = nextGridUnit;\r\n                          nextGridUnit = $time.getNextUnit(nextGridUnit);\r\n                      }\r\n                      else {\r\n                          nextGridUnit = undefined;\r\n                      }\r\n                  }\r\n                  else {\r\n                      nextGridUnit = undefined;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      return format;\r\n  }\r\n  */\n\n  Object.defineProperty(DateAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_updateDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_date) {}\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._baseDuration; //return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseMainDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.get(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"processSeriesDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, fields) {\n      var _this = this;\n\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if (!dataItem.open) {\n        dataItem.open = {};\n      }\n\n      if (!dataItem.close) {\n        dataItem.close = {};\n      }\n\n      $array.each(fields, function (field) {\n        var value = dataItem.get(field);\n\n        if ($type.isNumber(value)) {\n          var startTime = dataItem.open[field];\n          var endTime = dataItem.close[field]; // this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n          // if value is between prev start and end, it means it didn't change, all is fine.\n\n          if (value >= startTime && value <= endTime) {} else {\n            startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, _this._root.locale.firstDayOfWeek, _this._root.utc, undefined, _this._root.timezone).getTime();\n            endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, _this._root.utc).getTime();\n            dataItem.open[field] = startTime;\n            dataItem.close[field] = endTime;\n          }\n\n          _this._updateDates(startTime);\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, location) {\n      var value = this.positionToValue(position);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if (!$type.isNaN(value)) {\n        value = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(this.getPrivate(\"min\", 0)), this._root.timezone).getTime();\n        var endValue = value;\n\n        if (location > 0) {\n          endValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n        }\n\n        return this.valueToPosition(value + (endValue - value) * location);\n      }\n\n      return NaN;\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      if (this.getPrivate(\"min\") != null) {\n        var format = this.get(\"tooltipDateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        var date = new Date(this.positionToValue(position));\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n        return this._root.dateFormatter.format(new Date(this.positionToValue(position) + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration), this.get(\"tooltipDateFormat\", format));\n      }\n\n      return \"\";\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n      var result = $array.getSortedIndex(series.dataItems, function (dataItem) {\n        var diValue = 0;\n\n        if (dataItem.open) {\n          diValue = dataItem.open[fieldName];\n        }\n\n        return $order.compare(diValue, value);\n      });\n\n      if (series.get(\"snapTooltip\")) {\n        var first = series.dataItems[result.index - 1];\n        var second = series.dataItems[result.index];\n\n        if (first && second) {\n          if (first.open && second.close) {\n            var open_1 = first.open[fieldName];\n            var close_1 = second.close[fieldName];\n\n            if (Math.abs(value - open_1) > Math.abs(value - close_1)) {\n              return second;\n            }\n          }\n        }\n\n        return first;\n      } else {\n        // @todo check if is in range\n        var dataItem = series.dataItems[result.index - 1];\n\n        if (dataItem) {\n          if (dataItem.open && dataItem.close) {\n            var open_2 = dataItem.open[fieldName];\n            var close_2 = dataItem.close[fieldName];\n\n            if (value >= open_2 && value <= close_2) {\n              return dataItem;\n            }\n          }\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"shouldGap\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, nextItem, autoGapCount, fieldName) {\n      var value1 = dataItem.get(fieldName);\n      var value2 = nextItem.get(fieldName);\n\n      if (value2 - value1 > this.baseDuration() * autoGapCount) {\n        return true;\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"zoomToDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      this.zoomToValues(start.getTime(), end.getTime(), duration);\n    }\n  });\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"positionToDate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      return new Date(this.positionToValue(position));\n    }\n  });\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"dateToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date) {\n      return this.valueToPosition(date.getTime());\n    }\n  });\n  Object.defineProperty(DateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DateAxis\"\n  });\n  Object.defineProperty(DateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DateAxis.className])\n  });\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis };","map":{"version":3,"mappings":"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","names":["DataItem","ValueAxis","$type","$order","$array","$object","$utils","$time","__extends","Object","_settings","themeTags","mergeTags","_super","_afterNew","call","_setBaseInterval","get","on","_this","interval","setPrivateRaw","_baseDuration","getIntervalDuration","Math","round","getPrivate","baseMainDuration","min","max","isNumber","_fixZoomFactor","groupInterval","isDirty","groupInterval_1","setRaw","_dataGrouped","each","series","_groupSeriesData","_handleRangeChange","baseInterval","mainDataSetId_1","timeUnit","count","setDataSet","undefined","markDirtyExtremes","_seriesDataGrouped","intervals_1","baseDuration_1","groupIntervals","intervalDuration","push","_dataSets","key_1","fields_1","baseAxis","_valueYFields","_valueXFields","dataItems_1","_mainDataItems","mainDataSetId","groupCallback_1","groupOriginals_1","previousTime","Infinity","dataSetId","newDataItem","sum","groupFieldValues","workingFields","field","getDuration","firstItem","firstDate","Date","prevNewDataItem","dataItem","time","roundedTime","_root","locale","firstDayOfWeek","utc","timezone","getTime","dataContext","copy","_makeDataItem","value","set","groupKey","currentValue","average","abs","dataContext_1","_dataSetId","markDirtySize","_clearDirty","_groupingCalculated","duration","chooseInterval","_intervalMax","_intervalMin","selectionMin","selectionMax","modifiedDifference","baseDuration","getGroupInterval","current","newId_1","fieldName_1","start","getSortedIndex","dataItems","compare","startIndex","index","end","endIndex","endIndex2","firstDataItem","lastDataItem","lastDate","outOfSelection","setPrivate","gridCount","_strictMode","step","_intervalDuration","id","renderer","i","intervals","gridInterval","nextGridUnit","getNextUnit","previousValue","format","formats","length","_dataItems","processDataItem","_createAssets","isHidden","show","add","date","checkChange","label","dateFormatter","_prepareDataItem","j","hide","inited","_markDirtyAxes","_updateGhost","startTime","endTime","_date","fields","open","close","_updateDates","cellLocation","axisLocation","openValue","closeValue","_baseValue","valueToPosition","positionToCoordinate","getDataItemPositionX","getDataItemPositionY","position","location","positionToValue","isNaN","endValue","NaN","getDateIntervalDuration","fieldName","result","diValue","first","second","open_1","close_1","open_2","close_2","nextItem","autoGapCount","value1","value2","zoomToValues","classNames","concat","DateAxis","className"],"sourceRoot":"","sources":["../../../../../../src/.internal/charts/xy/axes/DateAxis.ts"],"sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { XYSeries, IXYSeriesDataItem } from \"../series/XYSeries\";\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IMinMaxStep, IValueAxisEvents } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\n\nexport interface IDateAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n\n\t/**\n\t * Should axis group data items togeter dynamically?\n\t *\n\t * @default false\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupData?: boolean;\n\n\t/**\n\t * Maximum number of data items in the view before data grouping kicks in.\n\t *\n\t * @default 500\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupCount?: number;\n\n\t/**\n\t * Force data item grouping to specific interval.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to group data items into.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t */\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\n\n\t/**\n\t * Time unit-specific formats to use for axis tooltip.\n\t * \n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A value which indicates relative position within axis cell to get timestamp\n\t * for the tooltip from.\n\t *\n\t * Values are from `0` (zero) to `1` (one), meaning start and end of the cell.\n\t *\n\t * If not set, it will use cell's start tiemstamp.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Axis_tooltip} for more info\n\t * @since 5.1.4\n\t */\n\ttooltipIntervalOffset?: number;\n\n}\n\nexport interface IDateAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDateAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * Current group interval.\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Current grid interval.\n\t */\n\tgridInterval: ITimeInterval;\n}\n\nexport interface IDateAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\n * @important\n */\nexport class DateAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DateAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DateAxis.className]);\n\n\tdeclare public _settings: IDateAxisSettings<R>;\n\tdeclare public _privateSettings: IDateAxisPrivate;\n\tdeclare public _dataItemSettings: IDateAxisDataItem;\n\tdeclare public _events: IDateAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _seriesDataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\tprotected _baseDuration: number = 1;\n\n\tprotected _intervalMax: { [index: string]: number } = {};\n\tprotected _intervalMin: { [index: string]: number } = {};\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\tthis.on(\"baseInterval\", () => {\n\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t})\n\t}\n\n\tprotected _setBaseInterval(interval: ITimeInterval) {\n\t\tthis.setPrivateRaw(\"baseInterval\", interval);\n\t\tthis._baseDuration = $time.getIntervalDuration(interval);\n\t}\n\n\tprotected _fixZoomFactor() {\n\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n\t}\n\n\tprotected _groupData() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif (($type.isNumber(min) && $type.isNumber(max))) {\n\n\t\t\tthis._fixZoomFactor();\n\n\t\t\tconst groupInterval = this.getPrivate(\"groupInterval\")!;\n\t\t\tif (groupInterval) {\n\t\t\t\tthis._setBaseInterval(groupInterval);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._setBaseInterval(this.get(\"baseInterval\"));\n\t\t\t}\n\n\n\t\t\tif (this.isDirty(\"groupInterval\")) {\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\")!;\n\t\t\t\tif (groupInterval) {\n\t\t\t\t\tthis.setRaw(\"groupIntervals\", [groupInterval]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isDirty(\"groupData\")) {\n\t\t\t\tif (!this._dataGrouped) {\n\t\t\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tthis._groupSeriesData(series);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._handleRangeChange();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\t\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tseries.setDataSet(mainDataSetId);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis._setBaseInterval(baseInterval);\n\t\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", undefined);\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t\tthis._dataGrouped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _groupSeriesData(series: XYSeries) {\n\t\tif (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n\n\t\t\tthis._dataGrouped = true; // helps to avoid double grouping\n\n\t\t\tthis._seriesDataGrouped = true;\n\n\t\t\t// make array of intervals which will be used;\n\t\t\tlet intervals: ITimeInterval[] = [];\n\t\t\tlet baseDuration = this.baseMainDuration();\n\n\t\t\tlet groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\tif (groupIntervals) { }\n\t\t\t$array.each(groupIntervals, (interval) => {\n\t\t\t\tlet intervalDuration = $time.getIntervalDuration(interval);\n\t\t\t\tif (intervalDuration > baseDuration) {\n\t\t\t\t\tintervals.push(interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tseries._dataSets = {};\n\n\t\t\tconst key = this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!;\n\t\t\tlet fields: Array<string>;\n\n\t\t\tconst baseAxis = series.get(\"baseAxis\");\n\n\t\t\tif (series.get(\"xAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueYFields;\n\t\t\t}\n\t\t\telse if (series.get(\"yAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueXFields;\n\t\t\t}\n\n\t\t\tlet dataItems = series._mainDataItems;\n\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\tseries._dataSets[mainDataSetId] = dataItems;\n\n\t\t\tconst groupCallback = series.get(\"groupDataCallback\");\n\t\t\tlet groupOriginals = series.get(\"groupDataWithOriginals\", false);\n\t\t\tif (groupCallback) {\n\t\t\t\tgroupOriginals = true;\n\t\t\t}\n\n\t\t\t$array.each(intervals, (interval) => {\n\n\t\t\t\tlet previousTime = -Infinity;\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\n\t\t\t\tseries._dataSets[dataSetId] = [];\n\n\t\t\t\tlet newDataItem: DataItem<IXYSeriesDataItem>;\n\n\t\t\t\tlet sum: { [index: string]: number } = {};\n\t\t\t\tlet count: { [index: string]: number } = {};\n\n\t\t\t\tlet groupFieldValues: { [index: string]: string } = {};\n\t\t\t\tlet workingFields: { [index: string]: string } = {};\n\n\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\tgroupFieldValues[field] = series.get((field + \"Grouped\") as any);\n\t\t\t\t\tworkingFields[field] = field + \"Working\";\n\t\t\t\t})\n\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit);\n\n\t\t\t\tlet firstItem = dataItems[0];\n\t\t\t\tlet firstDate: Date;\n\t\t\t\tif (firstItem) {\n\t\t\t\t\tfirstDate = new Date(dataItems[0].get(key as any));\n\t\t\t\t}\n\n\t\t\t\tlet prevNewDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\n\t\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\t\tlet time = dataItem.get(key as any);\n\t\t\t\t\tlet roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone).getTime();\n\t\t\t\t\tlet dataContext: any;\n\n\t\t\t\t\tif (previousTime < roundedTime - intervalDuration / 24) {\n\t\t\t\t\t\tdataContext = $object.copy(dataItem.dataContext);\n\n\t\t\t\t\t\tnewDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\t\t\t\t\t\tnewDataItem.setRaw(key as any, roundedTime);\n\n\t\t\t\t\t\tseries._dataSets[dataSetId].push(newDataItem);\n\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif ($type.isNumber(value)) {\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, value);\n\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.set(\"originals\", [dataItem]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprevNewDataItem = newDataItem;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet groupKey = groupFieldValues[field];\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\n\t\t\t\t\t\t\tif (value !== undefined) {\n\n\t\t\t\t\t\t\t\tlet currentValue = newDataItem.get(field as any);\n\n\t\t\t\t\t\t\t\tswitch (groupKey) {\n\t\t\t\t\t\t\t\t\tcase \"close\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, currentValue + value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"open\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"low\":\n\t\t\t\t\t\t\t\t\t\tif (value < currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"high\":\n\t\t\t\t\t\t\t\t\t\tif (value > currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"average\":\n\t\t\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t\t\t\tlet average = sum[field] / count[field];\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, average);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"extreme\":\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(value) > Math.abs(currentValue)) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, newDataItem.get(field as any));\n\t\t\t\t\t\t\t\tlet dataContext: any = $object.copy(dataItem.dataContext);\n\t\t\t\t\t\t\t\tdataContext[key as any] = roundedTime;\n\t\t\t\t\t\t\t\tnewDataItem.dataContext = dataContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (groupOriginals) {\n\t\t\t\t\t\t\tnewDataItem.get(\"originals\")!.push(dataItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousTime = roundedTime;\n\t\t\t\t})\n\n\t\t\t\tif (groupCallback && prevNewDataItem) {\n\t\t\t\t\tgroupCallback(prevNewDataItem, interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (series._dataSetId) {\n\t\t\t\tseries.setDataSet(series._dataSetId);\n\t\t\t}\n\t\t\tthis.markDirtySize();\n\t\t}\n\t}\n\n\tpublic _clearDirty() {\n\t\tsuper._clearDirty();\n\t\tthis._groupingCalculated = false;\n\t\tthis._dataGrouped = false;\n\t}\n\n\t/**\n\t * Returns a time interval axis would group data to for a specified duration.\n\t *\n\t * @since 5.2.1\n\t */\n\tpublic getGroupInterval(duration: number): ITimeInterval {\n\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\tlet groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\")!);\n\t\tif ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n\t\t\tgroupInterval = { ...baseInterval };\n\t\t}\n\t\treturn groupInterval;\n\t}\n\n\t/**\n\t * Return `max` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Max\n\t */\n\tpublic getIntervalMax(interval: ITimeInterval): number {\n\t\treturn this._intervalMax[interval.timeUnit + interval.count];\n\t}\n\n\t/**\n\t * Return `min` of a specified time interval.\n\t * \n\t * Will work only if the axis was grouped to this interval at least once.\n\t * \n\t * @since 5.2.1\n\t * @param   interval  Interval\n\t * @return            Min\n\t */\n\tpublic getIntervalMin(interval: ITimeInterval): number {\n\t\treturn this._intervalMin[interval.timeUnit + interval.count];\n\t}\n\n\tprotected _handleRangeChange() {\n\t\tsuper._handleRangeChange();\n\n\t\tconst selectionMin = this.getPrivate(\"selectionMin\");\n\t\tconst selectionMax = this.getPrivate(\"selectionMax\");\n\n\t\tif ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n\n\t\t\tif (this.get(\"groupData\") && !this._groupingCalculated) {\n\t\t\t\tthis._groupingCalculated = true;\n\n\t\t\t\tlet modifiedDifference = (selectionMax - selectionMin) + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\");\n\n\t\t\t\tif (!groupInterval) {\n\t\t\t\t\tgroupInterval = this.getGroupInterval(modifiedDifference);\n\t\t\t\t}\n\n\t\t\t\tlet current = this.getPrivate(\"groupInterval\");\n\n\t\t\t\tif (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count) || this._seriesDataGrouped)) {\n\t\t\t\t\tthis._seriesDataGrouped = false;\n\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", groupInterval);\n\t\t\t\t\tthis._setBaseInterval(groupInterval)\n\n\t\t\t\t\tif (groupInterval) {\n\t\t\t\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\t\t\t\tseries.setDataSet(newId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\n\t\t\t\t\tconst start = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMin);\n\t\t\t\t\t});\n\n\t\t\t\t\tlet startIndex = start.index;\n\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tstartIndex -= 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst end = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMax);\n\t\t\t\t\t});\n\t\t\t\t\tlet endIndex = end.index;\n\n\t\t\t\t\tlet endIndex2 = endIndex;\n\t\t\t\t\tif (endIndex2 > 0) {\n\t\t\t\t\t\tendIndex2--;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst firstDataItem = series.dataItems[startIndex];\n\t\t\t\t\tconst lastDataItem = series.dataItems[endIndex2];\n\n\t\t\t\t\tlet lastDate: number | undefined;\n\t\t\t\t\tlet firstDate: number | undefined;\n\t\t\t\t\tif (firstDataItem) {\n\t\t\t\t\t\tfirstDate = firstDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lastDataItem) {\n\t\t\t\t\t\tlastDate = lastDataItem.get(fieldName);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet outOfSelection = false;\n\t\t\t\t\tif (lastDate != null && firstDate != null) {\n\t\t\t\t\t\tif (lastDate < selectionMin || firstDate > selectionMax) {\n\t\t\t\t\t\t\toutOfSelection = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tseries.setPrivate(\"outOfSelection\", outOfSelection);\n\t\t\t\t\tseries.setPrivate(\"startIndex\", startIndex);\n\t\t\t\t\tseries.setPrivate(\"endIndex\", endIndex);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, _strictMode?: boolean): IMinMaxStep {\n\t\treturn { min: min, max: max, step: (max - min) / gridCount };\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic intervalDuration(): number {\n\t\treturn this._intervalDuration;\n\t}\n\n\tprotected _saveMinMax(min: number, max: number) {\n\t\tlet groupInterval = this.getPrivate(\"groupInterval\");\n\n\t\tif (!groupInterval) {\n\t\t\tgroupInterval = this.get(\"baseInterval\");\n\t\t}\n\n\t\tlet id = groupInterval.timeUnit + groupInterval.count;\n\t\tthis._intervalMin[id] = min;\n\t\tthis._intervalMax[id] = max;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tconst selectionMin = this.getPrivate(\"selectionMin\")! as number;\n\t\t\tconst selectionMax = this.getPrivate(\"selectionMax\")! as number;\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\t\tlet value = selectionMin;\n\t\t\tlet i = 0;\n\n\t\t\tconst intervals = this.get(\"gridIntervals\")!;\n\t\t\tlet gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n\t\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\t\tgridInterval = { ...baseInterval };\n\t\t\t}\n\n\t\t\tconst intervalDuration = $time.getIntervalDuration(gridInterval);\n\t\t\tthis._intervalDuration = intervalDuration;\n\n\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\n\t\t\tvalue = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min), this._root.timezone).getTime();\n\t\t\tlet previousValue = value - intervalDuration;\n\t\t\tlet format: string | Intl.DateTimeFormatOptions;\n\t\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\t\tthis.setPrivateRaw(\"gridInterval\", gridInterval);\n\n\t\t\twhile (value < selectionMax + intervalDuration) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\t\t\t\tdataItem.setRaw(\"endValue\", $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime()) //$time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem, gridInterval.count);\n\n\t\t\t\tpreviousValue = value;\n\n\t\t\t\tvalue = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis.dataItems[j].hide();\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n\t}\n\t/* goes up to the year\n\tprotected _getFormat(timeUnit: TimeUnit, value: number, previousValue: number) {\n\t\tconst formats = this.get(\"dateFormats\")!;\n\t\tlet format = formats[timeUnit];\n\n\t\tif (this.get(\"markUnitChange\")) {\n\t\t\tlet nextGridUnit = $time.getNextUnit(timeUnit);\n\n\t\t\twhile (nextGridUnit != undefined) {\n\n\t\t\t\tif (nextGridUnit) {\n\t\t\t\t\tif (timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![timeUnit];\n\t\t\t\t\t\t\ttimeUnit = nextGridUnit;\n\t\t\t\t\t\t\tnextGridUnit = $time.getNextUnit(nextGridUnit);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnextGridUnit = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnextGridUnit = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn format;\n\t}\n\t*/\n\tprotected _fixMax(max: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n\t}\n\n\tprotected _updateDates(_date: number) {\n\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t * \n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn this._baseDuration;\n\t\t//return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\t/**\n\t * Returns a duration of user-defined `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseMainDuration(): number {\n\t\treturn $time.getIntervalDuration(this.get(\"baseInterval\"));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic processSeriesDataItem(dataItem: DataItem<IXYSeriesDataItem>, fields: Array<string>) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif (!dataItem.open) {\n\t\t\tdataItem.open = {};\n\t\t}\n\t\tif (!dataItem.close) {\n\t\t\tdataItem.close = {};\n\t\t}\n\n\t\t$array.each(fields, (field) => {\n\t\t\tlet value = dataItem.get(field as any);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet startTime = dataItem.open![field];\n\t\t\t\tlet endTime = dataItem.close![field];\n\t\t\t\t// this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n\t\t\t\t// if value is between prev start and end, it means it didn't change, all is fine.\n\t\t\t\tif (value >= startTime && value <= endTime) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstartTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n\t\t\t\t\tendTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t\t\t\tdataItem.open![field] = startTime;\n\t\t\t\t\tdataItem.close![field] = endTime;\n\t\t\t\t}\n\n\t\t\t\tthis._updateDates(startTime);\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tlet value = this.positionToValue(position);\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tif (!$type.isNaN(value)) {\n\t\t\tvalue = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(this.getPrivate(\"min\", 0)), this._root.timezone).getTime();\n\t\t\tlet endValue = value;\n\t\t\tif (location > 0) {\n\t\t\t\tendValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t\t}\n\t\t\treturn this.valueToPosition(value + (endValue - value) * location);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tif (this.getPrivate(\"min\") != null) {\n\t\t\tlet format = this.get(\"tooltipDateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\tlet date = new Date(this.positionToValue(position));\n\t\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\t\tlet duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n\t\t\treturn this._root.dateFormatter.format(new Date(this.positionToValue(position) + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration), this.get(\"tooltipDateFormat\", format));\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\t\tconst result = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\tvar diValue = 0;\n\t\t\tif (dataItem.open) {\n\t\t\t\tdiValue = dataItem.open[fieldName];\n\t\t\t}\n\n\t\t\treturn $order.compare(diValue, value);\n\t\t});\n\n\t\tif (series.get(\"snapTooltip\")) {\n\t\t\tlet first = series.dataItems[result.index - 1];\n\t\t\tlet second = series.dataItems[result.index];\n\n\t\t\tif (first && second) {\n\t\t\t\tif (first.open && second.close) {\n\t\t\t\t\tlet open = first.open[fieldName];\n\t\t\t\t\tlet close = second.close[fieldName];\n\n\t\t\t\t\tif (Math.abs(value - open) > Math.abs(value - close)) {\n\t\t\t\t\t\treturn second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t}\n\t\telse {\n\t\t\t// @todo check if is in range\n\t\t\tconst dataItem = series.dataItems[result.index - 1];\n\n\t\t\tif (dataItem) {\n\t\t\t\tif (dataItem.open && dataItem.close) {\n\t\t\t\t\tlet open = dataItem.open[fieldName];\n\t\t\t\t\tlet close = dataItem.close[fieldName];\n\n\t\t\t\t\tif (value >= open && value <= close) {\n\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic shouldGap(dataItem: DataItem<IXYSeriesDataItem>, nextItem: DataItem<IXYSeriesDataItem>, autoGapCount: number, fieldName: string): boolean {\n\t\tconst value1 = dataItem.get(fieldName as any);\n\t\tconst value2 = nextItem.get(fieldName as any);\n\n\t\tif (value2 - value1 > this.baseDuration() * autoGapCount) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` dates.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start Date\n\t * @param  end       End Date\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\n\t\tthis.zoomToValues(start.getTime(), end.getTime(), duration);\n\t}\n\n\t/**\n\t * Returns a `Date` object corresponding to specific position within plot\n\t * area.\n\t *\n\t * @param   position  Pposition\n\t * @return            Date\n\t */\n\tpublic positionToDate(position: number): Date {\n\t\treturn new Date(this.positionToValue(position));\n\t}\n\n\t/**\n\t * Returns a relative position within plot area that corresponds to specific\n\t * date.\n\t *\n\t * @param   date  Date\n\t * @return        Position\n\t */\n\tpublic dateToPosition(date: Date): number {\n\t\treturn this.valueToPosition(date.getTime());\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}