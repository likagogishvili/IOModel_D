{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n/**\r\n * @ignore\r\n */\n\nexport function populateString(target, string) {\n  if (string != null) {\n    string = \"\" + string;\n    string = TextFormatter.escape(string);\n    var tags = string.match(/\\{([^}]+)\\}/g);\n    var i = void 0;\n\n    if (tags) {\n      for (i = 0; i < tags.length; i++) {\n        var tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n        var value = getTagValue(target, tag, \"\");\n\n        if (value == null) {\n          value = \"\";\n        }\n\n        string = string.split(tags[i]).join(value);\n      }\n    }\n\n    string = TextFormatter.unescape(string);\n  } else {\n    string = \"\";\n  } // TODO: apply adapter?\n\n\n  return string;\n}\n/**\r\n * @ignore\r\n */\n\nfunction getTagValue(target, tagName, format) {\n  var value;\n  var dataItem = target.dataItem; // Parse parts\n\n  var parts = [];\n  var reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;\n  ;\n  var matches;\n\n  while (true) {\n    matches = reg.exec(tagName);\n\n    if (matches === null) {\n      break;\n    }\n\n    if (matches[3]) {\n      // Simple property\n      parts.push({\n        prop: matches[3]\n      }); // Check if maybe we should force a formatter on this value\n\n      var dateFields = target.getDateFormatter().get(\"dateFields\", []);\n      var numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n      var durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\n      if (dateFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDate\",\n          params: []\n        });\n      } else if (numericFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatNumber\",\n          params: []\n        });\n      } else if (durationFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDuration\",\n          params: []\n        });\n      }\n    } else {\n      // Method\n      // Parse parameters\n      var params = [];\n\n      if ($utils.trim(matches[2]) != \"\") {\n        var reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n        var matches2 = void 0;\n\n        while (true) {\n          matches2 = reg2.exec(matches[2]);\n\n          if (matches2 === null) {\n            break;\n          }\n\n          params.push(matches2[1] || matches2[2] || matches2[3]);\n        }\n      }\n\n      parts.push({\n        method: matches[1],\n        params: params\n      });\n    }\n  } // Check if we can retrieve the value from data item\n\n\n  if (dataItem) {\n    // Check values\n    value = getTagValueFromObject(target, parts, dataItem._settings); // Check properties\n\n    if (value == null || $type.isObject(value)) {\n      // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n      value = getTagValueFromObject(target, parts, dataItem);\n    } // Check data context\n\n\n    var dataContext = dataItem.dataContext;\n\n    if (value == null && dataContext) {\n      value = getTagValueFromObject(target, parts, dataContext); // Maybe it's a literal dot-separated name of the key in dataContext?\n\n      if (value == null) {\n        value = getTagValueFromObject(target, [{\n          prop: tagName\n        }], dataContext);\n      } // scond data context level sometimes exist (tree map)\n\n\n      if (value == null && dataContext.dataContext) {\n        value = getTagValueFromObject(target, parts, dataContext.dataContext);\n      }\n    } // Check component's data item\n\n\n    if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n      value = getTagValue(dataItem.component, tagName, format);\n    }\n  } // Check sprite's properties\n\n\n  if (value == null) {\n    value = getTagValueFromObject(target, parts, target);\n  } // Finally, check the parent\n\n\n  if (value == null && target.parent) {\n    value = getTagValue(target.parent, tagName, format);\n  }\n\n  return value;\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction getCustomDataValue(target, prop) {\n  var customData = target.getPrivate(\"customData\");\n\n  if ($type.isObject(customData)) {\n    return customData[prop];\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nexport function getTagValueFromObject(target, parts, object, format) {\n  var current = object;\n  var formatApplied = false;\n\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n\n    if (part.prop) {\n      // Regular property\n      if (current instanceof Sprite) {\n        var tmp = current.get(part.prop);\n        if (tmp == null) tmp = current.getPrivate(part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        if (tmp == null) tmp = getCustomDataValue(current, part.prop);\n        current = tmp;\n      } else if (current.get) {\n        var tmp = current.get(part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        current = tmp;\n      } else {\n        current = current[part.prop];\n      }\n\n      if (current == null) {\n        // Not set, return undefined\n        return;\n      }\n    } else {\n      // Method\n      switch (part.method) {\n        case \"formatNumber\":\n          var numberValue = $type.toNumber(current);\n\n          if (numberValue != null) {\n            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDate\":\n          var dateValue = $type.toDate(current);\n\n          if (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n            // Was not able to get date out of value, quitting and letting\n            // calling method try another value\n            return;\n          }\n\n          if (dateValue != null) {\n            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDuration\":\n          var durationValue = $type.toNumber(current);\n\n          if (durationValue != null) {\n            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"urlEncode\":\n        case \"encodeURIComponent\":\n          current = encodeURIComponent(current);\n          break;\n\n        default:\n          if (current[part.method]) {\n            current[part.method].apply(object, part.params);\n          }\n\n          break;\n      }\n    }\n  } // Apply default format if it wasn't applied explicitly\n\n\n  if (!formatApplied) {\n    var formatParts = [{\n      method: \"\",\n      params: format\n    }];\n\n    if (format == null) {\n      // Format is not set\n      // Determine from the type of the value\n      if ($type.isNumber(current)) {\n        formatParts[0].method = \"formatNumber\";\n        formatParts[0].params = \"\";\n      } else if ($type.isDate(current)) {\n        formatParts[0].method = \"formatDate\";\n        formatParts[0].params = \"\";\n      }\n    } else {\n      // Format set\n      // Try to determine formatter based on the format\n      var formatterType = $utils.getFormat(format); // format\n\n      if (formatterType === \"number\") {\n        formatParts[0].method = \"formatNumber\";\n      } else if (formatterType === \"date\") {\n        formatParts[0].method = \"formatDate\";\n      } else if (formatterType === \"duration\") {\n        formatParts[0].method = \"formatDuration\";\n      }\n    } // Apply format\n\n\n    if (formatParts[0].method) {\n      current = getTagValueFromObject(target, formatParts, current);\n    }\n  }\n\n  return current;\n}","map":{"version":3,"mappings":"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","names":["$type","$utils","Sprite","TextFormatter","populateString","target","string","escape","tags","match","i","length","tag","replace","value","getTagValue","split","join","unescape","tagName","format","dataItem","parts","reg","matches","exec","push","prop","dateFields","getDateFormatter","get","numericFields","getNumberFormatter","durationFields","getDurationFormatter","indexOf","method","params","trim","reg2","matches2","getTagValueFromObject","_settings","isObject","dataContext","component","parent","getCustomDataValue","customData","getPrivate","object","current","formatApplied","len","part","tmp","numberValue","toNumber","undefined","dateValue","toDate","isDate","isNaN","getTime","durationValue","encodeURIComponent","apply","formatParts","isNumber","formatterType","getFormat"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/PopulateString.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n\n/**\n * @ignore\n */\nexport function populateString(target: Sprite, string: string): string {\n\tif (string != null) {\n\t\tstring = \"\" + string;\n\t\tstring = TextFormatter.escape(string);\n\t\tlet tags = string.match(/\\{([^}]+)\\}/g);\n\t\tlet i;\n\t\tif (tags) {\n\t\t\tfor (i = 0; i < tags.length; i++) {\n\t\t\t\tlet tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n\t\t\t\tlet value = getTagValue(target, tag, \"\");\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\n\t\t\t\tstring = string.split(tags[i]).join(value);\n\t\t\t}\n\t\t}\n\t\tstring = TextFormatter.unescape(string);\n\t}\n\telse {\n\t\tstring = \"\";\n\t}\n\n\t// TODO: apply adapter?\n\treturn string;\n}\n\n/**\n * @ignore\n */\nfunction getTagValue(target: Sprite, tagName: string, format?: string): string {\n\tlet value: any;\n\tconst dataItem = target.dataItem;\n\n\t// Parse parts\n\tlet parts: any[] = [];\n\tlet reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;;\n\tlet matches;\n\n\twhile (true) {\n\t\tmatches = reg.exec(tagName);\n\n\t\tif (matches === null) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (matches[3]) {\n\t\t\t// Simple property\n\t\t\tparts.push({\n\t\t\t\tprop: matches[3]\n\t\t\t});\n\n\t\t\t// Check if maybe we should force a formatter on this value\n\t\t\tconst dateFields = target.getDateFormatter().get(\"dateFields\", []);\n\t\t\tconst numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n\t\t\tconst durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\t\t\tif ((<any>dateFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDate\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>numericFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatNumber\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>durationFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDuration\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\t\t\t// Parse parameters\n\t\t\tlet params: any[] = [];\n\t\t\tif ($utils.trim(matches[2]) != \"\") {\n\t\t\t\tlet reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n\t\t\t\tlet matches2;\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tmatches2 = reg2.exec(matches[2]);\n\n\t\t\t\t\tif (matches2 === null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.push(matches2[1] || matches2[2] || matches2[3])\n\t\t\t\t}\n\t\t\t}\n\t\t\tparts.push({\n\t\t\t\tmethod: matches[1],\n\t\t\t\tparams: params\n\t\t\t})\n\t\t}\n\t}\n\n\t// Check if we can retrieve the value from data item\n\tif (dataItem) {\n\n\n\t\t// Check values\n\t\tvalue = getTagValueFromObject(target, parts, dataItem._settings);\n\n\t\t// Check properties\n\t\tif (value == null || $type.isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n\t\t\tvalue = getTagValueFromObject(target, parts, dataItem);\n\t\t}\n\n\t\t// Check data context\n\t\tlet dataContext: any = dataItem.dataContext;\n\n\t\tif (value == null && dataContext) {\n\t\t\tvalue = getTagValueFromObject(target, parts, dataContext);\n\n\t\t\t// Maybe it's a literal dot-separated name of the key in dataContext?\n\t\t\tif (value == null) {\n\t\t\t\tvalue = getTagValueFromObject(target, [{\n\t\t\t\t\tprop: tagName\n\t\t\t\t}], dataContext);\n\t\t\t}\n\n\t\t\t// scond data context level sometimes exist (tree map)\n\t\t\tif (value == null && dataContext.dataContext) {\n\t\t\t\tvalue = getTagValueFromObject(target, parts, dataContext.dataContext);\n\t\t\t}\n\t\t}\n\n\t\t// Check component's data item\n\t\tif (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n\t\t\tvalue = getTagValue(dataItem.component, tagName, format);\n\t\t}\n\t}\n\n\t// Check sprite's properties\n\tif (value == null) {\n\t\tvalue = getTagValueFromObject(target, parts, target);\n\t}\n\n\t// Finally, check the parent\n\tif (value == null && target.parent) {\n\t\tvalue = getTagValue(target.parent, tagName, format);\n\t}\n\n\treturn value;\n}\n\n/**\n * @ignore\n */\nfunction getCustomDataValue(target: Sprite, prop: string): any {\n\tconst customData = target.getPrivate(\"customData\");\n\tif ($type.isObject(customData)) {\n\t\treturn (<any>customData)[prop];\n\t}\n}\n\n/**\n * @ignore\n */\nexport function getTagValueFromObject(target: Sprite, parts: any[], object: any, format?: string): any {\n\tlet current: any = object;\n\tlet formatApplied = false;\n\tfor (let i = 0, len = parts.length; i < len; i++) {\n\t\tlet part = parts[i];\n\t\tif (part.prop) {\n\t\t\t// Regular property\n\t\t\tif (current instanceof Sprite) {\n\t\t\t\tlet tmp = current.get(part.prop);\n\t\t\t\tif (tmp == null) tmp = current.getPrivate(part.prop);\n\t\t\t\tif (tmp == null) tmp = (<any>current)[part.prop];\n\t\t\t\tif (tmp == null) tmp = getCustomDataValue(current, part.prop);\n\t\t\t\tcurrent = tmp;\n\t\t\t}\n\t\t\telse if (current.get) {\n\t\t\t\tlet tmp = current.get(part.prop);\n\t\t\t\tif (tmp == null) tmp = (<any>current)[part.prop];\n\t\t\t\tcurrent = tmp;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = current[part.prop];\n\t\t\t}\n\n\t\t\tif (current == null) {\n\t\t\t\t// Not set, return undefined\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\n\t\t\tswitch (part.method) {\n\t\t\t\tcase \"formatNumber\":\n\t\t\t\t\tlet numberValue = $type.toNumber(current);\n\t\t\t\t\tif (numberValue != null) {\n\t\t\t\t\t\tcurrent = target.getNumberFormatter().format(\n\t\t\t\t\t\t\tnumberValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDate\":\n\t\t\t\t\tlet dateValue = $type.toDate(current);\n\t\t\t\t\tif (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n\t\t\t\t\t\t// Was not able to get date out of value, quitting and letting\n\t\t\t\t\t\t// calling method try another value\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (dateValue != null) {\n\t\t\t\t\t\tcurrent = target.getDateFormatter().format(\n\t\t\t\t\t\t\tdateValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDuration\":\n\t\t\t\t\tlet durationValue = $type.toNumber(current);\n\t\t\t\t\tif (durationValue != null) {\n\t\t\t\t\t\tcurrent = target.getDurationFormatter().format(\n\t\t\t\t\t\t\tdurationValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined,\n\t\t\t\t\t\t\tpart.params[1] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"urlEncode\":\n\t\t\t\tcase \"encodeURIComponent\":\n\t\t\t\t\tcurrent = encodeURIComponent(current);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (current[part.method]) {\n\t\t\t\t\t\tcurrent[part.method].apply(object, part.params);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply default format if it wasn't applied explicitly\n\tif (!formatApplied) {\n\n\t\tlet formatParts = [{\n\t\t\tmethod: \"\",\n\t\t\tparams: format\n\t\t}];\n\n\t\tif (format == null) {\n\n\t\t\t// Format is not set\n\t\t\t// Determine from the type of the value\n\t\t\tif ($type.isNumber(current)) {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\t\t\telse if ($type.isDate(current)) {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\t// Format set\n\t\t\t// Try to determine formatter based on the format\n\t\t\tlet formatterType: string = $utils.getFormat(format);\n\n\t\t\t// format\n\t\t\tif (formatterType === \"number\") {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t}\n\t\t\telse if (formatterType === \"date\") {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t}\n\t\t\telse if (formatterType === \"duration\") {\n\t\t\t\tformatParts[0].method = \"formatDuration\";\n\t\t\t}\n\n\t\t}\n\n\t\t// Apply format\n\t\tif (formatParts[0].method) {\n\t\t\tcurrent = getTagValueFromObject(target, formatParts, current);\n\t\t}\n\n\t}\n\n\treturn current;\n}"]},"metadata":{},"sourceType":"module"}