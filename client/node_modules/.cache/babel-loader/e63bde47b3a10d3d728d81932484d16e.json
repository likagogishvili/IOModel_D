{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Category-based date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\r\n * @important\r\n */\n\nvar CategoryDateAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryDateAxis, _super);\n\n  function CategoryDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_itemMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.fields.push(\"category\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this; // temp\n\n\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      var renderer = this.get(\"renderer\");\n      var len = this.dataItems.length;\n      var startIndex = this.startIndex();\n\n      if (startIndex > 0) {\n        startIndex--;\n      }\n\n      var endIndex = this.endIndex();\n\n      if (endIndex < len) {\n        endIndex++;\n      }\n\n      var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      var frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n\n      for (var j = 0; j < len; j++) {\n        this.dataItems[j].hide();\n      }\n\n      var startTime = Number(this.dataItems[startIndex].get(\"category\"));\n      var endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n      var realDuration = endTime - startTime;\n\n      if (endIndex - startIndex < maxCount) {\n        realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n      } // if all items are on axis\n\n\n      var gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n      var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = __assign({}, baseInterval);\n      }\n\n      var formats = this.get(\"dateFormats\");\n      var previousValue = -Infinity;\n      var previousIndex = -Infinity;\n      var previousUnitValue = -Infinity;\n      var format;\n      var selectedItems = [];\n      var changed = false;\n\n      for (var i = startIndex; i < endIndex; i++) {\n        var dataItem = this.dataItems[i];\n        var index = dataItem.get(\"index\");\n        var skip = false;\n        var value = Number(dataItem.get(\"category\"));\n        var date = new Date(value);\n        var unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n        format = formats[gridInterval.timeUnit];\n        var added = false;\n\n        if (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n\n              if (index - frequency * 0.5 < previousIndex) {\n                selectedItems.pop();\n              }\n\n              selectedItems.push({\n                format: format,\n                dataItem: dataItem\n              });\n              changed = true;\n              added = true;\n              previousIndex = index;\n              previousUnitValue = unitValue;\n            }\n          }\n        }\n\n        var shouldAdd = false;\n\n        if (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n          if (index - previousIndex >= frequency) {\n            shouldAdd = true;\n          }\n        } else {\n          if (unitValue % gridInterval.count === 0) {\n            if (unitValue != previousUnitValue) {\n              shouldAdd = true;\n            }\n          }\n        }\n\n        if (!added && shouldAdd) {\n          if (index - frequency * 0.7 < previousIndex) {\n            if (changed) {\n              skip = true;\n            }\n          }\n\n          if (!skip) {\n            selectedItems.push({\n              format: format,\n              dataItem: dataItem\n            });\n            previousIndex = index;\n            previousUnitValue = unitValue;\n          }\n\n          changed = false;\n        }\n\n        previousValue = value;\n      }\n\n      if (selectedItems.length > 0) {\n        var f_1 = selectedItems[0].dataItem.get(\"index\", 0);\n        $array.each(selectedItems, function (item) {\n          var dataItem = item.dataItem;\n          var format = item.format;\n\n          _this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          var value = Number(dataItem.get(\"category\"));\n          var date = new Date(value);\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", _this._root.dateFormatter.format(date, format));\n          }\n\n          f_1++;\n\n          _this._prepareDataItem(dataItem, f_1, frequency);\n        });\n      }\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      var dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n      if (dataItem) {\n        var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        return this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n      }\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (tooltip, position) {\n      tooltip.label.set(\"text\", this.getTooltipText(position));\n    }\n  });\n  Object.defineProperty(CategoryDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CategoryDateAxis\"\n  });\n  Object.defineProperty(CategoryDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: CategoryAxis.classNames.concat([CategoryDateAxis.className])\n  });\n  return CategoryDateAxis;\n}(CategoryAxis);\n\nexport { CategoryDateAxis };","map":{"version":3,"mappings":"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","names":["CategoryAxis","$time","$type","$array","$utils","__extends","Object","_settings","themeTags","mergeTags","fields","push","_super","_afterNew","call","setPrivateRaw","get","renderer","len","dataItems","length","startIndex","endIndex","maxCount","axisLength","Math","max","Number","MAX_SAFE_INTEGER","frequency","min","ceil","floor","_frequency","j","hide","startTime","endTime","realDuration","baseDuration","gridInterval","chooseInterval","nextGridUnit","getNextUnit","timeUnit","baseInterval","getPrivate","getIntervalDuration","formats","previousValue","Infinity","previousIndex","previousUnitValue","format","selectedItems","changed","i","dataItem","index","skip","value","date","Date","unitValue","getUnitValue","added","isNumber","checkChange","_root","utc","pop","shouldAdd","count","f_1","each","item","_this","_createAssets","isHidden","show","label","set","dateFormatter","_prepareDataItem","position","axisPositionToIndex","tooltip","getTooltipText","classNames","concat","CategoryDateAxis","className"],"sourceRoot":"","sources":["../../../../../../src/.internal/charts/xy/axes/CategoryDateAxis.ts"],"sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport { CategoryAxis, ICategoryAxisSettings, ICategoryAxisPrivate, ICategoryAxisDataItem, ICategoryAxisEvents } from \"./CategoryAxis\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\n\nexport interface ICategoryDateAxisSettings<R extends AxisRenderer> extends ICategoryAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\n\t */\n\ttooltipDateFormat?: string;\n\n}\n\nexport interface ICategoryDateAxisDataItem extends ICategoryAxisDataItem {\n}\n\nexport interface ICategoryDateAxisPrivate extends ICategoryAxisPrivate {\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n}\n\nexport interface ICategoryDateAxisEvents extends ICategoryAxisEvents {\n}\n\n\n/**\n * Category-based date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\n * @important\n */\nexport class CategoryDateAxis<R extends AxisRenderer> extends CategoryAxis<R> {\n\tpublic static className: string = \"CategoryDateAxis\";\n\tpublic static classNames: Array<string> = CategoryAxis.classNames.concat([CategoryDateAxis.className]);\n\n\tdeclare public _settings: ICategoryDateAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryDateAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryDateAxisDataItem;\n\tdeclare public _events: ICategoryDateAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryDateAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\t// temp\n\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\n\n\t\tlet frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis.dataItems[j].hide();\n\t\t}\n\n\t\tlet startTime = Number(this.dataItems[startIndex].get(\"category\"));\n\t\tlet endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n\t\tlet realDuration = (endTime - startTime);\n\t\tif(endIndex - startIndex < maxCount){\n\t\t\trealDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n\t\t}\n\n\t\t// if all items are on axis\n\t\tlet gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\")!);\n\n\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\tgridInterval = { ...baseInterval };\n\t\t}\n\n\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\tlet previousValue = -Infinity;\n\t\tlet previousIndex = -Infinity;\n\t\tlet previousUnitValue = -Infinity;\n\t\tlet format: string;\n\n\t\tlet selectedItems: Array<{ format: string, dataItem: DataItem<ICategoryDateAxisDataItem> }> = [];\n\t\tlet changed = false;\n\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tlet dataItem = this.dataItems[i];\n\t\t\tlet index = dataItem.get(\"index\")!;\n\t\t\tlet skip = false;\n\n\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\tlet date = new Date(value);\n\t\t\tlet unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n\n\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\tlet added = false;\n\n\t\t\tif (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\n\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc)) {\n\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\n\t\t\t\t\t\tif (index - frequency * 0.5 < previousIndex) {\n\t\t\t\t\t\t\tselectedItems.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet shouldAdd = false;\n\t\t\tif (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n\t\t\t\tif (index - previousIndex >= frequency) {\n\t\t\t\t\tshouldAdd = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (unitValue % gridInterval.count === 0) {\n\t\t\t\t\tif (unitValue != previousUnitValue) {\n\t\t\t\t\t\tshouldAdd = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!added && shouldAdd) {\n\t\t\t\tif (index - frequency * 0.7 < previousIndex) {\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skip) {\n\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t}\n\t\t\t\tchanged = false;\n\n\t\t\t}\n\n\t\t\tpreviousValue = value;\n\n\t\t}\n\n\t\tif (selectedItems.length > 0) {\n\t\t\tlet f = selectedItems[0].dataItem.get(\"index\", 0);\n\n\t\t\t$array.each(selectedItems, (item) => {\n\t\t\t\tconst dataItem = item.dataItem;\n\t\t\t\tconst format = item.format;\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\t\t\t\tf++;\n\t\t\t\tthis._prepareDataItem(dataItem, f, frequency);\n\t\t\t})\n\n\t\t}\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tlet dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n\t\tif (dataItem) {\n\t\t\tlet format = this.get(\"dateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\treturn this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip.label.set(\"text\", this.getTooltipText(position));\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}