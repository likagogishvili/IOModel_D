{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * Creates a duration axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\r\n * @important\r\n */\n\nvar DurationAxis =\n/** @class */\nfunction (_super) {\n  __extends(DurationAxis, _super);\n\n  function DurationAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DurationAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      var e_1, _a;\n\n      var minMaxStep;\n      var durationFormatter = this.getDurationFormatter();\n      var baseUnit = this.get(\"baseUnit\"); // we don't allow to go to smaller units, setting so to avoid invalidation\n\n      this.setRaw(\"maxPrecision\", 0);\n\n      if (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n        // will fail if 0\n        if (gridCount <= 1) {\n          gridCount = 1;\n        }\n\n        gridCount = Math.round(gridCount); //let initialMin: number = min;\n        //let initialMax: number = max;\n\n        var difference = max - min; // in case min and max is the same, use max\n\n        if (difference === 0) {\n          difference = Math.abs(max);\n        }\n\n        var step = difference / gridCount;\n        var divisors = [60, 30, 20, 15, 10, 2, 1];\n        var realDivisor = 1;\n\n        if (baseUnit == \"hour\") {\n          divisors = [24, 12, 6, 4, 2, 1];\n        }\n\n        try {\n          for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {\n            var divisor = divisors_1_1.value;\n\n            if (difference / divisor > gridCount) {\n              realDivisor = divisor;\n              break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return)) _a.call(divisors_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var count = Math.ceil((max - min) / realDivisor / gridCount);\n        var exponent = Math.log(Math.abs(count)) * Math.LOG10E;\n        var power = Math.pow(10, Math.floor(exponent)) / 10;\n        var reducedCount = count / power; // find closest to divisor\n\n        var closest = $math.closest(divisors, reducedCount);\n        count = closest * power;\n        step = realDivisor * count;\n        min = Math.floor(min / step) * step;\n        max = Math.ceil(max / step) * step;\n        /*\r\n        causese SO with seconds\r\n        if (strictMode) {\r\n            min -= step;\r\n            if (min < 0 && initialMin >= 0) {\r\n                min = 0;\r\n            }\r\n            max += step;\r\n                  if (max > 0 && initialMax <= 0) {\r\n                max = 0;\r\n            }\r\n        }*/\n\n        minMaxStep = {\n          min: min,\n          max: max,\n          step: step\n        };\n      } else {\n        minMaxStep = _super.prototype._adjustMinMax.call(this, min, max, gridCount, strictMode);\n      } // choose duration formatter based on step\n\n\n      this.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n      return minMaxStep;\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var formatter = this.getDurationFormatter();\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DurationAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var formatter = this.getDurationFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  Object.defineProperty(DurationAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DurationAxis\"\n  });\n  Object.defineProperty(DurationAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DurationAxis.className])\n  });\n  return DurationAxis;\n}(ValueAxis);\n\nexport { DurationAxis };","map":{"version":3,"mappings":"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","names":["ValueAxis","$utils","$math","__extends","Object","_settings","themeTags","mergeTags","_super","_afterNew","call","min","max","gridCount","strictMode","minMaxStep","durationFormatter","getDurationFormatter","baseUnit","get","setRaw","Math","round","difference","abs","step","divisors","realDivisor","divisors_1_1","divisor","count","ceil","exponent","log","LOG10E","power","pow","floor","reducedCount","closest","_adjustMinMax","setPrivate","getFormat","value","formatter","format","getPrivate","position","extraDecimals","decimals","positionToValue","classNames","concat","DurationAxis","className"],"sourceRoot":"","sources":["../../../../../../src/.internal/charts/xy/axes/DurationAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\nimport type { TimeUnit } from \"../../../core/util/Time\"\n\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IValueAxisEvents, IMinMaxStep } from \"./ValueAxis\";\n\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n\nexport interface IDurationAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * A base unit (granularity) of data.\n\t *\n\t * Used to indicate what are the base units of your data.\n\t *\n\t * Available options: `\"millisecond\"`, `\"second\"` (default), `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/#Base_unit} for more info\n\t * @default \"second\"\n\t */\n\tbaseUnit?: TimeUnit\n\n}\n\nexport interface IDurationAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDurationAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * A format to used by axis to format its labels.\n\t *\n\t * @readonly\n\t */\n\tdurationFormat: string;\n\n}\n\nexport interface IDurationAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a duration axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\n * @important\n */\nexport class DurationAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DurationAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DurationAxis.className]);\n\n\tdeclare public _settings: IDurationAxisSettings<R>;\n\tdeclare public _privateSettings: IDurationAxisPrivate;\n\tdeclare public _dataItemSettings: IDurationAxisDataItem;\n\tdeclare public _events: IDurationAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\t\tlet minMaxStep: IMinMaxStep;\n\n\t\tconst durationFormatter = this.getDurationFormatter();\n\t\tconst baseUnit = this.get(\"baseUnit\");\n\t\t// we don't allow to go to smaller units, setting so to avoid invalidation\n\t\tthis.setRaw(\"maxPrecision\", 0);\n\n\t\tif (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n\t\t\t// will fail if 0\n\t\t\tif (gridCount <= 1) {\n\t\t\t\tgridCount = 1;\n\t\t\t}\n\n\t\t\tgridCount = Math.round(gridCount);\n\n\t\t\t//let initialMin: number = min;\n\t\t\t//let initialMax: number = max;\n\n\t\t\tlet difference = max - min;\n\n\t\t\t// in case min and max is the same, use max\n\t\t\tif (difference === 0) {\n\t\t\t\tdifference = Math.abs(max);\n\t\t\t}\n\n\t\t\tlet step = difference / gridCount;\n\n\t\t\tlet divisors = [60, 30, 20, 15, 10, 2, 1];\n\t\t\tlet realDivisor = 1;\n\n\t\t\tif (baseUnit == \"hour\") {\n\t\t\t\tdivisors = [24, 12, 6, 4, 2, 1];\n\t\t\t}\n\n\t\t\tfor (let divisor of divisors) {\n\t\t\t\tif (difference / divisor > gridCount) {\n\t\t\t\t\trealDivisor = divisor;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet count = Math.ceil(((max - min) / realDivisor) / gridCount);\n\n\t\t\tlet exponent: number = Math.log(Math.abs(count)) * Math.LOG10E;\n\t\t\tlet power = Math.pow(10, Math.floor(exponent)) / 10;\n\t\t\tlet reducedCount = count / power;\n\n\t\t\t// find closest to divisor\n\t\t\tlet closest = $math.closest(divisors, reducedCount);\n\t\t\tcount = closest * power;\n\n\t\t\tstep = realDivisor * count;\n\n\t\t\tmin = Math.floor(min / step) * step;\n\t\t\tmax = Math.ceil(max / step) * step;\n\n\t\t\t/*\n\t\t\tcausese SO with seconds\n\t\t\tif (strictMode) {\n\t\t\t\tmin -= step;\n\t\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\t\tmin = 0;\n\t\t\t\t}\n\t\t\t\tmax += step;\n\n\t\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tminMaxStep = { min: min, max: max, step: step };\n\t\t}\n\t\telse {\n\t\t\tminMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);\n\t\t}\n\n\t\t// choose duration formatter based on step\n\t\tthis.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n\n\t\treturn minMaxStep;\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst formatter = this.getDurationFormatter();\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\tconst formatter = this.getDurationFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}