{"ast":null,"code":"import { Color } from \"./Color\";\nimport * as $type from \"./Type\";\n\nvar TextFormatter =\n/** @class */\nfunction () {\n  function TextFormatter() {}\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n\n  Object.defineProperty(TextFormatter, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, this.prefix + \"1\").replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").replace(/\\]\\]/g, this.prefix + \"2\").replace(/\\{\\{/g, this.prefix + \"3\").replace(/\\}\\}/g, this.prefix + \"4\").replace(/\\'\\'/g, this.prefix + \"5\");\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").replace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").replace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").replace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").replace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n    }\n  });\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"cleanUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n    }\n  });\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n\n  Object.defineProperty(TextFormatter, \"chunk\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, quotedBlocks, noFormatting) {\n      if (quotedBlocks === void 0) {\n        quotedBlocks = false;\n      }\n\n      if (noFormatting === void 0) {\n        noFormatting = false;\n      } // Init result\n\n\n      var res = []; // Replace double (escaped) square spaces and quotes with temporary codes\n\n      text = this.escape(text); // Deal with style blocks\n\n      var chunks = quotedBlocks ? text.split(\"'\") : [text];\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // Empty?\n\n        if (chunk === \"\") {\n          continue;\n        }\n\n        if (i % 2 === 0) {\n          // Text outside quotes\n          // Parse for style blocks which are \"text\" chunks, the rest chunks are\n          // \"value\"\n          chunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n          chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Placeholder?\n\n            if (chunk2 === $type.PLACEHOLDER) {\n              continue;\n            } // Empty?\n\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or value\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"value\",\n                \"text\": chunk2\n              });\n            } else {\n              res.push({\n                \"type\": noFormatting ? \"value\" : \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        } else {\n          // A text within doublequotes\n          // All chunks are \"text\"\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Empty?\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or text\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"text\",\n                \"text\": chunk2\n              });\n            } else if (this.isImage(chunk2)) {\n              res.push({\n                \"type\": \"image\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            } else {\n              res.push({\n                \"type\": \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        }\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n\n  Object.defineProperty(TextFormatter, \"isImage\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.match(/img[ ]?:/) ? true : false;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"getTextStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (style) {\n      // let textStyle: string[] = [];\n      // let textFill: string | undefined;\n      var format = {};\n\n      if (style == \"\" || style == \"[ ]\") {\n        return {};\n      } // Pre-process quoted text\n\n\n      var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\n      if (q) {\n        for (var i = 0; i < q.length; i++) {\n          style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n        }\n      } // Get style parts\n\n\n      var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi); // Empty?\n\n      if (!b) {\n        return {};\n      } // Check each part\n\n\n      for (var i = 0; i < b.length; i++) {\n        if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n          format.fontWeight = b[i];\n        } else if (b[i].match(/^(underline)$/i)) {\n          format.textDecoration = b[i];\n        } else if (b[i] == \"/\") {// Just closing tag\n          // Do nothing\n        } else if (!b[i].match(/:/)) {\n          // Color\n          format.fill = Color.fromString(b[i]);\n        } else {\n          var p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n          format[p[0]] = p[1]; //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n          //b[i] = b[i].replace(/\\+/g, \" \");\n        }\n      }\n\n      return format;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"prefix\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__amcharts__\"\n  });\n  return TextFormatter;\n}();\n\nexport { TextFormatter };","map":{"version":3,"mappings":"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","names":["Color","$type","text","replace","prefix","RegExp","quotedBlocks","noFormatting","res","escape","chunks","split","i","length","chunk","PLACEHOLDER","chunks2","i2","chunk2","cleanUp","unescape","push","isImage","match","style","format","q","b","fontWeight","textDecoration","fill","fromString","p","Object","TextFormatter"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/TextFormatter.ts"],"sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i].match(/^(underline)$/i)) {\n\t\t\t\t(<any>format).textDecoration = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\treturn format;\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}