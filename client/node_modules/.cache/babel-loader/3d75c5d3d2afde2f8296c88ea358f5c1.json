{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Layout, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\n/**\r\n * A grid children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\n\nvar GridLayout =\n/** @class */\nfunction (_super) {\n  __extends(GridLayout, _super);\n\n  function GridLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(GridLayout.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(GridLayout.prototype, \"updateContainer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (container) {\n      var paddingLeft = container.get(\"paddingLeft\", 0);\n      var paddingRight = container.get(\"paddingRight\", 0);\n      var paddingTop = container.get(\"paddingTop\", 0);\n      var availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n      var minCellWidth = availableWidth;\n      var maxCellWidth = 1;\n      eachChildren(container, function (child) {\n        if (child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")) {\n          if (child.get(\"position\") != \"absolute\") {\n            var childWidth = child.width();\n\n            if (childWidth < minCellWidth) {\n              minCellWidth = childWidth;\n            }\n\n            if (childWidth > maxCellWidth) {\n              maxCellWidth = childWidth;\n            }\n          }\n        }\n      });\n      minCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n      maxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n      var columnCount = 1;\n\n      if (this.get(\"fixedWidthGrid\")) {\n        columnCount = availableWidth / maxCellWidth;\n      } else {\n        columnCount = availableWidth / minCellWidth;\n      }\n\n      columnCount = Math.max(1, Math.floor(columnCount));\n      columnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n      var columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n      var prevY = paddingTop;\n      var column = 0;\n      var maxColumnHeight = 0;\n      columnCount = columnWidths.length;\n      var prevX = paddingLeft;\n      eachChildren(container, function (child) {\n        if (child.get(\"position\") == \"relative\" && child.isVisible()) {\n          var marginTop = child.get(\"marginTop\", 0);\n          var marginBottom = child.get(\"marginBottom\", 0);\n          var bounds = child.adjustedLocalBounds();\n          var marginLeft = child.get(\"marginLeft\", 0);\n          var marginRight = child.get(\"marginRight\", 0);\n          var x = prevX + marginLeft - bounds.left;\n          var y = prevY + marginTop - bounds.top;\n          child.setPrivate(\"x\", x);\n          child.setPrivate(\"y\", y);\n          prevX += columnWidths[column] + marginRight;\n          maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n          column++;\n\n          if (column >= columnCount) {\n            column = 0;\n            prevX = paddingLeft;\n            prevY += maxColumnHeight;\n          }\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(GridLayout.prototype, \"getColumnWidths\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (container, columnCount, maxCellWidth, availableWidth) {\n      var _this = this;\n\n      var totalWidth = 0;\n      var columnWidths = [];\n      var column = 0;\n      eachChildren(container, function (child) {\n        var bounds = child.adjustedLocalBounds();\n\n        if (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n          if (_this.get(\"fixedWidthGrid\")) {\n            columnWidths[column] = maxCellWidth;\n          } else {\n            columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n          }\n\n          if (column < container.children.length - 1) {\n            column++;\n\n            if (column == columnCount) {\n              column = 0;\n            }\n          }\n        }\n      });\n      $array.each(columnWidths, function (w) {\n        totalWidth += w;\n      });\n\n      if (totalWidth > availableWidth) {\n        if (columnCount > 2) {\n          columnCount -= 1;\n          return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n        } else {\n          return [availableWidth];\n        }\n      }\n\n      return columnWidths;\n    }\n  });\n  Object.defineProperty(GridLayout, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"GridLayout\"\n  });\n  Object.defineProperty(GridLayout, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Layout.classNames.concat([GridLayout.className])\n  });\n  return GridLayout;\n}(Layout);\n\nexport { GridLayout };","map":{"version":3,"mappings":"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","names":["Layout","eachChildren","$array","$math","__extends","_setRawDefault","Number","MAX_VALUE","_super","_afterNew","call","container","paddingLeft","get","paddingRight","paddingTop","availableWidth","maxWidth","minCellWidth","maxCellWidth","child","getPrivate","childWidth","width","fitToRange","columnCount","Math","max","floor","min","columnWidths","getColumnWidths","prevY","column","maxColumnHeight","length","prevX","isVisible","marginTop","marginBottom","bounds","adjustedLocalBounds","marginLeft","marginRight","x","left","y","top","setPrivate","height","totalWidth","_this","right","children","each","w","Object","classNames","concat","GridLayout","className"],"sourceRoot":"","sources":["../../../../../src/.internal/core/render/GridLayout.ts"],"sourcesContent":["import { Layout, ILayoutSettings, ILayoutPrivate, eachChildren } from \"./Layout\";\nimport * as $array from \"../util/Array\";\nimport * as $math from \"../util/Math\";\nimport type { Container } from \"./Container\";\n\n\nexport interface IGridLayoutSettings extends ILayoutSettings {\n\n\t/**\n\t * If set to `true` all columns in the grid will be equal width.\n\t *\n\t * @default false\n\t */\n\tfixedWidthGrid?: boolean;\n\n\t/**\n\t * Maximum number of columns in the grid.\n\t */\n\tmaxColumns?: number;\n\n}\n\nexport interface IGridLayoutPrivate extends ILayoutPrivate {\n}\n\n/**\n * A grid children layout for [[Container]].\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\n */\nexport class GridLayout extends Layout {\n\n\tpublic static className: string = \"GridLayout\";\n\tpublic static classNames: Array<string> = Layout.classNames.concat([GridLayout.className]);\n\n\tdeclare public _settings: IGridLayoutSettings;\n\tdeclare public _privateSettings: IGridLayoutPrivate;\n\n\n\tprotected _afterNew() {\n\t\tthis._setRawDefault(\"maxColumns\", Number.MAX_VALUE);\n\t\tsuper._afterNew();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateContainer(container: Container): void {\n\t\tlet paddingLeft = container.get(\"paddingLeft\", 0);\n\t\tlet paddingRight = container.get(\"paddingRight\", 0);\n\t\tlet paddingTop = container.get(\"paddingTop\", 0);\n\n\t\tlet availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n\n\t\tlet minCellWidth = availableWidth;\n\t\tlet maxCellWidth = 1;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif(child.get(\"visible\") && child.getPrivate(\"visible\") && !child.get(\"forceHidden\")){\n\t\t\t\tif (child.get(\"position\") != \"absolute\") {\n\t\t\t\t\tlet childWidth = child.width();\n\n\t\t\t\t\tif (childWidth < minCellWidth) {\n\t\t\t\t\t\tminCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t\tif (childWidth > maxCellWidth) {\n\t\t\t\t\t\tmaxCellWidth = childWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tminCellWidth = $math.fitToRange(minCellWidth, 1, availableWidth);\n\t\tmaxCellWidth = $math.fitToRange(maxCellWidth, 1, availableWidth);\n\n\t\tlet columnCount = 1;\n\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\tcolumnCount = availableWidth / maxCellWidth;\n\t\t}\n\t\telse {\n\t\t\tcolumnCount = availableWidth / minCellWidth;\n\t\t}\n\n\t\tcolumnCount = Math.max(1, Math.floor(columnCount));\n\t\tcolumnCount = Math.min(this.get(\"maxColumns\", Number.MAX_VALUE), columnCount);\n\n\t\tlet columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\n\t\tlet prevY = paddingTop;\n\n\t\tlet column = 0;\n\t\tlet maxColumnHeight = 0;\n\n\t\tcolumnCount = columnWidths.length;\n\n\t\tlet prevX = paddingLeft;\n\n\t\teachChildren(container, (child) => {\n\t\t\tif (child.get(\"position\") == \"relative\" && child.isVisible()) {\n\t\t\t\tconst marginTop = child.get(\"marginTop\", 0);\n\t\t\t\tconst marginBottom = child.get(\"marginBottom\", 0);\n\n\t\t\t\tlet bounds = child.adjustedLocalBounds();\n\n\t\t\t\tlet marginLeft = child.get(\"marginLeft\", 0);\n\t\t\t\tlet marginRight = child.get(\"marginRight\", 0);\n\t\t\t\tlet x = prevX + marginLeft - bounds.left;\n\t\t\t\tlet y = prevY + marginTop - bounds.top;\n\n\t\t\t\tchild.setPrivate(\"x\", x);\n\t\t\t\tchild.setPrivate(\"y\", y);\n\n\t\t\t\tprevX += columnWidths[column] + marginRight;\n\n\t\t\t\tmaxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n\n\t\t\t\tcolumn++;\n\n\t\t\t\tif (column >= columnCount) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tprevX = paddingLeft;\n\t\t\t\t\tprevY += maxColumnHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getColumnWidths(container: Container, columnCount: number, maxCellWidth: number, availableWidth: number): number[] {\n\t\tlet totalWidth = 0;\n\t\tlet columnWidths: Array<number> = [];\n\t\tlet column = 0;\n\n\t\teachChildren(container, (child) => {\n\t\t\tlet bounds = child.adjustedLocalBounds();\n\t\t\tif (child.get(\"position\") != \"absolute\" && child.isVisible()) {\n\t\t\t\tif (this.get(\"fixedWidthGrid\")) {\n\t\t\t\t\tcolumnWidths[column] = maxCellWidth;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get(\"marginLeft\", 0) + child.get(\"marginRight\", 0));\n\t\t\t\t}\n\n\t\t\t\tif (column < container.children.length - 1) {\n\t\t\t\t\tcolumn++;\n\t\t\t\t\tif (column == columnCount) {\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$array.each(columnWidths, (w) => {\n\t\t\ttotalWidth += w;\n\t\t})\n\n\t\tif (totalWidth > availableWidth) {\n\t\t\tif (columnCount > 2) {\n\t\t\t\tcolumnCount -= 1;\n\t\t\t\treturn this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn [availableWidth];\n\t\t\t}\n\t\t}\n\n\t\treturn columnWidths;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}