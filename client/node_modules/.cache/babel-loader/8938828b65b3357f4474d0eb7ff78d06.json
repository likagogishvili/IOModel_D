{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n/**\r\n * Creates a tooltip.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\r\n * @important\r\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n\n  function Tooltip() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_arrangeDisposer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_fy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_label\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fillDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_labelDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_w\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_h\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Tooltip.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n\n      _super.prototype._afterNew.call(this);\n\n      this.set(\"background\", PointedRectangle.new(this._root, {\n        themeTags: [\"tooltip\", \"background\"]\n      }));\n      this._label = this.children.push(Label.new(this._root, {}));\n\n      this._disposers.push(this._label.events.on(\"boundschanged\", function () {\n        _this._updateBackground();\n      }));\n\n      this.on(\"bounds\", function () {\n        _this._updateBackground();\n      });\n\n      this._updateTextColor();\n\n      this._root.tooltipContainer.children.push(this);\n\n      this.hide(0);\n\n      this._root._tooltips.push(this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"label\", {\n    /**\r\n     * A [[Label]] element for the tooltip.\r\n     *\r\n     * @readonly\r\n     * @return Label\r\n     */\n    get: function () {\n      return this._label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Permanently disposes the tooltip.\r\n   */\n\n  Object.defineProperty(Tooltip.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.dispose.call(this);\n\n      $array.remove(this._root._tooltips, this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._updateChildren.call(this);\n\n      var labelText = this.get(\"labelText\");\n\n      if (labelText != null) {\n        this.label.set(\"text\", this.get(\"labelText\"));\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._changed.call(this);\n\n      if (this.isDirty(\"pointTo\")) {\n        // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n        this._updateBackground();\n      }\n\n      if (this.isDirty(\"tooltipTarget\")) {\n        this.updateBackgroundColor();\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_onShow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._onShow.call(this);\n\n      this.updateBackgroundColor();\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"updateBackgroundColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var tooltipTarget = this.get(\"tooltipTarget\");\n      var background = this.get(\"background\");\n      var fill;\n      var stroke;\n\n      if (tooltipTarget && background) {\n        fill = tooltipTarget.get(\"fill\");\n        stroke = tooltipTarget.get(\"stroke\");\n\n        if (fill == null) {\n          fill = stroke;\n        }\n\n        if (this.get(\"getFillFromSprite\")) {\n          if (this._fillDp) {\n            this._fillDp.dispose();\n          }\n\n          if (fill != null) {\n            background.set(\"fill\", fill);\n          }\n\n          this._fillDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"fill\", fill);\n\n              _this._updateTextColor(fill);\n            }\n          });\n        }\n\n        if (this.get(\"getStrokeFromSprite\")) {\n          if (this._strokeDp) {\n            this._strokeDp.dispose();\n          }\n\n          if (fill != null) {\n            background.set(\"stroke\", fill);\n          }\n\n          this._strokeDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"stroke\", fill);\n            }\n          });\n        }\n\n        if (this.get(\"getLabelFillFromSprite\")) {\n          if (this._labelDp) {\n            this._labelDp.dispose();\n          }\n\n          if (fill != null) {\n            this.label.set(\"fill\", fill);\n          }\n\n          this._labelDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              _this.label.set(\"fill\", fill);\n            }\n          });\n        }\n      }\n\n      this._updateTextColor(fill);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateTextColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fill) {\n      if (this.get(\"autoTextColor\")) {\n        if (fill == null) {\n          fill = this.get(\"background\").get(\"fill\");\n        }\n\n        if (fill == null) {\n          fill = this._root.interfaceColors.get(\"background\");\n        }\n\n        if (fill instanceof Color) {\n          this.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_setDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      _super.prototype._setDataItem.call(this, dataItem);\n\n      this.label._setDataItem(dataItem);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateBackground\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.updateBackground.call(this);\n\n      var parent = this._root.container;\n\n      if (parent) {\n        var cw = 0.5;\n        var ch = 0.5;\n        var centerX = this.get(\"centerX\");\n\n        if (centerX instanceof Percent) {\n          cw = centerX.value;\n        }\n\n        var centerY = this.get(\"centerY\");\n\n        if (centerY instanceof Percent) {\n          ch = centerY.value;\n        }\n\n        var parentW = parent.width();\n        var parentH = parent.height();\n        var bounds = this.get(\"bounds\", {\n          left: 0,\n          top: 0,\n          right: parentW,\n          bottom: parentH\n        });\n\n        this._updateBounds();\n\n        var w = this.width();\n        var h = this.height(); // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n\n        if (w === 0) {\n          w = this._w;\n        }\n\n        if (h === 0) {\n          h = this._h;\n        }\n\n        var pointTo = this.get(\"pointTo\", {\n          x: parentW / 2,\n          y: parentH / 2\n        });\n        var x = pointTo.x;\n        var y = pointTo.y;\n        var pointerOrientation = this.get(\"pointerOrientation\");\n        var background = this.get(\"background\");\n        var pointerLength = 0;\n        var bgStrokeSizeY = 0;\n        var bgStrokeSizeX = 0;\n\n        if (background instanceof PointedRectangle) {\n          pointerLength = background.get(\"pointerLength\", 0);\n          bgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n          bgStrokeSizeX = bgStrokeSizeY;\n        }\n\n        var pointerX = 0;\n        var pointerY = 0;\n        var boundsW = bounds.right - bounds.left;\n        var boundsH = bounds.bottom - bounds.top; // horizontal\n\n        if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n          bgStrokeSizeY = 0;\n\n          if (pointerOrientation == \"horizontal\") {\n            if (x > bounds.left + boundsW / 2) {\n              x -= w * (1 - cw) + pointerLength;\n              bgStrokeSizeX *= -1;\n            } else {\n              x += w * cw + pointerLength;\n            }\n          } else if (pointerOrientation == \"left\") {\n            x += w * (1 - cw) + pointerLength;\n          } else {\n            x -= w * cw + pointerLength;\n            bgStrokeSizeX *= -1;\n          }\n        } // vertical pointer\n        else {\n          bgStrokeSizeX = 0;\n\n          if (pointerOrientation == \"vertical\") {\n            if (y > bounds.top + h / 2 + pointerLength) {\n              y -= h * (1 - ch) + pointerLength;\n            } else {\n              y += h * ch + pointerLength;\n              bgStrokeSizeY *= -1;\n            }\n          } else if (pointerOrientation == \"down\") {\n            y -= h * (1 - ch) + pointerLength;\n          } else {\n            y += h * ch + pointerLength;\n            bgStrokeSizeY *= -1;\n          }\n        }\n\n        x = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n        y = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n        pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n        pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n        this._fx = x;\n        this._fy = y;\n        var animationDuration = this.get(\"animationDuration\", 0);\n\n        if (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n          var animationEasing = this.get(\"animationEasing\");\n          this.animate({\n            key: \"x\",\n            to: x,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n          this.animate({\n            key: \"y\",\n            to: y,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n        } else {\n          this.set(\"x\", x);\n          this.set(\"y\", y);\n        }\n\n        if (background instanceof PointedRectangle) {\n          background.set(\"pointerX\", pointerX);\n          background.set(\"pointerY\", pointerY);\n        }\n\n        if (w > 0) {\n          this._w = w;\n        }\n\n        if (h > 0) {\n          this._h = h;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Tooltip\"\n  });\n  Object.defineProperty(Tooltip, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Container.classNames.concat([Tooltip.className])\n  });\n  return Tooltip;\n}(Container);\n\nexport { Tooltip };","map":{"version":3,"mappings":"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","names":["Label","PointedRectangle","Container","Percent","Color","$math","$array","$utils","__extends","Object","_settings","themeTags","mergeTags","_super","_afterNew","call","set","new","_root","_label","children","push","_disposers","events","on","_this","_updateBackground","_updateTextColor","tooltipContainer","hide","_tooltips","Tooltip","dispose","remove","_updateChildren","labelText","get","label","_changed","isDirty","updateBackgroundColor","_onShow","tooltipTarget","background","fill","stroke","_fillDp","_strokeDp","_labelDp","interfaceColors","alternative","dataItem","_setDataItem","updateBackground","parent","container","cw","ch","centerX","value","centerY","parentW","width","parentH","height","bounds","left","top","right","bottom","_updateBounds","w","h","_w","_h","pointTo","x","y","pointerOrientation","pointerLength","bgStrokeSizeY","bgStrokeSizeX","pointerX","pointerY","boundsW","boundsH","fitToRange","_fx","_fy","animationDuration","animationEasing","animate","key","to","duration","easing","classNames","concat","className"],"sourceRoot":"","sources":["../../../../../src/.internal/core/render/Tooltip.ts"],"sourcesContent":["import type { IBounds } from \"../util/IBounds\";\nimport type { IPoint } from \"../util/IPoint\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Time } from \"../util/Animation\";\nimport type { Sprite } from \"../render/Sprite\";\nimport type { MultiDisposer, IDisposer } from \"../util/Disposer\";\n\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container, IContainerPrivate, IContainerSettings } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\n\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n//import * as $utils from \"../util/Utils\";\nimport type { DataItem, IComponentDataItem } from \"./Component\";\n\n\nexport interface ITooltipSettings extends IContainerSettings {\n\n\t/**\n\t * Text to use for tooltip's label.\n\t */\n\tlabelText?: string\n\n\t/**\n\t * A direction of the tooltip pointer.\n\t *\n\t * https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Orientation\n\t */\n\tpointerOrientation?: \"left\" | \"right\" | \"up\" | \"down\" | \"vertical\" | \"horizontal\";\n\n\t/**\n\t * If set to `true` will use the same `fill` color for its background as\n\t * its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `fill` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetLabelFillFromSprite?: boolean;\n\n\t/**\n\t * If set to `true` will use the same `stroke` color as its `tooltipTarget`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/#Colors} for more info\n\t * @default false\n\t */\n\tgetStrokeFromSprite?: boolean;\n\n\t/**\n\t * Scree bounds to constring tooltip within.\n\t */\n\tbounds?: IBounds;\n\n\t/**\n\t * If set to `true` tooltip will adjust its text color for better visibility\n\t * on its background.\n\t *\n\t * @default true\n\t */\n\tautoTextColor?: boolean;\n\n\t/**\n\t * Screen coordinates the tooltip show point to.\n\t */\n\tpointTo?: IPoint;\n\n\t/**\n\t * Duration in milliseconds for tooltip position change, e.g. when tooltip\n\t * is jumping from one target to another.\n\t */\n\tanimationDuration?: number;\n\n\t/**\n\t * Easing function for tooltip animation.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Easing_functions} for more info\n\t */\n\tanimationEasing?: (t: Time) => Time;\n\n\t/**\n\t * A target element tooltip is shown fow.\n\t */\n\ttooltipTarget?: Sprite;\n\n}\n\nexport interface ITooltipPrivate extends IContainerPrivate {\n}\n\n/**\n * Creates a tooltip.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\n * @important\n */\nexport class Tooltip extends Container {\n\n\tprotected _arrangeDisposer: MultiDisposer | undefined;\n\n\tpublic _fx: number = 0;\n\tpublic _fy: number = 0;\n\n\tdeclare public _settings: ITooltipSettings;\n\tdeclare public _privateSettings: ITooltipPrivate;\n\n\tprotected _label!: Label;\n\tpublic static className: string = \"Tooltip\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Tooltip.className]);\n\n\tprotected _fillDp: IDisposer | undefined;\n\tprotected _strokeDp: IDisposer | undefined;\n\tprotected _labelDp: IDisposer | undefined;\n\n\tprotected _w: number = 0;\n\tprotected _h: number = 0;\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n\n\t\tsuper._afterNew();\n\n\t\tthis.set(\"background\", PointedRectangle.new(this._root, {\n\t\t\tthemeTags: [\"tooltip\", \"background\"]\n\t\t}));\n\n\t\tthis._label = this.children.push(Label.new(this._root, {}));\n\n\t\tthis._disposers.push(this._label.events.on(\"boundschanged\", () => {\n\t\t\tthis._updateBackground();\n\t\t}))\n\n\t\tthis.on(\"bounds\", () => {\n\t\t\tthis._updateBackground();\n\t\t})\n\n\t\tthis._updateTextColor();\n\n\t\tthis._root.tooltipContainer.children.push(this);\n\t\tthis.hide(0);\n\n\t\tthis._root._tooltips.push(this);\n\t}\n\n\t/**\n\t * A [[Label]] element for the tooltip.\n\t *\n\t * @readonly\n\t * @return Label\n\t */\n\tpublic get label(): Label {\n\t\treturn this._label;\n\t}\n\n\t/**\n\t * Permanently disposes the tooltip.\n\t */\n\tpublic dispose() {\n\t\tsuper.dispose();\n\t\t$array.remove(this._root._tooltips, this);\n\t}\n\n\tpublic _updateChildren() {\n\t\tsuper._updateChildren();\n\t\tconst labelText = this.get(\"labelText\");\n\t\tif (labelText != null) {\n\t\t\tthis.label.set(\"text\", this.get(\"labelText\"));\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this.isDirty(\"pointTo\")) {\n\t\t\t// can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n\t\t\tthis._updateBackground();\n\t\t}\n\n\t\tif (this.isDirty(\"tooltipTarget\")) {\n\t\t\tthis.updateBackgroundColor();\n\t\t}\n\t}\n\n\tprotected _onShow() {\n\t\tsuper._onShow();\n\t\tthis.updateBackgroundColor();\n\t}\n\n\n\tpublic updateBackgroundColor() {\n\t\tlet tooltipTarget = this.get(\"tooltipTarget\");\n\t\tconst background = this.get(\"background\");\n\t\tlet fill: Color | undefined;\n\t\tlet stroke: Color | undefined;\n\n\n\t\tif (tooltipTarget && background) {\n\n\t\t\tfill = tooltipTarget.get(\"fill\" as any);\n\t\t\tstroke = tooltipTarget.get(\"stroke\" as any);\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = stroke;\n\t\t\t}\n\n\t\t\tif (this.get(\"getFillFromSprite\")) {\n\n\t\t\t\tif (this._fillDp) {\n\t\t\t\t\tthis._fillDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._fillDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"fill\", fill as any);\n\t\t\t\t\t\tthis._updateTextColor(fill);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.get(\"getStrokeFromSprite\")) {\n\n\t\t\t\tif (this._strokeDp) {\n\t\t\t\t\tthis._strokeDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._strokeDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tbackground.set(\"stroke\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.get(\"getLabelFillFromSprite\")) {\n\n\t\t\t\tif (this._labelDp) {\n\t\t\t\t\tthis._labelDp.dispose();\n\t\t\t\t}\n\n\t\t\t\tif (fill != null) {\n\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t}\n\n\t\t\t\tthis._labelDp = tooltipTarget.on(\"fill\" as any, (fill) => {\n\t\t\t\t\tif (fill != null) {\n\t\t\t\t\t\tthis.label.set(\"fill\", fill as any);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthis._updateTextColor(fill);\n\t}\n\n\n\tprotected _updateTextColor(fill?: Color | Pattern) {\n\t\tif (this.get(\"autoTextColor\")) {\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this.get(\"background\")!.get(\"fill\") as Color;\n\t\t\t}\n\n\t\t\tif (fill == null) {\n\t\t\t\tfill = this._root.interfaceColors.get(\"background\");\n\t\t\t}\n\n\t\t\tif (fill instanceof Color) {\n\t\t\t\tthis.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _setDataItem(dataItem?: DataItem<IComponentDataItem>): void {\n\t\tsuper._setDataItem(dataItem);\n\t\tthis.label._setDataItem(dataItem);\n\t}\n\n\n\tprotected _updateBackground() {\n\t\tsuper.updateBackground();\n\t\tconst parent = this._root.container;\n\n\t\tif (parent) {\n\n\t\t\tlet cw = 0.5;\n\t\t\tlet ch = 0.5;\n\n\t\t\tlet centerX = this.get(\"centerX\");\n\t\t\tif (centerX instanceof Percent) {\n\t\t\t\tcw = centerX.value;\n\t\t\t}\n\n\t\t\tlet centerY = this.get(\"centerY\");\n\t\t\tif (centerY instanceof Percent) {\n\t\t\t\tch = centerY.value;\n\t\t\t}\n\n\t\t\tlet parentW = parent.width();\n\t\t\tlet parentH = parent.height();\n\n\t\t\tconst bounds = this.get(\"bounds\", { left: 0, top: 0, right: parentW, bottom: parentH });\n\n\t\t\tthis._updateBounds();\n\n\t\t\tlet w = this.width();\n\t\t\tlet h = this.height();\n\n\t\t\t// use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n\t\t\tif (w === 0) {\n\t\t\t\tw = this._w;\n\t\t\t}\n\n\t\t\tif (h === 0) {\n\t\t\t\th = this._h;\n\t\t\t}\n\n\t\t\tlet pointTo = this.get(\"pointTo\", { x: parentW / 2, y: parentH / 2 });\n\t\t\tlet x = pointTo.x;\n\t\t\tlet y = pointTo.y;\n\n\t\t\tlet pointerOrientation = this.get(\"pointerOrientation\");\n\n\t\t\tlet background = this.get(\"background\");\n\t\t\tlet pointerLength = 0;\n\t\t\tlet bgStrokeSizeY = 0;\n\t\t\tlet bgStrokeSizeX = 0;\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tpointerLength = background.get(\"pointerLength\", 0);\n\t\t\t\tbgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n\t\t\t\tbgStrokeSizeX = bgStrokeSizeY;\n\t\t\t}\n\n\t\t\tlet pointerX = 0;\n\t\t\tlet pointerY = 0;\n\n\t\t\tlet boundsW = bounds.right - bounds.left;\n\t\t\tlet boundsH = bounds.bottom - bounds.top;\n\n\n\n\t\t\t// horizontal\n\t\t\tif (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n\t\t\t\tbgStrokeSizeY = 0;\n\t\t\t\tif (pointerOrientation == \"horizontal\") {\n\t\t\t\t\tif (x > bounds.left + boundsW / 2) {\n\t\t\t\t\t\tx -= (w * (1 - cw) + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx += (w * cw + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"left\") {\n\t\t\t\t\tx += (w * (1 - cw) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx -= (w * cw + pointerLength);\n\t\t\t\t\tbgStrokeSizeX *= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// vertical pointer\n\t\t\telse {\n\t\t\t\tbgStrokeSizeX = 0;\n\t\t\t\tif (pointerOrientation == \"vertical\") {\n\t\t\t\t\tif (y > bounds.top + h / 2 + pointerLength) {\n\t\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pointerOrientation == \"down\") {\n\t\t\t\t\ty -= (h * (1 - ch) + pointerLength);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ty += (h * ch + pointerLength);\n\t\t\t\t\tbgStrokeSizeY *= -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n\t\t\ty = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n\n\t\t\tpointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n\t\t\tpointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n\n\t\t\tthis._fx = x;\n\t\t\tthis._fy = y;\n\n\t\t\tconst animationDuration = this.get(\"animationDuration\", 0);\n\n\t\t\tif (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n\t\t\t\tconst animationEasing = this.get(\"animationEasing\");\n\t\t\t\tthis.animate({ key: \"x\", to: x, duration: animationDuration, easing: animationEasing });\n\t\t\t\tthis.animate({ key: \"y\", to: y, duration: animationDuration, easing: animationEasing });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.set(\"x\", x);\n\t\t\t\tthis.set(\"y\", y);\n\t\t\t}\n\n\t\t\tif (background instanceof PointedRectangle) {\n\t\t\t\tbackground.set(\"pointerX\", pointerX);\n\t\t\t\tbackground.set(\"pointerY\", pointerY);\n\t\t\t}\n\n\t\t\tif (w > 0) {\n\t\t\t\tthis._w = w;\n\t\t\t}\n\t\t\tif (h > 0) {\n\t\t\t\tthis._h = h;\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}