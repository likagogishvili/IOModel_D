{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar CategoryAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n\n      return this.properties.category;\n    },\n\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\n\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar CategoryAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n\n\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\"; // Set field name\n\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n\n    _this._disposers.push(_this._lastDataItem); // Apply theme\n\n\n    _this.applyTheme();\n\n    var dataItemsByCategory = _this.dataItemsByCategory;\n\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n\n    var category = dataItem[\"category\" + this.axisLetter];\n\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n\n    _super.prototype.validateDataRange.call(this);\n\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n\n        var endIndex = _this.positionToIndex(_this.end);\n\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        } // range might not change, but axis breaks might.\n\n\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    } // find frequency at which we'll show items\n\n\n    var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n\n    this._frequency = frequency;\n\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    this.maxZoomFactor = this.dataItems.length;\n\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n\n    this.resetIterators(); // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n\n            dataItem.__disabled = true;\n          }\n\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n\n              dataItem.__disabled = false;\n\n              _this.appendDataItem(dataItem);\n\n              _this.validateDataElement(dataItem, itemIndex_1);\n\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n\n\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++; //dataItem.__disabled = false;\n\n    var renderer = this.renderer;\n\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n\n      renderer.updateLabelElement(label, position, endPosition);\n\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n\n\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext); // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n\n\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n\n\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize; // value to the right of break end\n\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          } // value to the left of break start\n          else if (index < breakStartIndex) {} // value within break\n          else {\n            index = breakStartIndex + (index - breakStartIndex) * breakSize;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n\n\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n\n\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n\n\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n\n\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n\n\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  }; // todo: optimize\n\n\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n\n      var dataItem = this.dataItems.getIndex(index_1);\n\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        }); //@todo\n\n        if (findNearest) {}\n\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n\n\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n\n\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n\n    if (position < 0) {\n      position = 0;\n    }\n\n    if (position > 1) {\n      position = 1;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks; // in case we have some axis breaks\n\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize); // position to the right of break end\n\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        } // position to the left of break start\n        else if (position < breakStartPosition) {} // value within break\n        else {\n          var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n          index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n          return false;\n        }\n\n        return true;\n      });\n    }\n\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    } // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n\n\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return CategoryAxis;\n}(Axis);\n\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"mappings":"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","names":["Axis","AxisDataItem","AxisRendererX","AxisRendererY","registry","Dictionary","CategoryAxisBreak","$math","$type","$iter","__extends","_super","_this","className","text","locations","category","endCategory","deltaPosition","applyTheme","Object","CategoryAxisDataItem","_adapterO","isEnabled","apply","properties","value","oldCategory","setProperty","hasValue","component","validateDataElement","deltaCoordinate","invalidateDataItems","invalidateSeries","axisFieldName","_lastDataItem","createDataItem","_disposers","push","dataItemsByCategory","addDisposer","mainDataSet","events","on","event","removeKey","oldValue","CategoryAxis","dataItem","axisLetter","processSeriesDataItem","call","categoryAxisDataItem","getKey","seriesId","uid","seriesDataItems","dataItems","remove","validateDataRange","each","_series","iterator","series","xAxis","yAxis","invalidateDataRange","startIndex","positionToIndex","start","endIndex","end","length","minIndex","maxIndex","i","axisDataItem","getIndex","i_1","seriesDataItem","index","isNumber","_axisBreaks","validate","dataCount","fitToRange","Math","floor","ceil","renderer","invalid","maxCount","axisLength","max","minGridDistance","Number","MAX_SAFE_INTEGER","frequency","min","_startIndex","_endIndex","fixAxisBreaks","_frequency","maxZoomFactor","resetIterators","itemIndex","__disabled","len","round","axisBreak","isInBreak","appendDataItem","axisBreaks","adjustedStartValue","adjustedEndValue","intersect","b","frequency_1","breakSize","itemIndex_1","validateBreaks","validateAxisRanges","ghostLabel","invalidate","invalidateLayout","_axisItemCount","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillPosition","fillEndPosition","isRange","point","positionToPoint","tick","disabled","updateTickElement","grid","updateGridElement","label","undefined","updateLabelElement","measuredWidth","measuredHeight","html","currentText","fill","axisFill","location","updateFillElement","fillRule","bullet","updateBullet","mask","clear","disposeData","dataContext","processDataItem","setKey","dataFields","create","difference","adjustDifference","startLocation","endLocation","eachContinue","breakStartIndex","breakEndIndex","categoryToPosition","angle","positionToAngle","x","y","categoryToPoint","startCategory","zoomToIndexes","startPos","endPos","getPositionRangePath","categoryX","categoryY","findNearest","index_1","category_1","sdi_1","abs","key","stackKey","range","getPositionX","isNaN","basePoint","categories","getPositionY","roundPosition","tooltipDataItem","tooltip","tooltipText","breakStartPosition","startPosition","breakEndPosition","breakPosition","getPositionLabel","initRenderer","baseGrid","getPropertyValue","setPropertyValue","config","sortBySeries","isString","map","hasKey","addDelayedMap","processConfig","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/axes/CategoryAxis.ts"],"sourcesContent":["/**\r\n * Category axis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisItemLocation, AxisDataItem, IAxisProperties, IAxisDataFields, IAxisAdapters, IAxisEvents, IAxisDataItemAdapters } from \"./Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { SerialChart } from \"../types/SerialChart\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { Grid } from \"./Grid\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { ColumnSeries } from \"../series/ColumnSeries\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class CategoryAxisDataItem extends AxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: CategoryAxis;\r\n\r\n\tpublic seriesDataItems: { [index: string]: XYSeriesDataItem[] } = {};\r\n\r\n\tpublic deltaAnimation: Animation;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisDataItemAdapters;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxisDataItem\";\r\n\t\tthis.text = \"{category}\";\r\n\r\n\t\tthis.locations.category = 0;\r\n\t\tthis.locations.endCategory = 1;\r\n\r\n\t\tthis.deltaPosition = 0;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Category.\r\n\t *\r\n\t * @param value  Category\r\n\t */\r\n\tpublic set category(value: string) {\r\n\t\tlet oldCategory = this.properties.category;\r\n\t\tthis.setProperty(\"category\", value);\r\n\t\tif ($type.hasValue(oldCategory) && oldCategory != value) {\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.validateDataElement(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get category(): string {\r\n\t\tif (this._adapterO) {\r\n\t\t\tif (this._adapterO.isEnabled(\"category\")) {\r\n\t\t\t\treturn this._adapterO.apply(\"category\", this.properties.category);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.properties.category;\r\n\t}\r\n\r\n\t/**\r\n\t * End category.\r\n\t *\r\n\t * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n\t *\r\n\t * @param value  End category\r\n\t */\r\n\tpublic set endCategory(value: string) {\r\n\t\tthis.setProperty(\"endCategory\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End category\r\n\t */\r\n\tpublic get endCategory(): string {\r\n\t\treturn this.properties.endCategory;\r\n\t}\r\n\r\n\tpublic set deltaPosition(value: number) {\r\n\t\tif (value != this.properties.deltaCoordinate) {\r\n\t\t\tthis.setProperty(\"deltaCoordinate\", value);\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.invalidateDataItems();\r\n\t\t\t\tthis.component.invalidateSeries();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get deltaPosition(): number {\r\n\t\treturn this.properties.deltaCoordinate;\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DataItem]]\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisDataItemAdapters extends IAxisDataItemAdapters {\r\n\tcategory: string;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisDataFields extends IAxisDataFields {\r\n\r\n\t/**\r\n\t * A field that holds category information.\r\n\t */\r\n\tcategory?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisProperties extends IAxisProperties {\r\n\tsortBySeries?: ColumnSeries;\r\n}\r\n\r\n/**\r\n * Defines events for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisEvents extends IAxisEvents { }\r\n\r\n/**\r\n * Defines adapter for [[CategoryAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisAdapters extends IAxisAdapters, ICategoryAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class CategoryAxis<T extends AxisRenderer = AxisRenderer> extends Axis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: ICategoryAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ICategoryAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ICategoryAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: CategoryAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: CategoryAxisBreak;\r\n\r\n\t/**\r\n\t * A reference to chart the axis is for.\r\n\t */\r\n\tpublic chart: SerialChart;\r\n\r\n\t/**\r\n\t * Frequency of the labels on axis.\r\n\t */\r\n\tprotected _frequency: number;\r\n\r\n\t/**\r\n\t * A collection that holds Axis' data items sorted by each category.\r\n\t */\r\n\tpublic dataItemsByCategory: Dictionary<string, this[\"_dataItem\"]> = new Dictionary<string, this[\"_dataItem\"]>();\r\n\r\n\t/**\r\n\t * last data item is used for the closing grid\r\n\t */\r\n\tprotected _lastDataItem: CategoryAxisDataItem;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxis\";\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"category\";\r\n\r\n\t\tthis._lastDataItem = this.createDataItem();\r\n\t\tthis._lastDataItem.component = this;\r\n\t\tthis._disposers.push(this._lastDataItem);\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t\tlet dataItemsByCategory = this.dataItemsByCategory;\r\n\t\tthis.addDisposer(this.mainDataSet.events.on(\"removed\", function(event) {\r\n\t\t\tdataItemsByCategory.removeKey(event.oldValue.category);\r\n\t\t}))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new CategoryAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new CategoryAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tsuper.processSeriesDataItem(dataItem, axisLetter);\r\n\t\tlet category: string = (<any>dataItem)[\"category\" + this.axisLetter];\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet categoryAxisDataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (categoryAxisDataItem) {\r\n\t\t\t\tlet seriesId = dataItem.component.uid;\r\n\t\t\t\tlet seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n\t\t\t\tif (!seriesDataItems) {\r\n\t\t\t\t\tseriesDataItems = [];\r\n\t\t\t\t\tcategoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n\t\t\t\t}\r\n\t\t\t\tseriesDataItems.push(dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.component.dataItems.remove(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateDataRange(): void {\r\n\r\n\t\tsuper.validateDataRange();\r\n\r\n\t\t$iter.each(this._series.iterator(), (series) => {\r\n\t\t\tif ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet startIndex = this.positionToIndex(this.start);\r\n\t\t\t\tlet endIndex = this.positionToIndex(this.end);\r\n\r\n\t\t\t\tif (endIndex >= this.dataItems.length) {\r\n\t\t\t\t\tendIndex--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet seriesId = series.uid;\r\n\t\t\t\tlet minIndex: number;\r\n\t\t\t\tlet maxIndex: number;\r\n\r\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\r\n\t\t\t\t\tlet axisDataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif (axisDataItem) {\r\n\t\t\t\t\t\tlet seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n\r\n\t\t\t\t\t\tif (seriesDataItems) {\r\n\t\t\t\t\t\t\tfor (let i = 0; i < seriesDataItems.length; i++) {\r\n\t\t\t\t\t\t\t\tlet seriesDataItem = seriesDataItems[i];\r\n\t\t\t\t\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\t\t\t\t\tlet index = seriesDataItem.index;\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(minIndex) || index < minIndex) {\r\n\t\t\t\t\t\t\t\t\t\tminIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n\t\t\t\t\t\t\t\t\t\tmaxIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(minIndex)) {\r\n\t\t\t\t\tseries.startIndex = minIndex;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.start = this.start;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(maxIndex)) {\r\n\t\t\t\t\tseries.endIndex = maxIndex + 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.end = this.end;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// range might not change, but axis breaks might.\r\n\t\t\t\tif (this._axisBreaks && this._axisBreaks.length > 0) {\r\n\t\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the whole axis. Causes it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tlet dataCount: number = this.dataItems.length;\r\n\r\n\t\tlet startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n\t\tlet endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n\r\n\t\tif (this.renderer.invalid) {\r\n\t\t\tthis.renderer.validate();\r\n\t\t}\r\n\r\n\t\t// find frequency at which we'll show items\r\n\t\tlet maxCount: number = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\r\n\t\tlet frequency: number = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\tthis._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\tthis._endIndex = Math.ceil(this.end * dataCount);\r\n\r\n\t\tthis.fixAxisBreaks();\r\n\r\n\t\tif (this._startIndex == this._endIndex) {\r\n\t\t\tthis._endIndex++;\r\n\t\t}\r\n\r\n\t\tthis._frequency = frequency;\r\n\r\n\t\tif (this.axisLength <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.maxZoomFactor = this.dataItems.length;\r\n\t\tif (this.dataItems.length <= 0) {\r\n\t\t\tthis.maxZoomFactor = 1;\r\n\t\t}\r\n\r\n\t\tthis.resetIterators();\r\n\r\n\t\t// it's important to use protected variables here, as getters will return 0 - length\r\n\t\t// TODO use iterator instead\r\n\t\t// @ todo: not solved cat axis item fading\r\n\t\tstartIndex = $math.max(0, this._startIndex - this._frequency);\r\n\t\tendIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n\r\n\t\tlet itemIndex = 0;\r\n\r\n\t\tfor (let i = 0; i < startIndex; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tif (i < this.dataItems.length) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (i / this._frequency == Math.round(i / this._frequency)) {\r\n\t\t\t\t\tlet axisBreak: CategoryAxisBreak = this.isInBreak(i);\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//previously we disabled all before, but this is better for cpu\r\n\t\t\t\t\t//this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.appendDataItem(this._lastDataItem);\r\n\t\tthis.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\tlet adjustedStartValue: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet adjustedEndValue: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: this._startIndex, end: this._endIndex })) {\r\n\r\n\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n\t\t\t\t\t\tlet dataItem = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet frequency: number = $math.fitToRange(Math.ceil(this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n\t\t\t\t\tlet itemIndex = 0;\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency) {\r\n\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t\t\titemIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.validateBreaks();\r\n\t\tthis.validateAxisRanges();\r\n\r\n\t\tthis.ghostLabel.invalidate(); // solves font issue\r\n\t\tthis.renderer.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem   [description]\r\n\t * @param itemIndex  [description]\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"], itemIndex?: number, index?: number): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\t//dataItem.__disabled = false;\r\n\r\n\t\tlet renderer: AxisRenderer = this.renderer;\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = this.categoryToIndex(dataItem.category);\r\n\t\t}\r\n\r\n\t\tlet endIndex = this.categoryToIndex(dataItem.endCategory);\r\n\r\n\t\tif (!$type.isNumber(endIndex)) {\r\n\t\t\tendIndex = index;\r\n\t\t}\r\n\r\n\t\tlet position: number = this.indexToPosition(index, dataItem.locations.category);\r\n\t\tlet endPosition: number = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n\r\n\t\tdataItem.position = position;\r\n\r\n\t\tlet fillEndIndex: number;\r\n\t\tlet fillPosition: number;\r\n\t\tlet fillEndPosition: number;\r\n\r\n\t\tif (dataItem.isRange) {\r\n\t\t\tfillEndIndex = endIndex;\r\n\t\t\tfillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n\t\t}\r\n\r\n\t\tdataItem.point = renderer.positionToPoint(position);\r\n\r\n\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\tif (tick && !tick.disabled) {\r\n\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t}\r\n\r\n\t\tlet grid: Grid = dataItem.grid;\r\n\t\tif (grid && !grid.disabled) {\r\n\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet label: AxisLabel = dataItem.label;\r\n\t\tif (label && !label.disabled) {\r\n\t\t\t// theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\r\n\t\t\tif (!dataItem.isRange || label.text == undefined) {\r\n\t\t\t\tdataItem.text = dataItem.text;\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateLabelElement(label, position, endPosition);\r\n\r\n\t\t\tif ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n\t\t\t\tif (dataItem.label.html) {\r\n\t\t\t\t\tthis.ghostLabel.html = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.ghostLabel.text = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\tif (fill && !fill.disabled) {\r\n\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tfillEndIndex = index + this._frequency;\r\n\t\t\t\tfillPosition = this.indexToPosition(index, fill.location);\r\n\t\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tthis.fillRule(dataItem, itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (dataItem.bullet) {\r\n\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\tif (mask) {\r\n\t\t\trenderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tthis.dataItemsByCategory.clear();\r\n\t\tsuper.disposeData();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  The raw data that corresponds to this data item\r\n\t */\r\n\tpublic processDataItem(dataItem: this[\"_dataItem\"], dataContext: Object): void {\r\n\t\tif (dataItem) {\r\n\t\t\t// creat a collection for fast access\r\n\t\t\tsuper.processDataItem(dataItem, dataContext);\r\n\t\t\t// check if such category already exists\r\n\t\t\t//let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n\t\t\t//if (existingDataItem && existingDataItem != dataItem) {\r\n\t\t\t//\tthis.dataItems.remove(existingDataItem);\r\n\t\t\t//}\r\n\r\n\t\t\tif ($type.hasValue(dataItem.category)) {\r\n\t\t\t\tthis.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected getDataItem(dataContext?: any): this[\"_dataItem\"] {\r\n\t\tlet category: string = <string>(dataContext[this.dataFields.category]);\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.dataItems.create();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a category index to an actual screen coordinate on the axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param index     Index\r\n\t * @param location  Location (0-1)\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic indexToPosition(index: number, location?: AxisItemLocation | number): number {\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = 0.5;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet difference: number = this.adjustDifference(startIndex, endIndex);\r\n\r\n\t\tlet startLocation = this.startLocation;\r\n\t\tlet endLocation = this.endLocation;\r\n\r\n\t\tdifference -= startLocation;\r\n\t\tdifference -= (1 - endLocation);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n\t\t\t\t\tbreakStartIndex = Math.max(startIndex, breakStartIndex);\r\n\t\t\t\t\tbreakEndIndex = Math.min(endIndex, breakEndIndex);\r\n\r\n\t\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\t\t// value to the right of break end\r\n\t\t\t\t\tif (index > breakEndIndex) {\r\n\t\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value to the left of break start\r\n\t\t\t\t\telse if (index < breakStartIndex) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value within break\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tindex = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet deltaPosition = 0;\r\n\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\t\tif (dataItem) {\r\n\t\t\tdeltaPosition = dataItem.deltaPosition;\r\n\t\t}\r\n\r\n\t\treturn $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Position\r\n\t */\r\n\tpublic categoryToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.categoryToIndex(category);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic categoryToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\tlet position = this.categoryToPosition(category, location);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tanyToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\treturn this.categoryToPoint(category, location);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * An alias to `categoryToPosition()`.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\treturn this.categoryToPosition(category, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts named category to an index of data item it corresponds to.\r\n\t *\r\n\t * @param category  Category\r\n\t * @return Data item index\r\n\t */\r\n\tpublic categoryToIndex(category: string): number {\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific named ctaegories.\r\n\t *\r\n\t * @param startCategory  Start category\r\n\t * @param endCategory    End category\r\n\t */\r\n\tpublic zoomToCategories(startCategory: string, endCategory: string): void {\r\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * [getAnyRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param start         [description]\r\n\t * @param end           [description]\r\n\t * @param startLocation [description]\r\n\t * @param endLocation   [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getAnyRangePath(start: string, end: string, startLocation?: AxisItemLocation, endLocation?: AxisItemLocation): string {\r\n\t\tlet startPos: number = this.categoryToPosition(start, startLocation);\r\n\t\tlet endPos: number = this.categoryToPosition(end, endLocation);\r\n\t\treturn this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position (px) within axis and adjust it to a specific\r\n\t * `location` within category it corresponds to.\r\n\t *\r\n\t * @param position  Source position (px)\r\n\t * @param location  Location within category (0-1)\r\n\t * @return Adjusted position (px)\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.positionToIndex(position);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns first series data item with specific category\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getFirstSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = 0; i < series.dataItems.length; i++) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns last series data item with specific category.\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getLastSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// todo: optimize\r\n\tpublic getSeriesDataItemByCategory(category: string, series: XYSeries): XYSeriesDataItem {\r\n\t\tlet seriesDataItem: XYSeriesDataItem;\r\n\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn seriesDataItem;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a data item from Series that corresponds to a specific absolute\r\n\t * position on the Axis.\r\n\t *\r\n\t * @param series    Target series\r\n\t * @param position  Position (px)\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tif ($type.isNumber(position)) {\r\n\r\n\t\t\tlet index = this.positionToIndex(position);\r\n\r\n\t\t\tif (index >= this.dataItems.length) {\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet category = dataItem.category;\r\n\t\t\t\tlet sdi: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet seriesDataItem = series.dataItems.getIndex(index);\r\n\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryX == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryY == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//@todo\r\n\t\t\t\tif (findNearest) {\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sdi;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\r\n\t\tlet position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).y;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack key (?)\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.categoryToPosition(dataItem.categories[key], location);\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the start of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell start position (px)\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the end of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell end position (px)\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a category tooltip, based on specific position\r\n\t * within axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position (px)\r\n\t * @return Label (category)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\r\n\t\tif (dataItem) {\r\n\t\t\tthis.tooltipDataItem = dataItem;\r\n\t\t\tthis.tooltip.dataItem = dataItem;\r\n\t\t\tif (this.tooltipText) {\r\n\t\t\t\treturn this.tooltipText;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this._adapterO) {\r\n\t\t\t\treturn dataItem.category;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the category that corresponds to specific pixel\r\n\t * position within axis.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Category index\r\n\t */\r\n\tpublic positionToIndex(position: number): number {\r\n\t\tposition = $math.round(position, 10);\r\n\t\tif (position < 0) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tif (position > 1) {\r\n\t\t\tposition = 1;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet difference: number = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n\r\n\t\tposition += 1 / difference * this.startLocation;\r\n\t\tlet index: number = null;\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t// in case we have some axis breaks\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartPosition: number = axisBreak.startPosition;\r\n\t\t\t\tlet breakEndPosition: number = axisBreak.endPosition;\r\n\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tbreakStartIndex = $math.max(breakStartIndex, startIndex);\r\n\t\t\t\tbreakEndIndex = $math.min(breakEndIndex, endIndex);\r\n\r\n\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\tdifference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\r\n\t\t\t\t// position to the right of break end\r\n\t\t\t\tif (position > breakEndPosition) {\r\n\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t}\r\n\t\t\t\t// position to the left of break start\r\n\t\t\t\telse if (position < breakStartPosition) {\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// value within break\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n\t\t\t\t\tindex = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = Math.floor(position * difference + startIndex);\r\n\t\t}\r\n\t\tif (index >= this.dataItems.length) {\r\n\t\t\tindex = this.dataItems.length - 1;\r\n\t\t}\r\n\t\t// not good, when panning out of bounds, each time one less item gets selected\r\n\t\t//if (index >= endIndex) {\r\n\t\t//\tindex--;\r\n\t\t//}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n\t *\r\n\t * @since 4.3.8\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic positionToCategory(position: number): string {\r\n\t\treturn this.getPositionLabel(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\t// This makes base grid to be drawn at the end of the axis and adds extra\r\n\t\t// grid which we need to nicely close the chart.\r\n\t\treturn this.renderer.positionToPoint(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes Axis' renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\r\n\t\tlet renderer = this.renderer;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Current frequency of labels of the axis.\r\n\t *\r\n\t * Normally it would be 1, but when labels start to be hidden due\r\n\t * to `minGridDistance` this read-only property will increase.\r\n\t *\r\n\t * @readonly\r\n\t * @since 4.2.0\r\n\t * @return Label frequency\r\n\t */\r\n\tpublic get frequency(): number {\r\n\t\treturn this._frequency;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n\t * by actual values.\r\n\t *\r\n\t * The categories are ordered in descending order (from highest values to\r\n\t * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n\t * E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     // ...\r\n\t *     \"sortBySeries\": \"s1\",\r\n\t *     \"renderer\": {\r\n\t *       // ...\r\n\t *       \"inversed\": true\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.8.7\r\n\t * @param  value  Sort categories?\r\n\t */\r\n\tpublic set sortBySeries(value: ColumnSeries) {\r\n\t\tthis.setPropertyValue(\"sortBySeries\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Sort categories?\r\n\t */\r\n\tpublic get sortBySeries(): ColumnSeries {\r\n\t\treturn this.getPropertyValue(\"sortBySeries\");\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\tif ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n\t\t\t\tif (this.map.hasKey(config.sortBySeries)) {\r\n\t\t\t\t\tconfig.sortBySeries = this.map.getKey(config.sortBySeries);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n\t\t\t\t\tdelete config.sortBySeries;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"]},"metadata":{},"sourceType":"module"}