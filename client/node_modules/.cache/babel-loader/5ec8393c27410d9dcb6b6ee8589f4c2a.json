{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $math from \"./Math\";\n/**\r\n * @ignore\r\n */\n\nexport function segmentedLine(display, segments) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_1 = groups.length; g < len_1; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function line(display, points) {\n  for (var p = 0, len = points.length; p < len; p++) {\n    var point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\n\nexport function clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_2 = groups.length; g < len_2; g++) {\n          var points = groups[g];\n\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedLine(display, points, tensionX, tensionY) {\n  for (var i = points.length - 1; i > 0; i--) {\n    var p0 = points[i];\n    var p1 = points[i - 1];\n\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  var first = points[0];\n  var last = points[points.length - 1];\n  var closed = false;\n\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n  var path = \"\";\n\n  for (var i = 0, len = points.length - 1; i < len; i++) {\n    var p0 = points[i - 1];\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n\n    var controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    var controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n\n  return path;\n}","map":{"version":3,"mappings":"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","names":["$math","segmentedLine","display","segments","s","len","length","groups","firstGroup","firstPoint","moveTo","x","y","g","len_1","line","points","p","point","lineTo","clear","smoothedSegmentedline","tensionX","tensionY","len_2","smoothedLine","i","p0","p1","Math","abs","splice","first","last","closed","round","path","p2","p3","controlPointA","getCubicControlPointA","controlPointB","getCubicControlPointB","bezierCurveTo"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/Draw.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport type { IPoint } from \"./IPoint\"\nimport * as $math from \"./Math\";\nimport type { IGraphics } from \"../render/backend/Renderer\";\n\n/**\n * @ignore\n */\nexport function segmentedLine(display: IGraphics, segments: Array<Array<Array<IPoint>>>) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tline(display, groups[g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function line(display: IGraphics, points: Array<IPoint>) {\n\tfor (let p = 0, len = points.length; p < len; p++) {\n\t\tconst point = points[p];\n\t\tdisplay.lineTo(point.x, point.y);\n\t}\n}\n\n/**\n * @ignore\n */\nexport function moveTo(display: IGraphics, point: IPoint) {\n\tdisplay.moveTo(point.x, point.y);\n}\n\n/**\n * @ignore\n */\nexport function clear(display: IGraphics) {\n\tdisplay.clear();\n}\n\n/**\n * @ignore\n */\nexport function smoothedSegmentedline(display: IGraphics, segments: Array<Array<Array<IPoint>>>, tensionX: number, tensionY: number) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tconst points = groups[g];\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\tdisplay.lineTo(points[0].x, points[0].y)\n\t\t\t\t\t}\n\t\t\t\t\tsmoothedLine(display, points, tensionX, tensionY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function smoothedLine(display: IGraphics, points: Array<IPoint>, tensionX: number, tensionY: number) {\n\n\tfor (let i = points.length - 1; i > 0; i--) {\n\t\tlet p0 = points[i];\n\t\tlet p1 = points[i - 1];\n\n\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\tpoints.splice(i - 1, 1);\n\t\t}\n\t}\n\n\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\tline(display, points);\n\t\treturn;\n\t}\n\n\ttensionX = 1 - tensionX + 0.00001;\n\ttensionY = 1 - tensionY + 0.00001;\n\n\tlet first = points[0];\n\tlet last = points[points.length - 1];\n\n\tlet closed: boolean = false;\n\n\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\tclosed = true;\n\t}\n\n\t// Can't moveTo here, as it wont be possible to have fill then.\n\tlet path: string = \"\";\n\n\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\tlet p0: IPoint = points[i - 1];\n\n\t\tlet p1: IPoint = points[i];\n\n\t\tlet p2: IPoint = points[i + 1];\n\n\t\tlet p3: IPoint = points[i + 2];\n\n\t\tif (i === 0) {\n\t\t\tif (closed) {\n\t\t\t\tp0 = points[len - 2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp0 = points[0];\n\t\t\t}\n\t\t} else if (i == len - 1) {\n\t\t\tif (closed) {\n\t\t\t\tp3 = points[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp3 = p2;\n\t\t\t}\n\t\t}\n\n\n\t\tlet controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n\t\tlet controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n\n\t\tdisplay.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n\t}\n\n\treturn path;\n}\n"]},"metadata":{},"sourceType":"module"}