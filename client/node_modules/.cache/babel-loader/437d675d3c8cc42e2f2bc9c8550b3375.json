{"ast":null,"code":"/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { AMElement } from \"../rendering/AMElement\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\n\nvar TextFormatter =\n/** @class */\nfunction (_super) {\n  __extends(TextFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function TextFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    _this.className = \"TextFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  TextFormatter.prototype.debug = function () {};\n  /**\r\n   * Formats the text according to specifications passed in.\r\n   *\r\n   * @param text    Text to format\r\n   * @param output  Output format (svg, html)\r\n   * @return Formatted text\r\n   */\n\n\n  TextFormatter.prototype.format = function (text, output) {\n    // Apply default\n    if (!$type.hasValue(output)) {\n      output = \"svg\";\n    } // Init return value\n\n\n    var formatted = \"\"; // Replace double (escaped) square spaces with remporary codes\n\n    text = this.escape(text); // Divvy up the string by style tags\n\n    var styles = text.match(/\\[([^\\]]*?)\\]/gm);\n\n    if (!styles) {\n      // Nothing to do here - no formatting elements\n      return this.wrap(text, \"\", output);\n    } // Get pure text - no style tags\n\n\n    var texts = text.split(/\\[[^\\[\\]]*\\]/); // Go through each of the texts and wrap it in style tags\n\n    for (var i = 0, len = texts.length; i < len; i++) {\n      // Get text bit\n      var t = texts[i]; // Check if string is empty\n\n      if (t === \"\") {\n        continue;\n      } // Run through an adapter\n\n\n      t = this.adapter.apply(\"chunk\", t); // Get related style\n\n      var s = \"\";\n\n      if (i > 0) {\n        s = styles[i - 1].replace('[', '').replace(']', '');\n      } // Wrap text in tag\n\n\n      formatted += this.wrap(t, s, output);\n    } // Replace placeholders back\n\n\n    formatted = this.unescape(formatted); // Return result\n\n    return this.cleanUp(formatted);\n  };\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n\n  TextFormatter.prototype.escape = function (text) {\n    return text.replace(/\\[\\[/g, registry.getPlaceholder(\"1\")).replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).replace(/\\]\\]/g, registry.getPlaceholder(\"2\")).replace(/\\{\\{/g, registry.getPlaceholder(\"3\")).replace(/\\}\\}/g, registry.getPlaceholder(\"4\")).replace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n\n  TextFormatter.prototype.unescape = function (text) {\n    return text.replace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").replace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").replace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").replace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").replace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\n  };\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n\n\n  TextFormatter.prototype.cleanUp = function (text) {\n    return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n  };\n  /**\r\n   * Wraps text into corresponding tags.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Styles\r\n   * @param output  Format to output in (svg, html)\r\n   * @return Formatted string\r\n   */\n\n\n  TextFormatter.prototype.wrap = function (text, style, output) {\n    if (style === \"\" || style === \"/\") {\n      //return text;\n      style = \"\";\n    }\n\n    switch (output) {\n      case \"html\":\n        return this.wrapHtml(text, this.translateStyleShortcuts(style));\n\n      default:\n        return this.wrapSvg(text, this.translateStyleShortcuts(style));\n    }\n  };\n  /**\r\n   * Wraps text in styled SVG tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   */\n\n\n  TextFormatter.prototype.wrapSvg = function (text, style) {\n    if (style === \"\") {\n      return \"<tspan>\" + text + \"</tspan>\";\n    } else {\n      return \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\n    }\n  };\n  /**\r\n   * Returns an SVG `<tspan>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text\r\n   * @param style  Style\r\n   * @return Element\r\n   */\n\n\n  TextFormatter.prototype.getSvgElement = function (text, style) {\n    var element = new AMElement(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Wraps text in HTML <span> tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   * @todo Translate SVG styles into HTML ones\r\n   */\n\n\n  TextFormatter.prototype.wrapHtml = function (text, style) {\n    if (style === \"\") {\n      return \"<span>\" + text + \"</span>\";\n    } else {\n      return \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\n    }\n  };\n  /**\r\n   * Returns an HTML `<span>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text/HTML\r\n   * @param style  Style definition\r\n   * @return HTML element\r\n   */\n\n\n  TextFormatter.prototype.getHtmlElement = function (text, style) {\n    var element = document.createElement(\"span\");\n    element.innerHTML = text;\n\n    if (style) {\n      element.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Trabslates SVG CSS into HTML CSS.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  SVG CSS\r\n   * @return HTML CSS\r\n   * @todo Implement actual translation\r\n   */\n\n\n  TextFormatter.prototype.styleSvgToHtml = function (style) {\n    style = style.replace(/fill:/, \"color:\");\n    return style;\n  };\n  /**\r\n   * Translates style shortcuts into full styles, i.e.:\r\n   * \"bold\" => \"font-weight: bold\"\r\n   * \"#f00\" => \"fill: #f00\"\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Untranslated style\r\n   * @return Translated style\r\n   * @todo Implement actual translation\r\n   */\n\n\n  TextFormatter.prototype.translateStyleShortcuts = function (style) {\n    if (style == \"\" || style == \"[ ]\") {\n      return \"\";\n    }\n\n    var cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n\n    if (cached) {\n      return cached;\n    } // Pre-process quoted text\n\n\n    var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\n    if (q) {\n      for (var i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n      }\n    } // Get style parts\n\n\n    var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi); // Empty?\n\n    if (!b) {\n      return style;\n    } // Check each part\n\n\n    for (var i = 0; i < b.length; i++) {\n      if (b[i].match(/^bold$/i)) {\n        // Bold\n        b[i] = \"font-weight:\" + b[i];\n      } else if (b[i] == \"/\") {\n        // Just closing tag\n        // Do nothing\n        b[i] = \"\";\n      } else if (!b[i].match(/:/)) {\n        // Color\n        b[i] = \"fill:\" + b[i];\n      } else {\n        b[i] = b[i].replace(/\\+/g, \" \");\n      }\n    }\n\n    var res = b.join(';');\n    registry.setCache(\"translateStyleShortcuts_\" + style, res);\n    return res;\n  };\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n\n\n  TextFormatter.prototype.chunk = function (text, quotedBlocks, noFormatting) {\n    if (quotedBlocks === void 0) {\n      quotedBlocks = false;\n    }\n\n    if (noFormatting === void 0) {\n      noFormatting = false;\n    } // Init result\n\n\n    var res = []; // Replace double (escaped) square spaces and quotes with temporary codes\n\n    text = this.escape(text); // Deal with style blocks\n\n    var chunks = quotedBlocks ? text.split(\"'\") : [text];\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i]; // Empty?\n\n      if (chunk === \"\") {\n        continue;\n      }\n\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are \"text\" chunks, the rest chunks are\n        // \"value\"\n        chunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\n        chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Placeholder?\n\n          if (chunk2 === $strings.PLACEHOLDER) {\n            continue;\n          } // Empty?\n\n\n          if (chunk2 === \"\") {\n            continue;\n          } // Block or value\n\n\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"value\",\n              \"text\": this.adapter.apply(\"chunk\", chunk2)\n            });\n          } else {\n            res.push({\n              \"type\": noFormatting ? \"value\" : \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are \"text\"\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Empty?\n\n          if (chunk2 === \"\") {\n            continue;\n          } // Block or text\n\n\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"text\",\n              \"text\": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              \"type\": \"image\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          } else {\n            res.push({\n              \"type\": \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Format\r\n   * @return `true` if it is an image\r\n   */\n\n\n  TextFormatter.prototype.isImage = function (text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  };\n\n  return TextFormatter;\n}(BaseObject);\n\nexport { TextFormatter };\nvar formatter;\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\n\nexport function getTextFormatter() {\n  if (formatter == null) {\n    formatter = new TextFormatter();\n  }\n\n  return formatter;\n}\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;","map":{"version":3,"mappings":"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","names":["BaseObject","AMElement","Adapter","registry","$strings","$type","__extends","_super","_this","className","applyTheme","TextFormatter","text","output","hasValue","formatted","escape","styles","match","wrap","texts","split","i","len","length","t","adapter","apply","s","replace","unescape","cleanUp","getPlaceholder","RegExp","style","wrapHtml","translateStyleShortcuts","wrapSvg","element","textContent","node","setAttribute","styleSvgToHtml","document","createElement","innerHTML","cached","getCache","q","b","res","join","setCache","quotedBlocks","noFormatting","chunks","chunk","PLACEHOLDER","chunks2","i2","chunk2","push","isImage","formatter","getTextFormatter","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/core/formatters/TextFormatter.ts"],"sourcesContent":["/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Adapter } from \"../utils/Adapter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * Defines an interface for an object that holds a chunk of text.\r\n */\r\nexport interface ITextChunk {\r\n\r\n\t/**\r\n\t * Type of the chunk.\r\n\t */\r\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\r\n\r\n\t/**\r\n\t * Text.\r\n\t */\r\n\t\"text\": string\r\n\r\n}\r\n\r\n/**\r\n * A list of Adapters for [[TextFormatter]].\r\n */\r\nexport interface ITextFormatterAdapters {\r\n\r\n\t/**\r\n\t * Applied to each chunk of text when it is parsed and added to chunk list.\r\n\t */\r\n\tchunk: string\r\n\r\n}\r\n\r\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\r\nexport class TextFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ITextFormatterAdapters;\r\n\r\n\t/**\r\n\t * Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<TextFormatter, ITextFormatterAdapters>(this);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"TextFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\t/**\r\n\t * Formats the text according to specifications passed in.\r\n\t *\r\n\t * @param text    Text to format\r\n\t * @param output  Output format (svg, html)\r\n\t * @return Formatted text\r\n\t */\r\n\tpublic format(text: string, output?: string): string {\r\n\r\n\t\t// Apply default\r\n\t\tif (!$type.hasValue(output)) {\r\n\t\t\toutput = \"svg\";\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet formatted: string = \"\";\r\n\r\n\t\t// Replace double (escaped) square spaces with remporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Divvy up the string by style tags\r\n\t\tlet styles: string[] | null = text.match(/\\[([^\\]]*?)\\]/gm);\r\n\r\n\t\tif (!styles) {\r\n\t\t\t// Nothing to do here - no formatting elements\r\n\t\t\treturn this.wrap(text, \"\", output);\r\n\t\t}\r\n\r\n\t\t// Get pure text - no style tags\r\n\t\tlet texts: string[] = text.split(/\\[[^\\[\\]]*\\]/);\r\n\r\n\t\t// Go through each of the texts and wrap it in style tags\r\n\t\tfor (let i = 0, len = texts.length; i < len; i++) {\r\n\r\n\t\t\t// Get text bit\r\n\t\t\tlet t: string = texts[i];\r\n\r\n\t\t\t// Check if string is empty\r\n\t\t\tif (t === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Run through an adapter\r\n\t\t\tt = this.adapter.apply(\"chunk\", t);\r\n\r\n\t\t\t// Get related style\r\n\t\t\tlet s: string = \"\";\r\n\t\t\tif (i > 0) {\r\n\t\t\t\ts = styles[i - 1].replace('[', '').replace(']', '');\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap text in tag\r\n\t\t\tformatted += this.wrap(t, s, output);\r\n\t\t}\r\n\r\n\t\t// Replace placeholders back\r\n\t\tformatted = this.unescape(formatted);\r\n\r\n\t\t// Return result\r\n\t\treturn this.cleanUp(formatted);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, registry.getPlaceholder(\"1\")).\r\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\]\\]/g, registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\{\\{/g, registry.getPlaceholder(\"3\")).\r\n\t\t\treplace(/\\}\\}/g, registry.getPlaceholder(\"4\")).\r\n\t\t\treplace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\r\n\t}\r\n\r\n\t/**\r\n\t * Cleans up the text text for leftover double square brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Cleaned up text\r\n\t */\r\n\tpublic cleanUp(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, \"[\").\r\n\t\t\treplace(/\\]\\]/g, \"]\").\r\n\t\t\treplace(/\\{\\{/g, \"{\").\r\n\t\t\treplace(/\\}\\}/g, \"}\").\r\n\t\t\treplace(/\\'\\'/g, \"'\");\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text into corresponding tags.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Styles\r\n\t * @param output  Format to output in (svg, html)\r\n\t * @return Formatted string\r\n\t */\r\n\tpublic wrap(text: string, style: string, output: string): string {\r\n\r\n\t\tif (style === \"\" || style === \"/\") {\r\n\t\t\t//return text;\r\n\t\t\tstyle = \"\";\r\n\t\t}\r\n\r\n\t\tswitch (output) {\r\n\t\t\tcase \"html\":\r\n\t\t\t\treturn this.wrapHtml(text, this.translateStyleShortcuts(style));\r\n\t\t\tdefault:\r\n\t\t\t\treturn this.wrapSvg(text, this.translateStyleShortcuts(style));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in styled SVG tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t */\r\n\tpublic wrapSvg(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<tspan>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG `<tspan>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text\r\n\t * @param style  Style\r\n\t * @return Element\r\n\t */\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = new AMElement(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in HTML <span> tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t * @todo Translate SVG styles into HTML ones\r\n\t */\r\n\tpublic wrapHtml(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<span>\" + text + \"</span>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an HTML `<span>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text/HTML\r\n\t * @param style  Style definition\r\n\t * @return HTML element\r\n\t */\r\n\tpublic getHtmlElement(text: string, style?: string): HTMLElement {\r\n\t\tlet element = document.createElement(\"span\");\r\n\t\telement.innerHTML = text;\r\n\t\tif (style) {\r\n\t\t\telement.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Trabslates SVG CSS into HTML CSS.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  SVG CSS\r\n\t * @return HTML CSS\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic styleSvgToHtml(style: string): string {\r\n\t\tstyle = style.replace(/fill:/, \"color:\");\r\n\t\treturn style;\r\n\t}\r\n\r\n\t/**\r\n\t * Translates style shortcuts into full styles, i.e.:\r\n\t * \"bold\" => \"font-weight: bold\"\r\n\t * \"#f00\" => \"fill: #f00\"\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Untranslated style\r\n\t * @return Translated style\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic translateStyleShortcuts(style: string): string {\r\n\r\n\r\n\t\tif (style == \"\" || style == \"[ ]\") {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet cached = registry.getCache(\"translateStyleShortcuts_\" + style);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// Pre-process quoted text\r\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\r\n\t\tif (q) {\r\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\r\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get style parts\r\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\r\n\r\n\t\t// Empty?\r\n\t\tif (!b) {\r\n\t\t\treturn style;\r\n\t\t}\r\n\r\n\t\t// Check each part\r\n\t\tfor (let i: number = 0; i < b.length; i++) {\r\n\r\n\t\t\tif (b[i].match(/^bold$/i)) {\r\n\t\t\t\t// Bold\r\n\t\t\t\tb[i] = \"font-weight:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse if (b[i] == \"/\") {\r\n\t\t\t\t// Just closing tag\r\n\t\t\t\t// Do nothing\r\n\t\t\t\tb[i] = \"\";\r\n\t\t\t}\r\n\t\t\telse if (!b[i].match(/:/)) {\r\n\t\t\t\t// Color\r\n\t\t\t\tb[i] = \"fill:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tb[i] = b[i].replace(/\\+/g, \" \");\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet res = b.join(';');\r\n\t\tregistry.setCache(\"translateStyleShortcuts_\" + style, res);\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n\t *\r\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\r\n\t * also single out text blocks enclosed within single quotes that no\r\n\t * formatting should be applied to, and they should be displayed as is.\r\n\t *\r\n\t * Default for the above is `false`, so that you can use single quote in text\r\n\t * without escaping it.\r\n\t *\r\n\t * If enabled, single quotes can be escaped by doubling it - adding two\r\n\t * single quotes, which will be replaced by a one single quote in the final\r\n\t * output.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text          Text to chunk\r\n\t * @param quotedBlocks  Use quoted blocks\r\n\t * @param noFormatting  Formatting blocks will be treated as regular text\r\n\t * @return Array of string chunks\r\n\t */\r\n\tpublic chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\r\n\r\n\t\t// Init result\r\n\t\tlet res: ITextChunk[] = [];\r\n\r\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Deal with style blocks\r\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\r\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\tlet chunk = chunks[i];\r\n\r\n\t\t\t// Empty?\r\n\t\t\tif (chunk === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif ((i % 2) === 0) {\r\n\r\n\t\t\t\t// Text outside quotes\r\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\r\n\t\t\t\t// \"value\"\r\n\r\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\r\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Placeholder?\r\n\t\t\t\t\tif (chunk2 === $strings.PLACEHOLDER) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or value\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"value\",\r\n\t\t\t\t\t\t\t\"text\": this.adapter.apply(\"chunk\", chunk2)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// A text within doublequotes\r\n\t\t\t\t// All chunks are \"text\"\r\n\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or text\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"text\",\r\n\t\t\t\t\t\t\t\"text\": chunk2\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isImage(chunk2)) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"image\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if supplied format contains image information and should be\r\n\t * formatted as such.\r\n\t * I.e.: `[img: myImage.png]`\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Format\r\n\t * @return `true` if it is an image\r\n\t */\r\n\tpublic isImage(text: string): boolean {\r\n\t\treturn text.match(/img[ ]?:/) ? true : false;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet formatter: TextFormatter;\r\n\r\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\r\nexport function getTextFormatter(): TextFormatter {\r\n\tif (formatter == null) {\r\n\t\tformatter = new TextFormatter();\r\n\t}\r\n\r\n\treturn formatter;\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;\r\n"]},"metadata":{},"sourceType":"module"}