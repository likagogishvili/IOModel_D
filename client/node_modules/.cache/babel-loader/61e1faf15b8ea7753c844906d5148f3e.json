{"ast":null,"code":"/**\n * @module matrixmath/Matrix\n */\n'use strict';\n\nvar arrays = require('./arrays');\n/**\n * @classdesc A class for representing and working with a mathematical matrix.\n *\n * @property {number} rows Number of rows.\n * @property {number} cols Number of cols.\n * @property {number} length Number of values.\n *\n * @constructor\n *\n * @param {number=} opt_rows The number of rows for the matrix. Default is 0.\n * @param {number=} opt_cols The number of columns for the matrix. Default is same\n *     amount of columns as rows.\n * @param {boolean=} opt_setInitial Whether to set the initial data when created.\n *     The initial data will be set to the identity matrix if it specifies the same\n *     amount of rows as columns. Default is true.\n *\n * @example\n * // Create a 3x3 matrix with data\n * var matrix = new Matrix(3, 3);\n * matrix.setData(\n *   1, 0, 0,\n *   0, 1, 0,\n *   0, 0, 1\n * );\n *\n * // Create a matrix filled with zeros\n * // The matrix will be 3 rows and 2 columns\n * var matrix = new Matrix(3, 2);\n *\n * // Create an identity matrix\n * // The matrix will be 3 rows and 3 columns\n * var matrix = new Matrix(3);\n *\n * // Create a matrix with no data set\n * // The matrix will be 3 rows and 3 columns\n * var matrix = new Matrix(3, 3, false);\n */\n\n\nfunction Matrix(opt_rows, opt_cols, opt_setInitial) {\n  this.rows = opt_rows || 0;\n  this.cols = opt_cols || this.rows;\n  this.length = this.rows * this.cols;\n  this._cache = null;\n  var setInitial = opt_setInitial === undefined ? true : opt_setInitial;\n\n  if (setInitial) {\n    if (this.rows === this.cols) {\n      this.setIdentityData();\n    } else {\n      this.setEmptyData();\n    }\n  }\n}\n/**\n * Add matrices together and return a new matrix.\n * It will clone the first matrix and add to that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\n\n\nMatrix.add = function (var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.add.apply(outputMatrix, matrices);\n  return outputMatrix;\n};\n/**\n * Subtract matrices and return a new matrix.\n * It will clone the first matrix and subtract from that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\n\n\nMatrix.subtract = function (var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.subtract.apply(outputMatrix, matrices);\n  return outputMatrix;\n};\n/**\n * Multiply matrices and return a new matrix.\n * It will clone the first matrix and multiply that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\n\n\nMatrix.multiply = function (var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.multiply.apply(outputMatrix, matrices);\n  return outputMatrix;\n};\n/**\n * Divide matrices and return a new matrix.\n * It will clone the first matrix and divide that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\n\n\nMatrix.divide = function (var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.divide.apply(outputMatrix, matrices);\n  return outputMatrix;\n};\n/**\n * Set the data for this matrix to be only zeros.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.setEmptyData = function () {\n  for (var i = 0, l = this.length; i < l; i++) {\n    this[i] = 0;\n  }\n\n  return this;\n};\n/**\n * Set the data for this matrix to the identity data.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.setIdentityData = function () {\n  for (var i = 0, l = this.length; i < l; i++) {\n    this[i] = i % (this.cols + 1) ? 0 : 1;\n  }\n\n  return this;\n};\n/**\n * Set the data for this matrix.\n *\n * @param {Array.<number>} data An array of values (numbers). Alternatively,\n *     the data can be provided as separate arguments, but if so, the size\n *     must match the current size.\n * @param {number=} opt_rows Number of rows in the new data. If not provided,\n *     the data must match the size of the previous data.\n * @param {number=} opt_cols Number of columns in the new data. If not provided,\n *     the data must match the size of the previous data.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.setData = function (data, opt_rows, opt_cols) {\n  var i, l;\n  var isArray = Array.isArray(data);\n  var rows = opt_rows;\n  var cols = opt_cols;\n\n  if (!isArray) {\n    data = arguments;\n    rows = undefined;\n    cols = undefined;\n  } // If the number of values is different than before, and there was no hint\n  // provided for the size of the new matrix data, we can't modify the data\n  // safely, so we do nothing.\n\n\n  if (data.length !== this.length) {\n    if (rows === undefined || cols === undefined) {\n      return this;\n    } else if (rows * cols !== data.length) {\n      return this;\n    }\n  } // Clean out previous data\n\n\n  for (i = data.length, l = this.length; i < l; i++) {\n    delete this[i];\n  } // Set new data\n\n\n  for (i = 0, l = data.length; i < l; i++) {\n    this[i] = data[i];\n  } // Set new metadata\n\n\n  this.length = data.length;\n  this.rows = rows || this.rows;\n  this.cols = cols || this.cols;\n  return this;\n};\n/**\n * Get the data for this matrix as an array of numbers, with additional data\n * properties for rows and columns counts.\n *\n * @return {Array} An array of numbers, representing the data of the matrix.\n */\n\n\nMatrix.prototype.getData = function () {\n  return getData(this, new Array(this.length));\n};\n/**\n * Get the data for this matrix as a regular array.\n *\n * @return {Array} An array of numbers.\n */\n\n\nMatrix.prototype.toArray = function () {\n  return toArray(this, new Array(this.length));\n};\n/**\n * Get the data for this matrix as a formatted string, which is useful for\n * logging and debugging. It will be formatted with line breaks to visualize\n * the rows and columns.\n *\n * @param {number|string=} opt_indentation Optional argument to control\n *     indentation in the output string. If set to a number, the indentation\n *     will be that many spaces wide. If it is a string, the indentation will be\n *     this string. It will default to two spaces.\n * @param {string=} opt_separator Optional argument to control what separates\n *     the values in the output string. It will default to two spaces.\n * @param {string=} opt_start String to start the output with. Default is '['.\n * @param {string=} opt_end String to end the output with. Default is ']'.\n *\n * @return {string} A string representation of the data.\n */\n\n\nMatrix.prototype.toLogString = function (opt_indentation, opt_separator, opt_start, opt_end) {\n  var array = this.toArray();\n  var beginning;\n  var sep;\n  var separator = typeof opt_separator === 'string' ? opt_separator : '  ';\n  var indentation = '  ';\n\n  if (typeof opt_indentation === 'number') {\n    indentation = new Array(Math.max(0, opt_indentation) + 1).join(' ');\n  } else if (typeof opt_indentation === 'string') {\n    indentation = opt_indentation;\n  }\n\n  var start = typeof opt_start === 'string' ? opt_start : '[';\n  var end = typeof opt_end === 'string' ? opt_end : ']';\n  var string = start;\n\n  for (var i = 0, l = array.length; i < l; i++) {\n    beginning = i % this.cols === 0 ? '\\n' + indentation : '';\n    sep = i % this.cols === this.cols - 1 ? '' : separator;\n    string += beginning + array[i] + sep;\n  }\n\n  string += '\\n' + end;\n  return string;\n};\n/**\n * Copy data from the input matrix to this matrix.\n *\n * @param {Matrix} matrix Input matrix to copy from.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.copy = function (matrix) {\n  var i, l; // If the input matrix is smaller, clear out the values not needed anymore\n\n  if (matrix.length < this.length) {\n    for (i = matrix.length, l = this.length; i < l; i++) {\n      delete this[i];\n    }\n  } // Set new metadata if the matrices are of different size\n\n\n  if (matrix.length !== this.length) {\n    this.length = matrix.length;\n    this.rows = matrix.rows;\n    this.cols = matrix.cols;\n  } // Copy the data from the input matrix to this matrix\n\n\n  for (i = 0, l = this.length; i < l; i++) {\n    this[i] = matrix[i];\n  }\n\n  return this;\n};\n/**\n * Clone this matrix to a new instance.\n *\n * @return {Matrix} A new matrix for the result.\n */\n\n\nMatrix.prototype.clone = function () {\n  return new Matrix(this.rows, this.cols, false).copy(this);\n};\n/**\n * Add matrices together into this matrix.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.add = function (var_args) {\n  var matrices = arguments;\n  var numValues = this.length; // Loop through all the matrices passed to the method\n\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i]; // The size of the matrices must match\n\n    if (matrix.cols !== this.cols || matrix.rows !== this.rows) {\n      continue;\n    } // Loop through all values\n\n\n    for (var n = 0; n < numValues; n++) {\n      // Add the number in that position\n      this[n] += matrix[n];\n    }\n  }\n\n  return this;\n};\n/**\n * Subtract matrices from this matrix.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.subtract = function (var_args) {\n  var matrices = arguments;\n  var numValues = this.length; // Loop through all the matrices passed to the method\n\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i]; // The size of the matrices must match\n\n    if (matrix.cols !== this.cols || matrix.rows !== this.rows) {\n      continue;\n    } // Loop through all values\n\n\n    for (var n = 0; n < numValues; n++) {\n      // Subtract the number in that position\n      this[n] -= matrix[n];\n    }\n  }\n\n  return this;\n};\n/**\n * Multiply matrices into this matrix.\n *\n * @param {...Matrix|number} var_args At least one Matrix instance or a number.\n *     If many, use multiple arguments. If a number, it will make a scalar\n *     multiplication.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.multiply = function (var_args) {\n  var matrices = arguments;\n  var startIndex = 0; // If this matrix is an identity matrix, multiplying it with anything will\n  // just result in this matrix having the exact same data as the matrix to\n  // multiply by. We can avoid one step of multiplication if we make a shortcut\n  // and just copy the data from the next matrix.\n\n  if (this.isIdentity()) {\n    var next;\n\n    while ((next = matrices[startIndex]) !== undefined) {\n      // If a number was found, we must break out and start the multiplication\n      // with this number. Special case is the number 1 though, as that will\n      // result in the same as well.\n      if (typeof next === 'number') {\n        if (next === 1) {\n          startIndex++;\n          continue;\n        } else {\n          break;\n        }\n      } // If a matrix was found, we can safely skip the matrix (either it's an\n      // identity matrix and we'll continue looking for a matrix that isn't an\n      // identity matrix, or it's not an identity matrix and we'll just copy\n      // its data and start multiplying by the next matrix in line).\n\n\n      startIndex++;\n      if (!next.isIdentity()) break;\n    } // No matrix was found in line, meaning we are only dealing with identity\n    // matrices, so it's fine to bail out early, as it will just result in an\n    // identity matrix.\n\n\n    if (!next) return this; // If we did find a matrix, we will copy the data from that matrix into this\n    // one and start multiplying by the next matrix in line.\n\n    if (typeof next !== 'number') {\n      this.copy(next);\n    }\n  }\n\n  var newRows = getData(this, arrays.getWithLength(this.length)); // Loop through all the matrices passed to the method\n\n  for (var i = startIndex, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i]; // Get the number of rows and columns for the target matrix\n\n    var rowsInTarget = newRows.rows;\n    var colsInTarget = newRows.cols;\n    var numValuesInTarget = newRows.length; // A number means we should do a scalar multiplication.\n\n    if (typeof matrix === 'number') {\n      var scale = matrix;\n      var factor = 1 / scale; // Used to not get floating point errors\n      // Loop through all values\n\n      for (var n = 0; n < numValuesInTarget; n++) {\n        // Multiply the number in that position\n        newRows[n] = newRows[n] * (scale * factor) / factor;\n      } // Break this iteration here and continue with next matrix\n\n\n      continue;\n    } // Multiplying with an identity matrix will not make any changes\n\n\n    if (matrix.isIdentity()) continue; // Get the number of rows and columns for the current matrix\n\n    var rowsInCurrent = matrix.rows;\n    var colsInCurrent = matrix.cols; // The number of rows must match the number of columns in the first matrix\n\n    if (colsInTarget !== rowsInCurrent) {\n      continue;\n    } // Create a temporary data array.\n    // This will be used to store values in while reading from newRows.\n\n\n    var tempData = arrays.getWithLength(newRows.rows * matrix.cols);\n    tempData.rows = newRows.rows;\n    tempData.cols = matrix.cols; // Loop through each row from the first matrix\n\n    for (var row = 0; row < rowsInTarget; row++) {\n      // For each row, loop through all columns in second matrix\n      for (var currentCol = 0; currentCol < colsInCurrent; currentCol++) {\n        // For each column, loop through each row in the second matrix\n        for (var currentRow = 0; currentRow < rowsInCurrent; currentRow++) {\n          var outputIndex = row * tempData.cols + currentCol; // Create initial values when they don't exist\n\n          if (!tempData[outputIndex]) tempData[outputIndex] = 0; // Calculate the product of the number at the current position in the first matrix\n          // and the current position in the second matrix. Add the product to the previous\n          // value at the current position in the output data array.\n\n          tempData[outputIndex] += newRows[row * newRows.cols + currentRow] * matrix[currentRow * matrix.cols + currentCol];\n        }\n      }\n    }\n\n    arrays.giveBack(newRows); // Save the temporary data array in newRows, so that the next matrix can be applied\n    // to the output of this iteration instead of the original data.\n\n    newRows = tempData;\n  } // Set the new data for this Matrix instance\n\n\n  this.setData(newRows, newRows.rows, newRows.cols);\n  arrays.giveBack(newRows);\n  return this;\n};\n/**\n * Divide matrices from this matrix.\n * The matrices must be square.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.divide = function (var_args) {\n  var matrices = Array.prototype.slice.call(arguments); // Loop through all the matrices passed to the method\n\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i]; // The matrix must be square. If it's not, remove the\n    // matrix from the list.\n\n    if (matrix.rows !== matrix.cols) {\n      matrices.splice(i, 1);\n      i--;\n      l--;\n      continue;\n    } // To divide matrices, you multiply by the inverse.\n    // So we first store the inverse of all matrices.\n\n\n    matrices[i] = matrix.clone().invert();\n  } // Multiply this matrix with the inverse of all the other matrices\n\n\n  this.multiply.apply(this, matrices);\n  return this;\n};\n/**\n * Raise the matrix to a given power.\n *\n * @param {number} power The power to raise it to.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.power = function (power) {\n  // Matrices that are not square can't be raised\n  if (this.rows !== this.cols) {\n    return this;\n  }\n\n  var matrices = new Array(power - 1);\n\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    matrices[i] = this.clone();\n  }\n\n  this.multiply.apply(this, matrices);\n  return this;\n};\n/**\n * Transpose the matrix.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.transpose = function () {\n  var numRows = this.rows;\n  var numCols = this.cols;\n  var newData = arrays.getWithLength(this.length);\n\n  for (var row = 0; row < numRows; row++) {\n    for (var col = 0; col < numCols; col++) {\n      newData[col * numRows + row] = this[row * numCols + col];\n    }\n  }\n\n  this.setData(newData, numCols, numRows);\n  arrays.giveBack(newData);\n  return this;\n};\n/**\n * Invert the matrix.\n * This only works if it is a square matrix. If it is not,\n * the matrix will stay the same.\n * For this to work, the determinant of the matrix must not\n * be zero. If it is, the matrix will stay the same.\n *\n * @return {Matrix} This Matrix instance.\n */\n\n\nMatrix.prototype.invert = function () {\n  var numRows = this.rows;\n  var numCols = this.cols; // The matrix must be square\n\n  if (numRows !== numCols) return this; // Simple solution for 2x2 matrices\n\n  if (numRows === 2) {\n    var determinant = this.getDeterminant();\n    if (determinant === 0) return this;\n    var invertedDeterminant = 1 / determinant;\n    var m0 = invertedDeterminant * this[3];\n    var m1 = invertedDeterminant * -this[1];\n    var m2 = invertedDeterminant * -this[2];\n    var m3 = invertedDeterminant * this[0];\n    this[0] = m0;\n    this[1] = m1;\n    this[2] = m2;\n    this[3] = m3;\n    return this;\n  } // By using a cache, only the first call to invert will cause a memory increase.\n\n\n  var cache = this._cache || (this._cache = {});\n  var matrixOfCoFactors = cache.matrixOfCoFactors || (cache.matrixOfCoFactors = new Matrix(numRows, numCols, false));\n  var matrix = cache.tempMatrix || (cache.tempMatrix = new Matrix(this.rows, this.cols, false)); // Loop through each number in the matrix\n\n  var i = 0;\n\n  for (var row = 0; row < numRows; row++) {\n    for (var col = 0; col < numCols; col++) {\n      // We need to get a temporary copy of the matrix data in an array\n      var newData = arrays.getWithLength(this.length);\n\n      for (var d = this.length; d--;) {\n        newData[d] = this[d];\n      } // We need to get the determinant of the matrix made by the area\n      // that is not in the current number's row or column. To do this,\n      // we remove the first row and the column where the number is.\n\n\n      removeRow(newData, row, this.cols);\n      removeColumn(newData, col, this.cols);\n      matrix.setData(newData, this.rows - 1, this.cols - 1); // We're now done with the temporary copy of the matrix data\n\n      arrays.giveBack(newData); // Some of the determinants need to change sign to become the cofactor.\n      // This is applied as a checkerboard to the matrix.\n\n      var coFactor = matrix.getDeterminant();\n      var rowAlternate = row % 2 === 1;\n      var colAlternate = col % 2 === 1;\n\n      if (rowAlternate && !colAlternate || colAlternate && !rowAlternate) {\n        coFactor *= -1;\n      } // Set the cofactor in the correct position in the matrix of cofactors.\n\n\n      matrixOfCoFactors[row * matrixOfCoFactors.cols + col] = coFactor;\n      i++;\n    }\n  } // Get the determinant of the original matrix.\n  // This could be done with the getDeterminant method, but this is faster.\n\n\n  var originalDeterminant = 0;\n\n  for (var n = 0; n < numCols; n++) {\n    originalDeterminant += this[n] * matrixOfCoFactors[n];\n  } // Cancel everything if the determinant is zero, since inversion can't be done then\n\n\n  if (originalDeterminant === 0) return this; // Transpose the cofactor of cofactors to get the adjugate matrix\n\n  matrixOfCoFactors.transpose(); // Multiply the matrix of cofactors with the inverse of the determinant,\n  // to get the final inverse of the original matrix.\n\n  var product = matrixOfCoFactors.multiply(1 / originalDeterminant); // Copy the data from the inverted temp matrix to this matrix\n\n  for (var x = 0, y = product.length; x < y; x++) {\n    this[x] = product[x];\n  }\n\n  return this;\n};\n/**\n * Get the determinant of the matrix, if possible.\n *\n * @return {number?} The determinant. The matrix must be square for\n *     this to be possible, so if it's not, this will return null.\n */\n\n\nMatrix.prototype.getDeterminant = function () {\n  var rows = this.rows;\n  var cols = this.cols; // The matrix must be square\n\n  if (rows !== cols) return null; // For a 1x1 matrix ( [[a]] ), the determinant is: a\n\n  if (rows === 1) {\n    return this[0];\n  } // For a 2x2 matrix ( [[a, b], [c, d]] ), the determinant is: a*d - b*c\n\n\n  if (rows === 2) {\n    return this[0] * this[3] - this[1] * this[2];\n  } // For a 3x3 matrix ( [[a, b, c], [d, e, f], [g, h, i]] ), the determinant\n  // is: a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)\n\n\n  if (rows === 3) {\n    var a = this[0];\n    var b = this[1];\n    var c = this[2];\n    var d = this[3];\n    var e = this[4];\n    var f = this[5];\n    var g = this[6];\n    var h = this[7];\n    var i = this[8];\n    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n  } // For 4x4 or larger matrices\n\n\n  if (rows >= 4) {\n    var result = 0; // By using a cache, only the first call to the method will cause a memory increase.\n\n    var cache = this._cache || (this._cache = {});\n    var matrix = cache.tempMatrix || (cache.tempMatrix = new Matrix(this.rows, this.cols, false)); // Loop through each number for the first row\n\n    for (var col = 0; col < cols; col++) {\n      // We need to get a temporary copy of the matrix data in an array\n      var newData = arrays.getWithLength(this.length);\n\n      for (var d = this.length; d--;) {\n        newData[d] = this[d];\n      } // We need to get the determinant of the matrix made by the area\n      // that is not in the current number's row or column. To do this,\n      // we remove the first row and the column where the number is.\n\n\n      removeRow(newData, 0, this.cols);\n      removeColumn(newData, col, this.cols);\n      matrix.setData(newData, this.rows - 1, this.cols - 1); // We're now done with the temporary copy of the matrix data\n\n      arrays.giveBack(newData);\n      result += (col % 2 ? -1 : 1) * this[col] * matrix.getDeterminant();\n    }\n\n    return result;\n  }\n};\n/**\n * Tests if the data of the matrix is the same as the input.\n *\n * @param {Matrix} input Another Matrix instance.\n *\n * @return {Boolean} True if it's the same.\n */\n\n\nMatrix.prototype.equals = function (input) {\n  if (!(input instanceof Matrix)) return false; // If the size does not match, it is not equal\n\n  if (this.rows !== input.rows || this.cols !== input.cols) {\n    return false;\n  } // Check each number and return false if something doesn't match\n\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] !== input[i]) return false;\n  } // If it hasn't returned before, everything matches and is the same\n\n\n  return true;\n};\n/**\n * Tests if the data of the matrix represents the identity matrix.\n *\n * @return {boolean} True if it is the identity matrix, false otherwise.\n */\n\n\nMatrix.prototype.isIdentity = function () {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] !== (i % (this.cols + 1) ? 0 : 1)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Remove a row from the values array.\n *\n * @param {Array} values Array of values.\n * @param {number} row Index of the row.\n * @param {number} colsPerRow Number of columns per row.\n *\n * @private\n */\n\n\nfunction removeRow(values, row, colsPerRow) {\n  values.splice(row * colsPerRow, colsPerRow);\n}\n/**\n * Remove a column from the values array.\n *\n * @param {Array} values Array of values.\n * @param {number} col Index of the column.\n * @param {number} colsPerRow Number of columns per row.\n *\n * @private\n */\n\n\nfunction removeColumn(values, col, colsPerRow) {\n  var n = 0;\n\n  for (var i = 0, l = values.length; i < l; i++) {\n    if (i % colsPerRow !== col) values[n++] = values[i];\n  }\n\n  values.length = n;\n}\n/**\n * Convert a matrix to an array with the values.\n *\n * @param {Matrix} matrix The matrix instance.\n * @param {Array} array The array to use.\n *\n * @return {Array} The array.\n *\n * @private\n */\n\n\nfunction toArray(matrix, array) {\n  for (var i = 0, l = matrix.length; i < l; i++) {\n    array[i] = matrix[i];\n  }\n\n  return array;\n}\n/**\n * Get the matrix data as an array with properties for rows and cols.\n *\n * @param {Matrix} matrix The matrix instance.\n * @param {Array} array The array to use.\n *\n * @return {Array} The array.\n *\n * @private\n */\n\n\nfunction getData(matrix, array) {\n  toArray(matrix, array);\n  array.rows = matrix.rows;\n  array.cols = matrix.cols;\n  return array;\n}\n\nmodule.exports = Matrix;","map":{"version":3,"names":["arrays","require","Matrix","opt_rows","opt_cols","opt_setInitial","rows","cols","length","_cache","setInitial","undefined","setIdentityData","setEmptyData","add","var_args","matrices","Array","prototype","slice","call","arguments","firstMatrix","shift","outputMatrix","clone","apply","subtract","multiply","divide","i","l","setData","data","isArray","getData","toArray","toLogString","opt_indentation","opt_separator","opt_start","opt_end","array","beginning","sep","separator","indentation","Math","max","join","start","end","string","copy","matrix","numValues","n","startIndex","isIdentity","next","newRows","getWithLength","rowsInTarget","colsInTarget","numValuesInTarget","scale","factor","rowsInCurrent","colsInCurrent","tempData","row","currentCol","currentRow","outputIndex","giveBack","splice","invert","power","transpose","numRows","numCols","newData","col","determinant","getDeterminant","invertedDeterminant","m0","m1","m2","m3","cache","matrixOfCoFactors","tempMatrix","d","removeRow","removeColumn","coFactor","rowAlternate","colAlternate","originalDeterminant","product","x","y","a","b","c","e","f","g","h","result","equals","input","values","colsPerRow","module","exports"],"sources":["/Users/macbookpro/Desktop/IOModel_D/client/node_modules/matrixmath/Matrix.js"],"sourcesContent":["/**\n * @module matrixmath/Matrix\n */\n'use strict';\n\nvar arrays = require('./arrays');\n\n/**\n * @classdesc A class for representing and working with a mathematical matrix.\n *\n * @property {number} rows Number of rows.\n * @property {number} cols Number of cols.\n * @property {number} length Number of values.\n *\n * @constructor\n *\n * @param {number=} opt_rows The number of rows for the matrix. Default is 0.\n * @param {number=} opt_cols The number of columns for the matrix. Default is same\n *     amount of columns as rows.\n * @param {boolean=} opt_setInitial Whether to set the initial data when created.\n *     The initial data will be set to the identity matrix if it specifies the same\n *     amount of rows as columns. Default is true.\n *\n * @example\n * // Create a 3x3 matrix with data\n * var matrix = new Matrix(3, 3);\n * matrix.setData(\n *   1, 0, 0,\n *   0, 1, 0,\n *   0, 0, 1\n * );\n *\n * // Create a matrix filled with zeros\n * // The matrix will be 3 rows and 2 columns\n * var matrix = new Matrix(3, 2);\n *\n * // Create an identity matrix\n * // The matrix will be 3 rows and 3 columns\n * var matrix = new Matrix(3);\n *\n * // Create a matrix with no data set\n * // The matrix will be 3 rows and 3 columns\n * var matrix = new Matrix(3, 3, false);\n */\nfunction Matrix(opt_rows, opt_cols, opt_setInitial) {\n  this.rows = opt_rows || 0;\n  this.cols = opt_cols || this.rows;\n  this.length = this.rows * this.cols;\n  this._cache = null;\n\n  var setInitial = opt_setInitial === undefined ? true : opt_setInitial;\n\n  if (setInitial) {\n    if (this.rows === this.cols) {\n      this.setIdentityData();\n    } else {\n      this.setEmptyData();\n    }\n  }\n}\n\n/**\n * Add matrices together and return a new matrix.\n * It will clone the first matrix and add to that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\nMatrix.add = function(var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.add.apply(outputMatrix, matrices);\n\n  return outputMatrix;\n};\n\n/**\n * Subtract matrices and return a new matrix.\n * It will clone the first matrix and subtract from that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\nMatrix.subtract = function(var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.subtract.apply(outputMatrix, matrices);\n\n  return outputMatrix;\n};\n\n/**\n * Multiply matrices and return a new matrix.\n * It will clone the first matrix and multiply that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\nMatrix.multiply = function(var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.multiply.apply(outputMatrix, matrices);\n\n  return outputMatrix;\n};\n\n/**\n * Divide matrices and return a new matrix.\n * It will clone the first matrix and divide that.\n *\n * @param {...Matrix} var_args At least two Matrix instances as\n *     multiple arguments.\n *\n * @return {Matrix} A new matrix for the result.\n */\nMatrix.divide = function(var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n  var firstMatrix = matrices.shift();\n\n  var outputMatrix = firstMatrix.clone();\n  outputMatrix.divide.apply(outputMatrix, matrices);\n\n  return outputMatrix;\n};\n\n/**\n * Set the data for this matrix to be only zeros.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.setEmptyData = function() {\n  for (var i = 0, l = this.length; i < l; i++) {\n    this[i] = 0;\n  }\n\n  return this;\n};\n\n/**\n * Set the data for this matrix to the identity data.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.setIdentityData = function() {\n  for (var i = 0, l = this.length; i < l; i++) {\n    this[i] = i % (this.cols + 1) ? 0 : 1;\n  }\n\n  return this;\n};\n\n/**\n * Set the data for this matrix.\n *\n * @param {Array.<number>} data An array of values (numbers). Alternatively,\n *     the data can be provided as separate arguments, but if so, the size\n *     must match the current size.\n * @param {number=} opt_rows Number of rows in the new data. If not provided,\n *     the data must match the size of the previous data.\n * @param {number=} opt_cols Number of columns in the new data. If not provided,\n *     the data must match the size of the previous data.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.setData = function(data, opt_rows, opt_cols) {\n  var i, l;\n  var isArray = Array.isArray(data);\n  var rows = opt_rows;\n  var cols = opt_cols;\n\n  if (!isArray) {\n    data = arguments;\n    rows = undefined;\n    cols = undefined;\n  }\n\n  // If the number of values is different than before, and there was no hint\n  // provided for the size of the new matrix data, we can't modify the data\n  // safely, so we do nothing.\n  if (data.length !== this.length) {\n    if (rows === undefined || cols === undefined) {\n      return this;\n    } else if (rows * cols !== data.length) {\n      return this;\n    }\n  }\n\n  // Clean out previous data\n  for (i = data.length, l = this.length; i < l; i++) {\n    delete this[i];\n  }\n\n  // Set new data\n  for (i = 0, l = data.length; i < l; i++) {\n    this[i] = data[i];\n  }\n\n  // Set new metadata\n  this.length = data.length;\n  this.rows = rows || this.rows;\n  this.cols = cols || this.cols;\n\n  return this;\n};\n\n/**\n * Get the data for this matrix as an array of numbers, with additional data\n * properties for rows and columns counts.\n *\n * @return {Array} An array of numbers, representing the data of the matrix.\n */\nMatrix.prototype.getData = function() {\n  return getData(this, new Array(this.length));\n};\n\n/**\n * Get the data for this matrix as a regular array.\n *\n * @return {Array} An array of numbers.\n */\nMatrix.prototype.toArray = function() {\n  return toArray(this, new Array(this.length));\n};\n\n/**\n * Get the data for this matrix as a formatted string, which is useful for\n * logging and debugging. It will be formatted with line breaks to visualize\n * the rows and columns.\n *\n * @param {number|string=} opt_indentation Optional argument to control\n *     indentation in the output string. If set to a number, the indentation\n *     will be that many spaces wide. If it is a string, the indentation will be\n *     this string. It will default to two spaces.\n * @param {string=} opt_separator Optional argument to control what separates\n *     the values in the output string. It will default to two spaces.\n * @param {string=} opt_start String to start the output with. Default is '['.\n * @param {string=} opt_end String to end the output with. Default is ']'.\n *\n * @return {string} A string representation of the data.\n */\nMatrix.prototype.toLogString = function(opt_indentation, opt_separator, opt_start, opt_end) {\n  var array = this.toArray();\n\n  var beginning;\n  var sep;\n\n  var separator = typeof opt_separator === 'string' ? opt_separator : '  ';\n  var indentation = '  ';\n\n  if (typeof opt_indentation === 'number') {\n    indentation = (new Array(Math.max(0, opt_indentation) + 1)).join(' ');\n  } else if (typeof opt_indentation === 'string') {\n    indentation = opt_indentation;\n  }\n\n  var start = typeof opt_start === 'string' ? opt_start : '[';\n  var end = typeof opt_end === 'string' ? opt_end : ']';\n\n  var string = start;\n  for (var i = 0, l = array.length; i < l; i++) {\n    beginning = i % this.cols === 0 ? '\\n' + indentation : '';\n    sep = i % this.cols === this.cols - 1 ? '' : separator;\n    string += beginning + array[i] + sep;\n  }\n  string += '\\n' + end;\n\n  return string;\n};\n\n/**\n * Copy data from the input matrix to this matrix.\n *\n * @param {Matrix} matrix Input matrix to copy from.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.copy = function(matrix) {\n  var i, l;\n\n  // If the input matrix is smaller, clear out the values not needed anymore\n  if (matrix.length < this.length) {\n    for (i = matrix.length, l = this.length; i < l; i++) {\n      delete this[i];\n    }\n  }\n\n  // Set new metadata if the matrices are of different size\n  if (matrix.length !== this.length) {\n    this.length = matrix.length;\n    this.rows = matrix.rows;\n    this.cols = matrix.cols;\n  }\n\n  // Copy the data from the input matrix to this matrix\n  for (i = 0, l = this.length; i < l; i++) {\n    this[i] = matrix[i];\n  }\n\n  return this;\n};\n\n/**\n * Clone this matrix to a new instance.\n *\n * @return {Matrix} A new matrix for the result.\n */\nMatrix.prototype.clone = function() {\n  return new Matrix(this.rows, this.cols, false).copy(this);\n};\n\n/**\n * Add matrices together into this matrix.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.add = function(var_args) {\n  var matrices = arguments;\n\n  var numValues = this.length;\n\n  // Loop through all the matrices passed to the method\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i];\n\n    // The size of the matrices must match\n    if (matrix.cols !== this.cols || matrix.rows !== this.rows) {\n      continue;\n    }\n\n    // Loop through all values\n    for (var n = 0; n < numValues; n++) {\n\n      // Add the number in that position\n      this[n] += matrix[n];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Subtract matrices from this matrix.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.subtract = function(var_args) {\n  var matrices = arguments;\n\n  var numValues = this.length;\n\n  // Loop through all the matrices passed to the method\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i];\n\n    // The size of the matrices must match\n    if (matrix.cols !== this.cols || matrix.rows !== this.rows) {\n      continue;\n    }\n\n    // Loop through all values\n    for (var n = 0; n < numValues; n++) {\n\n      // Subtract the number in that position\n      this[n] -= matrix[n];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Multiply matrices into this matrix.\n *\n * @param {...Matrix|number} var_args At least one Matrix instance or a number.\n *     If many, use multiple arguments. If a number, it will make a scalar\n *     multiplication.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.multiply = function(var_args) {\n  var matrices = arguments;\n  var startIndex = 0;\n\n  // If this matrix is an identity matrix, multiplying it with anything will\n  // just result in this matrix having the exact same data as the matrix to\n  // multiply by. We can avoid one step of multiplication if we make a shortcut\n  // and just copy the data from the next matrix.\n  if (this.isIdentity()) {\n    var next;\n    while ((next = matrices[startIndex]) !== undefined) {\n\n      // If a number was found, we must break out and start the multiplication\n      // with this number. Special case is the number 1 though, as that will\n      // result in the same as well.\n      if (typeof next === 'number') {\n        if (next === 1) {\n          startIndex++;\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // If a matrix was found, we can safely skip the matrix (either it's an\n      // identity matrix and we'll continue looking for a matrix that isn't an\n      // identity matrix, or it's not an identity matrix and we'll just copy\n      // its data and start multiplying by the next matrix in line).\n      startIndex++;\n      if (!next.isIdentity()) break;\n    }\n\n    // No matrix was found in line, meaning we are only dealing with identity\n    // matrices, so it's fine to bail out early, as it will just result in an\n    // identity matrix.\n    if (!next) return this;\n\n    // If we did find a matrix, we will copy the data from that matrix into this\n    // one and start multiplying by the next matrix in line.\n    if (typeof next !== 'number') {\n      this.copy(next);\n    }\n  }\n\n  var newRows = getData(this, arrays.getWithLength(this.length));\n\n  // Loop through all the matrices passed to the method\n  for (var i = startIndex, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i];\n\n    // Get the number of rows and columns for the target matrix\n    var rowsInTarget = newRows.rows;\n    var colsInTarget = newRows.cols;\n    var numValuesInTarget = newRows.length;\n\n    // A number means we should do a scalar multiplication.\n    if (typeof matrix === 'number') {\n      var scale = matrix;\n      var factor = 1 / scale; // Used to not get floating point errors\n\n      // Loop through all values\n      for (var n = 0; n < numValuesInTarget; n++) {\n\n        // Multiply the number in that position\n        newRows[n] = newRows[n] * (scale * factor) / factor;\n      }\n\n      // Break this iteration here and continue with next matrix\n      continue;\n    }\n\n    // Multiplying with an identity matrix will not make any changes\n    if (matrix.isIdentity()) continue;\n\n    // Get the number of rows and columns for the current matrix\n    var rowsInCurrent = matrix.rows;\n    var colsInCurrent = matrix.cols;\n\n    // The number of rows must match the number of columns in the first matrix\n    if (colsInTarget !== rowsInCurrent) {\n      continue;\n    }\n\n    // Create a temporary data array.\n    // This will be used to store values in while reading from newRows.\n    var tempData = arrays.getWithLength(newRows.rows * matrix.cols);\n    tempData.rows = newRows.rows;\n    tempData.cols = matrix.cols;\n\n    // Loop through each row from the first matrix\n    for (var row = 0; row < rowsInTarget; row++) {\n\n      // For each row, loop through all columns in second matrix\n      for (var currentCol = 0; currentCol < colsInCurrent; currentCol++) {\n\n        // For each column, loop through each row in the second matrix\n        for (var currentRow = 0; currentRow < rowsInCurrent; currentRow++) {\n          var outputIndex = row * tempData.cols + currentCol;\n\n          // Create initial values when they don't exist\n          if (!tempData[outputIndex]) tempData[outputIndex] = 0;\n\n          // Calculate the product of the number at the current position in the first matrix\n          // and the current position in the second matrix. Add the product to the previous\n          // value at the current position in the output data array.\n          tempData[outputIndex] += newRows[row * newRows.cols + currentRow] * matrix[currentRow * matrix.cols + currentCol];\n        }\n      }\n    }\n    arrays.giveBack(newRows);\n\n    // Save the temporary data array in newRows, so that the next matrix can be applied\n    // to the output of this iteration instead of the original data.\n    newRows = tempData;\n  }\n\n  // Set the new data for this Matrix instance\n  this.setData(newRows, newRows.rows, newRows.cols);\n\n  arrays.giveBack(newRows);\n\n  return this;\n};\n\n/**\n * Divide matrices from this matrix.\n * The matrices must be square.\n *\n * @param {...Matrix} var_args At least one Matrix instance. If many,\n *     use multiple arguments.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.divide = function(var_args) {\n  var matrices = Array.prototype.slice.call(arguments);\n\n  // Loop through all the matrices passed to the method\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    var matrix = matrices[i];\n\n    // The matrix must be square. If it's not, remove the\n    // matrix from the list.\n    if (matrix.rows !== matrix.cols) {\n      matrices.splice(i, 1);\n      i--; l--;\n      continue;\n    }\n\n    // To divide matrices, you multiply by the inverse.\n    // So we first store the inverse of all matrices.\n    matrices[i] = matrix.clone().invert();\n  }\n\n  // Multiply this matrix with the inverse of all the other matrices\n  this.multiply.apply(this, matrices);\n\n  return this;\n};\n\n/**\n * Raise the matrix to a given power.\n *\n * @param {number} power The power to raise it to.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.power = function(power) {\n\n  // Matrices that are not square can't be raised\n  if (this.rows !== this.cols) {\n    return this;\n  }\n\n  var matrices = new Array(power - 1);\n  for (var i = 0, l = matrices.length; i < l; i++) {\n    matrices[i] = this.clone();\n  }\n\n  this.multiply.apply(this, matrices);\n\n  return this;\n};\n\n/**\n * Transpose the matrix.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.transpose = function() {\n  var numRows = this.rows;\n  var numCols = this.cols;\n\n  var newData = arrays.getWithLength(this.length);\n\n  for (var row = 0; row < numRows; row++) {\n    for (var col = 0; col < numCols; col++) {\n      newData[col * numRows + row] = this[row * numCols + col];\n    }\n  }\n  this.setData(newData, numCols, numRows);\n\n  arrays.giveBack(newData);\n\n  return this;\n};\n\n/**\n * Invert the matrix.\n * This only works if it is a square matrix. If it is not,\n * the matrix will stay the same.\n * For this to work, the determinant of the matrix must not\n * be zero. If it is, the matrix will stay the same.\n *\n * @return {Matrix} This Matrix instance.\n */\nMatrix.prototype.invert = function() {\n  var numRows = this.rows;\n  var numCols = this.cols;\n\n  // The matrix must be square\n  if (numRows !== numCols) return this;\n\n  // Simple solution for 2x2 matrices\n  if (numRows === 2) {\n    var determinant = this.getDeterminant();\n    if (determinant === 0) return this;\n\n    var invertedDeterminant = 1 / determinant;\n    var m0 = invertedDeterminant * this[3];\n    var m1 = invertedDeterminant * -this[1];\n    var m2 = invertedDeterminant * -this[2];\n    var m3 = invertedDeterminant * this[0];\n    this[0] = m0;\n    this[1] = m1;\n    this[2] = m2;\n    this[3] = m3;\n\n    return this;\n  }\n\n  // By using a cache, only the first call to invert will cause a memory increase.\n  var cache = this._cache || (this._cache = {});\n  var matrixOfCoFactors = cache.matrixOfCoFactors || (cache.matrixOfCoFactors = new Matrix(numRows, numCols, false));\n  var matrix = cache.tempMatrix || (cache.tempMatrix = new Matrix(this.rows, this.cols, false));\n\n  // Loop through each number in the matrix\n  var i = 0;\n  for (var row = 0; row < numRows; row++) {\n    for (var col = 0; col < numCols; col++) {\n\n      // We need to get a temporary copy of the matrix data in an array\n      var newData = arrays.getWithLength(this.length);\n      for (var d = this.length; d--;) {\n        newData[d] = this[d];\n      }\n\n      // We need to get the determinant of the matrix made by the area\n      // that is not in the current number's row or column. To do this,\n      // we remove the first row and the column where the number is.\n      removeRow(newData, row, this.cols);\n      removeColumn(newData, col, this.cols);\n      matrix.setData(newData, this.rows - 1, this.cols - 1);\n\n      // We're now done with the temporary copy of the matrix data\n      arrays.giveBack(newData);\n\n      // Some of the determinants need to change sign to become the cofactor.\n      // This is applied as a checkerboard to the matrix.\n      var coFactor = matrix.getDeterminant();\n      var rowAlternate = row % 2 === 1;\n      var colAlternate = col % 2 === 1;\n      if ((rowAlternate && !colAlternate) || (colAlternate && !rowAlternate)) {\n        coFactor *= -1;\n      }\n\n      // Set the cofactor in the correct position in the matrix of cofactors.\n      matrixOfCoFactors[row * matrixOfCoFactors.cols + col] = coFactor;\n\n      i++;\n    }\n  }\n\n  // Get the determinant of the original matrix.\n  // This could be done with the getDeterminant method, but this is faster.\n  var originalDeterminant = 0;\n  for (var n = 0; n < numCols; n++) {\n    originalDeterminant += this[n] * matrixOfCoFactors[n];\n  }\n\n  // Cancel everything if the determinant is zero, since inversion can't be done then\n  if (originalDeterminant === 0) return this;\n\n  // Transpose the cofactor of cofactors to get the adjugate matrix\n  matrixOfCoFactors.transpose();\n\n  // Multiply the matrix of cofactors with the inverse of the determinant,\n  // to get the final inverse of the original matrix.\n  var product = matrixOfCoFactors.multiply(1 / originalDeterminant);\n\n  // Copy the data from the inverted temp matrix to this matrix\n  for (var x = 0, y = product.length; x < y; x++) {\n    this[x] = product[x];\n  }\n\n  return this;\n};\n\n/**\n * Get the determinant of the matrix, if possible.\n *\n * @return {number?} The determinant. The matrix must be square for\n *     this to be possible, so if it's not, this will return null.\n */\nMatrix.prototype.getDeterminant = function() {\n  var rows = this.rows;\n  var cols = this.cols;\n\n  // The matrix must be square\n  if (rows !== cols) return null;\n\n  // For a 1x1 matrix ( [[a]] ), the determinant is: a\n  if (rows === 1) {\n    return this[0];\n  }\n\n  // For a 2x2 matrix ( [[a, b], [c, d]] ), the determinant is: a*d - b*c\n  if (rows === 2) {\n    return this[0] * this[3] - this[1] * this[2];\n  }\n\n  // For a 3x3 matrix ( [[a, b, c], [d, e, f], [g, h, i]] ), the determinant\n  // is: a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)\n  if (rows === 3) {\n    var a = this[0];\n    var b = this[1];\n    var c = this[2];\n    var d = this[3];\n    var e = this[4];\n    var f = this[5];\n    var g = this[6];\n    var h = this[7];\n    var i = this[8];\n    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n  }\n\n  // For 4x4 or larger matrices\n  if (rows >= 4) {\n\n    var result = 0;\n\n    // By using a cache, only the first call to the method will cause a memory increase.\n    var cache = this._cache || (this._cache = {});\n    var matrix = cache.tempMatrix || (cache.tempMatrix = new Matrix(this.rows, this.cols, false));\n\n    // Loop through each number for the first row\n    for (var col = 0; col < cols; col++) {\n\n      // We need to get a temporary copy of the matrix data in an array\n      var newData = arrays.getWithLength(this.length);\n      for (var d = this.length; d--;) {\n        newData[d] = this[d];\n      }\n\n      // We need to get the determinant of the matrix made by the area\n      // that is not in the current number's row or column. To do this,\n      // we remove the first row and the column where the number is.\n      removeRow(newData, 0, this.cols);\n      removeColumn(newData, col, this.cols);\n      matrix.setData(newData, this.rows - 1, this.cols - 1);\n\n      // We're now done with the temporary copy of the matrix data\n      arrays.giveBack(newData);\n\n      result += (col % 2 ? -1 : 1) * this[col] * matrix.getDeterminant();\n    }\n\n    return result;\n  }\n};\n\n/**\n * Tests if the data of the matrix is the same as the input.\n *\n * @param {Matrix} input Another Matrix instance.\n *\n * @return {Boolean} True if it's the same.\n */\nMatrix.prototype.equals = function(input) {\n  if (!(input instanceof Matrix)) return false;\n\n  // If the size does not match, it is not equal\n  if (this.rows !== input.rows || this.cols !== input.cols) {\n    return false;\n  }\n\n  // Check each number and return false if something doesn't match\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] !== input[i]) return false;\n  }\n\n  // If it hasn't returned before, everything matches and is the same\n  return true;\n};\n\n/**\n * Tests if the data of the matrix represents the identity matrix.\n *\n * @return {boolean} True if it is the identity matrix, false otherwise.\n */\nMatrix.prototype.isIdentity = function() {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this[i] !== (i % (this.cols + 1) ? 0 : 1)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Remove a row from the values array.\n *\n * @param {Array} values Array of values.\n * @param {number} row Index of the row.\n * @param {number} colsPerRow Number of columns per row.\n *\n * @private\n */\nfunction removeRow(values, row, colsPerRow) {\n  values.splice(row * colsPerRow, colsPerRow);\n}\n\n/**\n * Remove a column from the values array.\n *\n * @param {Array} values Array of values.\n * @param {number} col Index of the column.\n * @param {number} colsPerRow Number of columns per row.\n *\n * @private\n */\nfunction removeColumn(values, col, colsPerRow) {\n  var n = 0;\n  for (var i = 0, l = values.length; i < l; i++) {\n    if (i % colsPerRow !== col) values[n++] = values[i];\n  }\n  values.length = n;\n}\n\n/**\n * Convert a matrix to an array with the values.\n *\n * @param {Matrix} matrix The matrix instance.\n * @param {Array} array The array to use.\n *\n * @return {Array} The array.\n *\n * @private\n */\nfunction toArray(matrix, array) {\n  for (var i = 0, l = matrix.length; i < l; i++) {\n    array[i] = matrix[i];\n  }\n\n  return array;\n}\n\n/**\n * Get the matrix data as an array with properties for rows and cols.\n *\n * @param {Matrix} matrix The matrix instance.\n * @param {Array} array The array to use.\n *\n * @return {Array} The array.\n *\n * @private\n */\nfunction getData(matrix, array) {\n  toArray(matrix, array);\n\n  array.rows = matrix.rows;\n  array.cols = matrix.cols;\n\n  return array;\n}\n\nmodule.exports = Matrix;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAgBC,QAAhB,EAA0BC,QAA1B,EAAoCC,cAApC,EAAoD;EAClD,KAAKC,IAAL,GAAYH,QAAQ,IAAI,CAAxB;EACA,KAAKI,IAAL,GAAYH,QAAQ,IAAI,KAAKE,IAA7B;EACA,KAAKE,MAAL,GAAc,KAAKF,IAAL,GAAY,KAAKC,IAA/B;EACA,KAAKE,MAAL,GAAc,IAAd;EAEA,IAAIC,UAAU,GAAGL,cAAc,KAAKM,SAAnB,GAA+B,IAA/B,GAAsCN,cAAvD;;EAEA,IAAIK,UAAJ,EAAgB;IACd,IAAI,KAAKJ,IAAL,KAAc,KAAKC,IAAvB,EAA6B;MAC3B,KAAKK,eAAL;IACD,CAFD,MAEO;MACL,KAAKC,YAAL;IACD;EACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAX,MAAM,CAACY,GAAP,GAAa,UAASC,QAAT,EAAmB;EAC9B,IAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAf;EACA,IAAIC,WAAW,GAAGN,QAAQ,CAACO,KAAT,EAAlB;EAEA,IAAIC,YAAY,GAAGF,WAAW,CAACG,KAAZ,EAAnB;EACAD,YAAY,CAACV,GAAb,CAAiBY,KAAjB,CAAuBF,YAAvB,EAAqCR,QAArC;EAEA,OAAOQ,YAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtB,MAAM,CAACyB,QAAP,GAAkB,UAASZ,QAAT,EAAmB;EACnC,IAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAf;EACA,IAAIC,WAAW,GAAGN,QAAQ,CAACO,KAAT,EAAlB;EAEA,IAAIC,YAAY,GAAGF,WAAW,CAACG,KAAZ,EAAnB;EACAD,YAAY,CAACG,QAAb,CAAsBD,KAAtB,CAA4BF,YAA5B,EAA0CR,QAA1C;EAEA,OAAOQ,YAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtB,MAAM,CAAC0B,QAAP,GAAkB,UAASb,QAAT,EAAmB;EACnC,IAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAf;EACA,IAAIC,WAAW,GAAGN,QAAQ,CAACO,KAAT,EAAlB;EAEA,IAAIC,YAAY,GAAGF,WAAW,CAACG,KAAZ,EAAnB;EACAD,YAAY,CAACI,QAAb,CAAsBF,KAAtB,CAA4BF,YAA5B,EAA0CR,QAA1C;EAEA,OAAOQ,YAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtB,MAAM,CAAC2B,MAAP,GAAgB,UAASd,QAAT,EAAmB;EACjC,IAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAf;EACA,IAAIC,WAAW,GAAGN,QAAQ,CAACO,KAAT,EAAlB;EAEA,IAAIC,YAAY,GAAGF,WAAW,CAACG,KAAZ,EAAnB;EACAD,YAAY,CAACK,MAAb,CAAoBH,KAApB,CAA0BF,YAA1B,EAAwCR,QAAxC;EAEA,OAAOQ,YAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;;;AACAtB,MAAM,CAACgB,SAAP,CAAiBL,YAAjB,GAAgC,YAAW;EACzC,KAAK,IAAIiB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKvB,MAAzB,EAAiCsB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;IAC3C,KAAKA,CAAL,IAAU,CAAV;EACD;;EAED,OAAO,IAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACA5B,MAAM,CAACgB,SAAP,CAAiBN,eAAjB,GAAmC,YAAW;EAC5C,KAAK,IAAIkB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKvB,MAAzB,EAAiCsB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;IAC3C,KAAKA,CAAL,IAAUA,CAAC,IAAI,KAAKvB,IAAL,GAAY,CAAhB,CAAD,GAAsB,CAAtB,GAA0B,CAApC;EACD;;EAED,OAAO,IAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAL,MAAM,CAACgB,SAAP,CAAiBc,OAAjB,GAA2B,UAASC,IAAT,EAAe9B,QAAf,EAAyBC,QAAzB,EAAmC;EAC5D,IAAI0B,CAAJ,EAAOC,CAAP;EACA,IAAIG,OAAO,GAAGjB,KAAK,CAACiB,OAAN,CAAcD,IAAd,CAAd;EACA,IAAI3B,IAAI,GAAGH,QAAX;EACA,IAAII,IAAI,GAAGH,QAAX;;EAEA,IAAI,CAAC8B,OAAL,EAAc;IACZD,IAAI,GAAGZ,SAAP;IACAf,IAAI,GAAGK,SAAP;IACAJ,IAAI,GAAGI,SAAP;EACD,CAV2D,CAY5D;EACA;EACA;;;EACA,IAAIsB,IAAI,CAACzB,MAAL,KAAgB,KAAKA,MAAzB,EAAiC;IAC/B,IAAIF,IAAI,KAAKK,SAAT,IAAsBJ,IAAI,KAAKI,SAAnC,EAA8C;MAC5C,OAAO,IAAP;IACD,CAFD,MAEO,IAAIL,IAAI,GAAGC,IAAP,KAAgB0B,IAAI,CAACzB,MAAzB,EAAiC;MACtC,OAAO,IAAP;IACD;EACF,CArB2D,CAuB5D;;;EACA,KAAKsB,CAAC,GAAGG,IAAI,CAACzB,MAAT,EAAiBuB,CAAC,GAAG,KAAKvB,MAA/B,EAAuCsB,CAAC,GAAGC,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;IACjD,OAAO,KAAKA,CAAL,CAAP;EACD,CA1B2D,CA4B5D;;;EACA,KAAKA,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGE,IAAI,CAACzB,MAArB,EAA6BsB,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC,EAAyC;IACvC,KAAKA,CAAL,IAAUG,IAAI,CAACH,CAAD,CAAd;EACD,CA/B2D,CAiC5D;;;EACA,KAAKtB,MAAL,GAAcyB,IAAI,CAACzB,MAAnB;EACA,KAAKF,IAAL,GAAYA,IAAI,IAAI,KAAKA,IAAzB;EACA,KAAKC,IAAL,GAAYA,IAAI,IAAI,KAAKA,IAAzB;EAEA,OAAO,IAAP;AACD,CAvCD;AAyCA;AACA;AACA;AACA;AACA;AACA;;;AACAL,MAAM,CAACgB,SAAP,CAAiBiB,OAAjB,GAA2B,YAAW;EACpC,OAAOA,OAAO,CAAC,IAAD,EAAO,IAAIlB,KAAJ,CAAU,KAAKT,MAAf,CAAP,CAAd;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAN,MAAM,CAACgB,SAAP,CAAiBkB,OAAjB,GAA2B,YAAW;EACpC,OAAOA,OAAO,CAAC,IAAD,EAAO,IAAInB,KAAJ,CAAU,KAAKT,MAAf,CAAP,CAAd;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,MAAM,CAACgB,SAAP,CAAiBmB,WAAjB,GAA+B,UAASC,eAAT,EAA0BC,aAA1B,EAAyCC,SAAzC,EAAoDC,OAApD,EAA6D;EAC1F,IAAIC,KAAK,GAAG,KAAKN,OAAL,EAAZ;EAEA,IAAIO,SAAJ;EACA,IAAIC,GAAJ;EAEA,IAAIC,SAAS,GAAG,OAAON,aAAP,KAAyB,QAAzB,GAAoCA,aAApC,GAAoD,IAApE;EACA,IAAIO,WAAW,GAAG,IAAlB;;EAEA,IAAI,OAAOR,eAAP,KAA2B,QAA/B,EAAyC;IACvCQ,WAAW,GAAI,IAAI7B,KAAJ,CAAU8B,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYV,eAAZ,IAA+B,CAAzC,CAAD,CAA8CW,IAA9C,CAAmD,GAAnD,CAAd;EACD,CAFD,MAEO,IAAI,OAAOX,eAAP,KAA2B,QAA/B,EAAyC;IAC9CQ,WAAW,GAAGR,eAAd;EACD;;EAED,IAAIY,KAAK,GAAG,OAAOV,SAAP,KAAqB,QAArB,GAAgCA,SAAhC,GAA4C,GAAxD;EACA,IAAIW,GAAG,GAAG,OAAOV,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,GAAlD;EAEA,IAAIW,MAAM,GAAGF,KAAb;;EACA,KAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGW,KAAK,CAAClC,MAA1B,EAAkCsB,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C,EAA8C;IAC5Ca,SAAS,GAAGb,CAAC,GAAG,KAAKvB,IAAT,KAAkB,CAAlB,GAAsB,OAAOuC,WAA7B,GAA2C,EAAvD;IACAF,GAAG,GAAGd,CAAC,GAAG,KAAKvB,IAAT,KAAkB,KAAKA,IAAL,GAAY,CAA9B,GAAkC,EAAlC,GAAuCsC,SAA7C;IACAO,MAAM,IAAIT,SAAS,GAAGD,KAAK,CAACZ,CAAD,CAAjB,GAAuBc,GAAjC;EACD;;EACDQ,MAAM,IAAI,OAAOD,GAAjB;EAEA,OAAOC,MAAP;AACD,CA3BD;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlD,MAAM,CAACgB,SAAP,CAAiBmC,IAAjB,GAAwB,UAASC,MAAT,EAAiB;EACvC,IAAIxB,CAAJ,EAAOC,CAAP,CADuC,CAGvC;;EACA,IAAIuB,MAAM,CAAC9C,MAAP,GAAgB,KAAKA,MAAzB,EAAiC;IAC/B,KAAKsB,CAAC,GAAGwB,MAAM,CAAC9C,MAAX,EAAmBuB,CAAC,GAAG,KAAKvB,MAAjC,EAAyCsB,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;MACnD,OAAO,KAAKA,CAAL,CAAP;IACD;EACF,CARsC,CAUvC;;;EACA,IAAIwB,MAAM,CAAC9C,MAAP,KAAkB,KAAKA,MAA3B,EAAmC;IACjC,KAAKA,MAAL,GAAc8C,MAAM,CAAC9C,MAArB;IACA,KAAKF,IAAL,GAAYgD,MAAM,CAAChD,IAAnB;IACA,KAAKC,IAAL,GAAY+C,MAAM,CAAC/C,IAAnB;EACD,CAfsC,CAiBvC;;;EACA,KAAKuB,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAG,KAAKvB,MAArB,EAA6BsB,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC,EAAyC;IACvC,KAAKA,CAAL,IAAUwB,MAAM,CAACxB,CAAD,CAAhB;EACD;;EAED,OAAO,IAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;;;AACA5B,MAAM,CAACgB,SAAP,CAAiBO,KAAjB,GAAyB,YAAW;EAClC,OAAO,IAAIvB,MAAJ,CAAW,KAAKI,IAAhB,EAAsB,KAAKC,IAA3B,EAAiC,KAAjC,EAAwC8C,IAAxC,CAA6C,IAA7C,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnD,MAAM,CAACgB,SAAP,CAAiBJ,GAAjB,GAAuB,UAASC,QAAT,EAAmB;EACxC,IAAIC,QAAQ,GAAGK,SAAf;EAEA,IAAIkC,SAAS,GAAG,KAAK/C,MAArB,CAHwC,CAKxC;;EACA,KAAK,IAAIsB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,QAAQ,CAACR,MAA7B,EAAqCsB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;IAC/C,IAAIwB,MAAM,GAAGtC,QAAQ,CAACc,CAAD,CAArB,CAD+C,CAG/C;;IACA,IAAIwB,MAAM,CAAC/C,IAAP,KAAgB,KAAKA,IAArB,IAA6B+C,MAAM,CAAChD,IAAP,KAAgB,KAAKA,IAAtD,EAA4D;MAC1D;IACD,CAN8C,CAQ/C;;;IACA,KAAK,IAAIkD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAApB,EAA+BC,CAAC,EAAhC,EAAoC;MAElC;MACA,KAAKA,CAAL,KAAWF,MAAM,CAACE,CAAD,CAAjB;IACD;EACF;;EAED,OAAO,IAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtD,MAAM,CAACgB,SAAP,CAAiBS,QAAjB,GAA4B,UAASZ,QAAT,EAAmB;EAC7C,IAAIC,QAAQ,GAAGK,SAAf;EAEA,IAAIkC,SAAS,GAAG,KAAK/C,MAArB,CAH6C,CAK7C;;EACA,KAAK,IAAIsB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,QAAQ,CAACR,MAA7B,EAAqCsB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;IAC/C,IAAIwB,MAAM,GAAGtC,QAAQ,CAACc,CAAD,CAArB,CAD+C,CAG/C;;IACA,IAAIwB,MAAM,CAAC/C,IAAP,KAAgB,KAAKA,IAArB,IAA6B+C,MAAM,CAAChD,IAAP,KAAgB,KAAKA,IAAtD,EAA4D;MAC1D;IACD,CAN8C,CAQ/C;;;IACA,KAAK,IAAIkD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAApB,EAA+BC,CAAC,EAAhC,EAAoC;MAElC;MACA,KAAKA,CAAL,KAAWF,MAAM,CAACE,CAAD,CAAjB;IACD;EACF;;EAED,OAAO,IAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtD,MAAM,CAACgB,SAAP,CAAiBU,QAAjB,GAA4B,UAASb,QAAT,EAAmB;EAC7C,IAAIC,QAAQ,GAAGK,SAAf;EACA,IAAIoC,UAAU,GAAG,CAAjB,CAF6C,CAI7C;EACA;EACA;EACA;;EACA,IAAI,KAAKC,UAAL,EAAJ,EAAuB;IACrB,IAAIC,IAAJ;;IACA,OAAO,CAACA,IAAI,GAAG3C,QAAQ,CAACyC,UAAD,CAAhB,MAAkC9C,SAAzC,EAAoD;MAElD;MACA;MACA;MACA,IAAI,OAAOgD,IAAP,KAAgB,QAApB,EAA8B;QAC5B,IAAIA,IAAI,KAAK,CAAb,EAAgB;UACdF,UAAU;UACV;QACD,CAHD,MAGO;UACL;QACD;MACF,CAZiD,CAclD;MACA;MACA;MACA;;;MACAA,UAAU;MACV,IAAI,CAACE,IAAI,CAACD,UAAL,EAAL,EAAwB;IACzB,CAtBoB,CAwBrB;IACA;IACA;;;IACA,IAAI,CAACC,IAAL,EAAW,OAAO,IAAP,CA3BU,CA6BrB;IACA;;IACA,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;MAC5B,KAAKN,IAAL,CAAUM,IAAV;IACD;EACF;;EAED,IAAIC,OAAO,GAAGzB,OAAO,CAAC,IAAD,EAAOnC,MAAM,CAAC6D,aAAP,CAAqB,KAAKrD,MAA1B,CAAP,CAArB,CA5C6C,CA8C7C;;EACA,KAAK,IAAIsB,CAAC,GAAG2B,UAAR,EAAoB1B,CAAC,GAAGf,QAAQ,CAACR,MAAtC,EAA8CsB,CAAC,GAAGC,CAAlD,EAAqDD,CAAC,EAAtD,EAA0D;IACxD,IAAIwB,MAAM,GAAGtC,QAAQ,CAACc,CAAD,CAArB,CADwD,CAGxD;;IACA,IAAIgC,YAAY,GAAGF,OAAO,CAACtD,IAA3B;IACA,IAAIyD,YAAY,GAAGH,OAAO,CAACrD,IAA3B;IACA,IAAIyD,iBAAiB,GAAGJ,OAAO,CAACpD,MAAhC,CANwD,CAQxD;;IACA,IAAI,OAAO8C,MAAP,KAAkB,QAAtB,EAAgC;MAC9B,IAAIW,KAAK,GAAGX,MAAZ;MACA,IAAIY,MAAM,GAAG,IAAID,KAAjB,CAF8B,CAEN;MAExB;;MACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,iBAApB,EAAuCR,CAAC,EAAxC,EAA4C;QAE1C;QACAI,OAAO,CAACJ,CAAD,CAAP,GAAaI,OAAO,CAACJ,CAAD,CAAP,IAAcS,KAAK,GAAGC,MAAtB,IAAgCA,MAA7C;MACD,CAT6B,CAW9B;;;MACA;IACD,CAtBuD,CAwBxD;;;IACA,IAAIZ,MAAM,CAACI,UAAP,EAAJ,EAAyB,SAzB+B,CA2BxD;;IACA,IAAIS,aAAa,GAAGb,MAAM,CAAChD,IAA3B;IACA,IAAI8D,aAAa,GAAGd,MAAM,CAAC/C,IAA3B,CA7BwD,CA+BxD;;IACA,IAAIwD,YAAY,KAAKI,aAArB,EAAoC;MAClC;IACD,CAlCuD,CAoCxD;IACA;;;IACA,IAAIE,QAAQ,GAAGrE,MAAM,CAAC6D,aAAP,CAAqBD,OAAO,CAACtD,IAAR,GAAegD,MAAM,CAAC/C,IAA3C,CAAf;IACA8D,QAAQ,CAAC/D,IAAT,GAAgBsD,OAAO,CAACtD,IAAxB;IACA+D,QAAQ,CAAC9D,IAAT,GAAgB+C,MAAM,CAAC/C,IAAvB,CAxCwD,CA0CxD;;IACA,KAAK,IAAI+D,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGR,YAAxB,EAAsCQ,GAAG,EAAzC,EAA6C;MAE3C;MACA,KAAK,IAAIC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGH,aAAtC,EAAqDG,UAAU,EAA/D,EAAmE;QAEjE;QACA,KAAK,IAAIC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGL,aAAtC,EAAqDK,UAAU,EAA/D,EAAmE;UACjE,IAAIC,WAAW,GAAGH,GAAG,GAAGD,QAAQ,CAAC9D,IAAf,GAAsBgE,UAAxC,CADiE,CAGjE;;UACA,IAAI,CAACF,QAAQ,CAACI,WAAD,CAAb,EAA4BJ,QAAQ,CAACI,WAAD,CAAR,GAAwB,CAAxB,CAJqC,CAMjE;UACA;UACA;;UACAJ,QAAQ,CAACI,WAAD,CAAR,IAAyBb,OAAO,CAACU,GAAG,GAAGV,OAAO,CAACrD,IAAd,GAAqBiE,UAAtB,CAAP,GAA2ClB,MAAM,CAACkB,UAAU,GAAGlB,MAAM,CAAC/C,IAApB,GAA2BgE,UAA5B,CAA1E;QACD;MACF;IACF;;IACDvE,MAAM,CAAC0E,QAAP,CAAgBd,OAAhB,EA9DwD,CAgExD;IACA;;IACAA,OAAO,GAAGS,QAAV;EACD,CAlH4C,CAoH7C;;;EACA,KAAKrC,OAAL,CAAa4B,OAAb,EAAsBA,OAAO,CAACtD,IAA9B,EAAoCsD,OAAO,CAACrD,IAA5C;EAEAP,MAAM,CAAC0E,QAAP,CAAgBd,OAAhB;EAEA,OAAO,IAAP;AACD,CA1HD;AA4HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1D,MAAM,CAACgB,SAAP,CAAiBW,MAAjB,GAA0B,UAASd,QAAT,EAAmB;EAC3C,IAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAf,CAD2C,CAG3C;;EACA,KAAK,IAAIS,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,QAAQ,CAACR,MAA7B,EAAqCsB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;IAC/C,IAAIwB,MAAM,GAAGtC,QAAQ,CAACc,CAAD,CAArB,CAD+C,CAG/C;IACA;;IACA,IAAIwB,MAAM,CAAChD,IAAP,KAAgBgD,MAAM,CAAC/C,IAA3B,EAAiC;MAC/BS,QAAQ,CAAC2D,MAAT,CAAgB7C,CAAhB,EAAmB,CAAnB;MACAA,CAAC;MAAIC,CAAC;MACN;IACD,CAT8C,CAW/C;IACA;;;IACAf,QAAQ,CAACc,CAAD,CAAR,GAAcwB,MAAM,CAAC7B,KAAP,GAAemD,MAAf,EAAd;EACD,CAlB0C,CAoB3C;;;EACA,KAAKhD,QAAL,CAAcF,KAAd,CAAoB,IAApB,EAA0BV,QAA1B;EAEA,OAAO,IAAP;AACD,CAxBD;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAd,MAAM,CAACgB,SAAP,CAAiB2D,KAAjB,GAAyB,UAASA,KAAT,EAAgB;EAEvC;EACA,IAAI,KAAKvE,IAAL,KAAc,KAAKC,IAAvB,EAA6B;IAC3B,OAAO,IAAP;EACD;;EAED,IAAIS,QAAQ,GAAG,IAAIC,KAAJ,CAAU4D,KAAK,GAAG,CAAlB,CAAf;;EACA,KAAK,IAAI/C,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGf,QAAQ,CAACR,MAA7B,EAAqCsB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;IAC/Cd,QAAQ,CAACc,CAAD,CAAR,GAAc,KAAKL,KAAL,EAAd;EACD;;EAED,KAAKG,QAAL,CAAcF,KAAd,CAAoB,IAApB,EAA0BV,QAA1B;EAEA,OAAO,IAAP;AACD,CAfD;AAiBA;AACA;AACA;AACA;AACA;;;AACAd,MAAM,CAACgB,SAAP,CAAiB4D,SAAjB,GAA6B,YAAW;EACtC,IAAIC,OAAO,GAAG,KAAKzE,IAAnB;EACA,IAAI0E,OAAO,GAAG,KAAKzE,IAAnB;EAEA,IAAI0E,OAAO,GAAGjF,MAAM,CAAC6D,aAAP,CAAqB,KAAKrD,MAA1B,CAAd;;EAEA,KAAK,IAAI8D,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGS,OAAxB,EAAiCT,GAAG,EAApC,EAAwC;IACtC,KAAK,IAAIY,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,OAAxB,EAAiCE,GAAG,EAApC,EAAwC;MACtCD,OAAO,CAACC,GAAG,GAAGH,OAAN,GAAgBT,GAAjB,CAAP,GAA+B,KAAKA,GAAG,GAAGU,OAAN,GAAgBE,GAArB,CAA/B;IACD;EACF;;EACD,KAAKlD,OAAL,CAAaiD,OAAb,EAAsBD,OAAtB,EAA+BD,OAA/B;EAEA/E,MAAM,CAAC0E,QAAP,CAAgBO,OAAhB;EAEA,OAAO,IAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA/E,MAAM,CAACgB,SAAP,CAAiB0D,MAAjB,GAA0B,YAAW;EACnC,IAAIG,OAAO,GAAG,KAAKzE,IAAnB;EACA,IAAI0E,OAAO,GAAG,KAAKzE,IAAnB,CAFmC,CAInC;;EACA,IAAIwE,OAAO,KAAKC,OAAhB,EAAyB,OAAO,IAAP,CALU,CAOnC;;EACA,IAAID,OAAO,KAAK,CAAhB,EAAmB;IACjB,IAAII,WAAW,GAAG,KAAKC,cAAL,EAAlB;IACA,IAAID,WAAW,KAAK,CAApB,EAAuB,OAAO,IAAP;IAEvB,IAAIE,mBAAmB,GAAG,IAAIF,WAA9B;IACA,IAAIG,EAAE,GAAGD,mBAAmB,GAAG,KAAK,CAAL,CAA/B;IACA,IAAIE,EAAE,GAAGF,mBAAmB,GAAG,CAAC,KAAK,CAAL,CAAhC;IACA,IAAIG,EAAE,GAAGH,mBAAmB,GAAG,CAAC,KAAK,CAAL,CAAhC;IACA,IAAII,EAAE,GAAGJ,mBAAmB,GAAG,KAAK,CAAL,CAA/B;IACA,KAAK,CAAL,IAAUC,EAAV;IACA,KAAK,CAAL,IAAUC,EAAV;IACA,KAAK,CAAL,IAAUC,EAAV;IACA,KAAK,CAAL,IAAUC,EAAV;IAEA,OAAO,IAAP;EACD,CAvBkC,CAyBnC;;;EACA,IAAIC,KAAK,GAAG,KAAKjF,MAAL,KAAgB,KAAKA,MAAL,GAAc,EAA9B,CAAZ;EACA,IAAIkF,iBAAiB,GAAGD,KAAK,CAACC,iBAAN,KAA4BD,KAAK,CAACC,iBAAN,GAA0B,IAAIzF,MAAJ,CAAW6E,OAAX,EAAoBC,OAApB,EAA6B,KAA7B,CAAtD,CAAxB;EACA,IAAI1B,MAAM,GAAGoC,KAAK,CAACE,UAAN,KAAqBF,KAAK,CAACE,UAAN,GAAmB,IAAI1F,MAAJ,CAAW,KAAKI,IAAhB,EAAsB,KAAKC,IAA3B,EAAiC,KAAjC,CAAxC,CAAb,CA5BmC,CA8BnC;;EACA,IAAIuB,CAAC,GAAG,CAAR;;EACA,KAAK,IAAIwC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGS,OAAxB,EAAiCT,GAAG,EAApC,EAAwC;IACtC,KAAK,IAAIY,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,OAAxB,EAAiCE,GAAG,EAApC,EAAwC;MAEtC;MACA,IAAID,OAAO,GAAGjF,MAAM,CAAC6D,aAAP,CAAqB,KAAKrD,MAA1B,CAAd;;MACA,KAAK,IAAIqF,CAAC,GAAG,KAAKrF,MAAlB,EAA0BqF,CAAC,EAA3B,GAAgC;QAC9BZ,OAAO,CAACY,CAAD,CAAP,GAAa,KAAKA,CAAL,CAAb;MACD,CANqC,CAQtC;MACA;MACA;;;MACAC,SAAS,CAACb,OAAD,EAAUX,GAAV,EAAe,KAAK/D,IAApB,CAAT;MACAwF,YAAY,CAACd,OAAD,EAAUC,GAAV,EAAe,KAAK3E,IAApB,CAAZ;MACA+C,MAAM,CAACtB,OAAP,CAAeiD,OAAf,EAAwB,KAAK3E,IAAL,GAAY,CAApC,EAAuC,KAAKC,IAAL,GAAY,CAAnD,EAbsC,CAetC;;MACAP,MAAM,CAAC0E,QAAP,CAAgBO,OAAhB,EAhBsC,CAkBtC;MACA;;MACA,IAAIe,QAAQ,GAAG1C,MAAM,CAAC8B,cAAP,EAAf;MACA,IAAIa,YAAY,GAAG3B,GAAG,GAAG,CAAN,KAAY,CAA/B;MACA,IAAI4B,YAAY,GAAGhB,GAAG,GAAG,CAAN,KAAY,CAA/B;;MACA,IAAKe,YAAY,IAAI,CAACC,YAAlB,IAAoCA,YAAY,IAAI,CAACD,YAAzD,EAAwE;QACtED,QAAQ,IAAI,CAAC,CAAb;MACD,CAzBqC,CA2BtC;;;MACAL,iBAAiB,CAACrB,GAAG,GAAGqB,iBAAiB,CAACpF,IAAxB,GAA+B2E,GAAhC,CAAjB,GAAwDc,QAAxD;MAEAlE,CAAC;IACF;EACF,CAjEkC,CAmEnC;EACA;;;EACA,IAAIqE,mBAAmB,GAAG,CAA1B;;EACA,KAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,OAApB,EAA6BxB,CAAC,EAA9B,EAAkC;IAChC2C,mBAAmB,IAAI,KAAK3C,CAAL,IAAUmC,iBAAiB,CAACnC,CAAD,CAAlD;EACD,CAxEkC,CA0EnC;;;EACA,IAAI2C,mBAAmB,KAAK,CAA5B,EAA+B,OAAO,IAAP,CA3EI,CA6EnC;;EACAR,iBAAiB,CAACb,SAAlB,GA9EmC,CAgFnC;EACA;;EACA,IAAIsB,OAAO,GAAGT,iBAAiB,CAAC/D,QAAlB,CAA2B,IAAIuE,mBAA/B,CAAd,CAlFmC,CAoFnC;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,OAAO,CAAC5F,MAA5B,EAAoC6F,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAgD;IAC9C,KAAKA,CAAL,IAAUD,OAAO,CAACC,CAAD,CAAjB;EACD;;EAED,OAAO,IAAP;AACD,CA1FD;AA4FA;AACA;AACA;AACA;AACA;AACA;;;AACAnG,MAAM,CAACgB,SAAP,CAAiBkE,cAAjB,GAAkC,YAAW;EAC3C,IAAI9E,IAAI,GAAG,KAAKA,IAAhB;EACA,IAAIC,IAAI,GAAG,KAAKA,IAAhB,CAF2C,CAI3C;;EACA,IAAID,IAAI,KAAKC,IAAb,EAAmB,OAAO,IAAP,CALwB,CAO3C;;EACA,IAAID,IAAI,KAAK,CAAb,EAAgB;IACd,OAAO,KAAK,CAAL,CAAP;EACD,CAV0C,CAY3C;;;EACA,IAAIA,IAAI,KAAK,CAAb,EAAgB;IACd,OAAO,KAAK,CAAL,IAAU,KAAK,CAAL,CAAV,GAAoB,KAAK,CAAL,IAAU,KAAK,CAAL,CAArC;EACD,CAf0C,CAiB3C;EACA;;;EACA,IAAIA,IAAI,KAAK,CAAb,EAAgB;IACd,IAAIiG,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIC,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIC,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIZ,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIa,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIC,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIC,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAIC,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,IAAI/E,CAAC,GAAG,KAAK,CAAL,CAAR;IACA,OAAOyE,CAAC,IAAIG,CAAC,GAAG5E,CAAJ,GAAQ6E,CAAC,GAAGE,CAAhB,CAAD,GAAsBL,CAAC,IAAIX,CAAC,GAAG/D,CAAJ,GAAQ6E,CAAC,GAAGC,CAAhB,CAAvB,GAA4CH,CAAC,IAAIZ,CAAC,GAAGgB,CAAJ,GAAQH,CAAC,GAAGE,CAAhB,CAApD;EACD,CA9B0C,CAgC3C;;;EACA,IAAItG,IAAI,IAAI,CAAZ,EAAe;IAEb,IAAIwG,MAAM,GAAG,CAAb,CAFa,CAIb;;IACA,IAAIpB,KAAK,GAAG,KAAKjF,MAAL,KAAgB,KAAKA,MAAL,GAAc,EAA9B,CAAZ;IACA,IAAI6C,MAAM,GAAGoC,KAAK,CAACE,UAAN,KAAqBF,KAAK,CAACE,UAAN,GAAmB,IAAI1F,MAAJ,CAAW,KAAKI,IAAhB,EAAsB,KAAKC,IAA3B,EAAiC,KAAjC,CAAxC,CAAb,CANa,CAQb;;IACA,KAAK,IAAI2E,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG3E,IAAxB,EAA8B2E,GAAG,EAAjC,EAAqC;MAEnC;MACA,IAAID,OAAO,GAAGjF,MAAM,CAAC6D,aAAP,CAAqB,KAAKrD,MAA1B,CAAd;;MACA,KAAK,IAAIqF,CAAC,GAAG,KAAKrF,MAAlB,EAA0BqF,CAAC,EAA3B,GAAgC;QAC9BZ,OAAO,CAACY,CAAD,CAAP,GAAa,KAAKA,CAAL,CAAb;MACD,CANkC,CAQnC;MACA;MACA;;;MACAC,SAAS,CAACb,OAAD,EAAU,CAAV,EAAa,KAAK1E,IAAlB,CAAT;MACAwF,YAAY,CAACd,OAAD,EAAUC,GAAV,EAAe,KAAK3E,IAApB,CAAZ;MACA+C,MAAM,CAACtB,OAAP,CAAeiD,OAAf,EAAwB,KAAK3E,IAAL,GAAY,CAApC,EAAuC,KAAKC,IAAL,GAAY,CAAnD,EAbmC,CAenC;;MACAP,MAAM,CAAC0E,QAAP,CAAgBO,OAAhB;MAEA6B,MAAM,IAAI,CAAC5B,GAAG,GAAG,CAAN,GAAU,CAAC,CAAX,GAAe,CAAhB,IAAqB,KAAKA,GAAL,CAArB,GAAiC5B,MAAM,CAAC8B,cAAP,EAA3C;IACD;;IAED,OAAO0B,MAAP;EACD;AACF,CAjED;AAmEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA5G,MAAM,CAACgB,SAAP,CAAiB6F,MAAjB,GAA0B,UAASC,KAAT,EAAgB;EACxC,IAAI,EAAEA,KAAK,YAAY9G,MAAnB,CAAJ,EAAgC,OAAO,KAAP,CADQ,CAGxC;;EACA,IAAI,KAAKI,IAAL,KAAc0G,KAAK,CAAC1G,IAApB,IAA4B,KAAKC,IAAL,KAAcyG,KAAK,CAACzG,IAApD,EAA0D;IACxD,OAAO,KAAP;EACD,CANuC,CAQxC;;;EACA,KAAK,IAAIuB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKvB,MAAzB,EAAiCsB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;IAC3C,IAAI,KAAKA,CAAL,MAAYkF,KAAK,CAAClF,CAAD,CAArB,EAA0B,OAAO,KAAP;EAC3B,CAXuC,CAaxC;;;EACA,OAAO,IAAP;AACD,CAfD;AAiBA;AACA;AACA;AACA;AACA;;;AACA5B,MAAM,CAACgB,SAAP,CAAiBwC,UAAjB,GAA8B,YAAW;EACvC,KAAK,IAAI5B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKvB,MAAzB,EAAiCsB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;IAC3C,IAAI,KAAKA,CAAL,OAAaA,CAAC,IAAI,KAAKvB,IAAL,GAAY,CAAhB,CAAD,GAAsB,CAAtB,GAA0B,CAAvC,CAAJ,EAA+C;MAC7C,OAAO,KAAP;IACD;EACF;;EAED,OAAO,IAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASuF,SAAT,CAAmBmB,MAAnB,EAA2B3C,GAA3B,EAAgC4C,UAAhC,EAA4C;EAC1CD,MAAM,CAACtC,MAAP,CAAcL,GAAG,GAAG4C,UAApB,EAAgCA,UAAhC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASnB,YAAT,CAAsBkB,MAAtB,EAA8B/B,GAA9B,EAAmCgC,UAAnC,EAA+C;EAC7C,IAAI1D,CAAC,GAAG,CAAR;;EACA,KAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGkF,MAAM,CAACzG,MAA3B,EAAmCsB,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;IAC7C,IAAIA,CAAC,GAAGoF,UAAJ,KAAmBhC,GAAvB,EAA4B+B,MAAM,CAACzD,CAAC,EAAF,CAAN,GAAcyD,MAAM,CAACnF,CAAD,CAApB;EAC7B;;EACDmF,MAAM,CAACzG,MAAP,GAAgBgD,CAAhB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpB,OAAT,CAAiBkB,MAAjB,EAAyBZ,KAAzB,EAAgC;EAC9B,KAAK,IAAIZ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGuB,MAAM,CAAC9C,MAA3B,EAAmCsB,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;IAC7CY,KAAK,CAACZ,CAAD,CAAL,GAAWwB,MAAM,CAACxB,CAAD,CAAjB;EACD;;EAED,OAAOY,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASP,OAAT,CAAiBmB,MAAjB,EAAyBZ,KAAzB,EAAgC;EAC9BN,OAAO,CAACkB,MAAD,EAASZ,KAAT,CAAP;EAEAA,KAAK,CAACpC,IAAN,GAAagD,MAAM,CAAChD,IAApB;EACAoC,KAAK,CAACnC,IAAN,GAAa+C,MAAM,CAAC/C,IAApB;EAEA,OAAOmC,KAAP;AACD;;AAEDyE,MAAM,CAACC,OAAP,GAAiBlH,MAAjB"},"metadata":{},"sourceType":"script"}