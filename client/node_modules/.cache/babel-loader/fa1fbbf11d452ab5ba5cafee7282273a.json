{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DateAxis } from \"./DateAxis\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\n\nvar GaplessDateAxis =\n/** @class */\nfunction (_super) {\n  __extends(GaplessDateAxis, _super);\n\n  function GaplessDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_dates\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    return _this;\n  }\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.valueFields.push(\"date\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_updateDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date) {\n      var dates = this._dates;\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, date);\n      });\n\n      if (!result.found) {\n        $array.insertIndex(dates, result.index, date);\n      }\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_updateAllDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._dates.length = 0;\n      $array.each(this.series, function (series) {\n        var field = \"valueX\";\n\n        if (series.get(\"yAxis\") == _this) {\n          field = \"valueY\";\n        }\n\n        $array.each(series.dataItems, function (dataItem) {\n          var value = dataItem.get(field);\n\n          if ($type.isNumber(value)) {\n            if (dataItem.open) {\n              _this._updateDates(dataItem.open[field]);\n            }\n          }\n        });\n      });\n    }\n  });\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"valueToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var dates = this._dates;\n      var len = dates.length;\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, value);\n      });\n      var index = result.index;\n\n      if (result.found) {\n        return index / len;\n      } else {\n        if (index > 0) {\n          index -= 1;\n        }\n\n        var itemValue = dates[index];\n        var d = 0;\n\n        if (itemValue > value) {\n          d = itemValue - value;\n        } else {\n          d = value - itemValue;\n        }\n\n        return index / len + d / this.baseDuration() / len;\n      }\n    }\n  });\n  /**\r\n   * Converts numeric value from axis scale to index.\r\n   *\r\n   * @param  value  Value\r\n   * @return        Index\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"valueToIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var dates = this._dates;\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, value);\n      });\n      var index = result.index;\n\n      if (result.found) {\n        return index;\n      } else {\n        if (index > 0) {\n          index -= 1;\n        }\n\n        return index;\n      }\n    }\n  });\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"positionToValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var len = this._dates.length;\n      var index = position * len;\n      var findex = Math.floor(index);\n\n      if (findex < 0) {\n        findex = 0;\n      }\n\n      if (findex > len - 1) {\n        findex = len - 1;\n      }\n\n      return this._dates[findex] + (index - findex) * this.baseDuration();\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_fixZoomFactor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivateRaw(\"maxZoomFactor\", this._dates.length);\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var startTime = this.getPrivate(\"selectionMin\", 0);\n      var endTime = this.getPrivate(\"selectionMax\", 0);\n\n      if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n        if (this._seriesValuesDirty) {\n          this._seriesValuesDirty = false;\n\n          this._updateAllDates();\n        }\n\n        var dates_1 = this._dates;\n        var renderer = this.get(\"renderer\");\n        var len = dates_1.length;\n        var startIndex_1 = this.valueToIndex(startTime);\n\n        if (startIndex_1 > 0) {\n          startIndex_1--;\n        }\n\n        var endIndex_1 = this.valueToIndex(endTime);\n\n        if (endIndex_1 < len - 1) {\n          endIndex_1++;\n        }\n\n        var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n        var frequency = Math.min(len, Math.ceil((endIndex_1 - startIndex_1) / maxCount));\n        startIndex_1 = Math.floor(startIndex_1 / frequency) * frequency;\n        this._frequency = frequency;\n\n        for (var j = 0, length_1 = this.dataItems.length; j < length_1; j++) {\n          this.dataItems[j].hide();\n        }\n\n        var realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex_1 - startIndex_1)) * this.baseDuration(); // if all items are on axis\n\n        var gridInterval_1 = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var intervalDuration_1 = $time.getIntervalDuration(gridInterval_1);\n\n        if (intervalDuration_1 < this.baseDuration()) {\n          gridInterval_1 = __assign({}, baseInterval);\n          intervalDuration_1 = $time.getIntervalDuration(gridInterval_1);\n        }\n\n        this._intervalDuration = intervalDuration_1;\n        var formats_1 = this.get(\"dateFormats\");\n        var selectedItems_1 = [];\n        var firstDate = new Date();\n\n        if (this._dates[0]) {\n          firstDate = new Date(this._dates[0]);\n        }\n\n        var startDate = $time.round(new Date(this.getPrivate(\"min\", 0)), gridInterval_1.timeUnit, gridInterval_1.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone);\n        var value = $time.add(startDate, gridInterval_1.timeUnit, -1, this._root.utc).getTime();\n        var selectionMax = this.getPrivate(\"selectionMax\");\n        var previousPosition = -Infinity;\n        var minDifference = (this.get(\"end\", 1) - this.get(\"start\", 0)) / maxCount;\n\n        while (value <= selectionMax) {\n          var index = this.valueToIndex(value);\n          var realValue = this._dates[index];\n\n          if (realValue < value) {\n            for (var i = index, len_1 = this._dates.length; i < len_1; i++) {\n              var realValue_1 = this._dates[i];\n\n              if (realValue_1 >= value) {\n                index = i;\n                break;\n              }\n            }\n          }\n\n          var position = this.valueToPosition(realValue);\n\n          if (position - previousPosition >= minDifference * 0.95) {\n            $array.move(selectedItems_1, index);\n            previousPosition = position;\n          }\n\n          value = $time.add(new Date(value), gridInterval_1.timeUnit, gridInterval_1.count, this._root.utc).getTime();\n        }\n\n        if (selectedItems_1.length > 0) {\n          var i_1 = 0;\n          var previousValue_1 = -Infinity;\n          var nextGridUnit_1 = $time.getNextUnit(gridInterval_1.timeUnit);\n          $array.each(selectedItems_1, function (index) {\n            var dataItem;\n\n            if (_this.dataItems.length < i_1 + 1) {\n              dataItem = new DataItem(_this, undefined, {});\n\n              _this._dataItems.push(dataItem);\n\n              _this.processDataItem(dataItem);\n            } else {\n              dataItem = _this.dataItems[i_1];\n            }\n\n            var value = dates_1[index];\n            var date = new Date(value);\n            var endValue = value;\n\n            if (i_1 < selectedItems_1.length - 1) {\n              endValue = dates_1[selectedItems_1[i_1 + 1]];\n            } else {\n              endValue += intervalDuration_1;\n            }\n\n            dataItem.setRaw(\"value\", value);\n            dataItem.setRaw(\"endValue\", endValue);\n            dataItem.setRaw(\"index\", i_1);\n\n            if (index > startIndex_1 - 100 && index < endIndex_1 + 100) {\n              var format = formats_1[gridInterval_1.timeUnit];\n              format = formats_1[gridInterval_1.timeUnit];\n\n              if (nextGridUnit_1 && _this.get(\"markUnitChange\") && $type.isNumber(previousValue_1)) {\n                if (gridInterval_1.timeUnit != \"year\") {\n                  if ($time.checkChange(value, previousValue_1, nextGridUnit_1, _this._root.utc, _this._root.timezone)) {\n                    format = _this.get(\"periodChangeDateFormats\")[gridInterval_1.timeUnit];\n                  }\n                }\n              }\n\n              _this._createAssets(dataItem, []);\n\n              var label = dataItem.get(\"label\");\n\n              if (label) {\n                label.set(\"text\", _this._root.dateFormatter.format(date, format));\n              }\n\n              if (dataItem.isHidden()) {\n                dataItem.show();\n              }\n\n              _this._prepareDataItem(dataItem, gridInterval_1.count);\n            }\n\n            i_1++;\n            previousValue_1 = value;\n          });\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(GaplessDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"GaplessDateAxis\"\n  });\n  Object.defineProperty(GaplessDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: DateAxis.classNames.concat([GaplessDateAxis.className])\n  });\n  return GaplessDateAxis;\n}(DateAxis);\n\nexport { GaplessDateAxis };","map":{"version":3,"mappings":"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","names":["DateAxis","DataItem","$array","$order","$time","$type","__extends","Object","valueFields","push","_super","_afterNew","call","date","dates","_dates","result","getSortedIndex","x","compare","found","insertIndex","index","length","each","series","field","get","_this","dataItems","dataItem","value","isNumber","open","_updateDates","len","itemValue","d","baseDuration","position","findex","Math","floor","setPrivateRaw","startTime","getPrivate","endTime","_seriesValuesDirty","_updateAllDates","dates_1","renderer","startIndex_1","valueToIndex","endIndex_1","maxCount","axisLength","max","Number","MAX_SAFE_INTEGER","frequency","min","ceil","_frequency","j","length_1","hide","realDuration","gridInterval_1","chooseInterval","baseInterval","intervalDuration_1","getIntervalDuration","_intervalDuration","formats_1","selectedItems_1","firstDate","Date","startDate","round","timeUnit","count","_root","locale","firstDayOfWeek","utc","timezone","add","getTime","selectionMax","previousPosition","Infinity","minDifference","realValue","i","len_1","realValue_1","valueToPosition","move","i_1","previousValue_1","nextGridUnit_1","getNextUnit","undefined","_dataItems","processDataItem","endValue","setRaw","format","checkChange","_createAssets","label","set","dateFormatter","isHidden","show","_prepareDataItem","inited","_markDirtyAxes","_updateGhost","classNames","concat","GaplessDateAxis","className"],"sourceRoot":"","sources":["../../../../../../src/.internal/charts/xy/axes/GaplessDateAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\r\n\r\nimport { DateAxis, IDateAxisSettings, IDateAxisPrivate, IDateAxisDataItem, IDateAxisEvents } from \"./DateAxis\";\r\nimport { DataItem } from \"../../../core/render/Component\";\r\n\r\nimport * as $array from \"../../../core/util/Array\"\r\nimport * as $order from \"../../../core/util/Order\";\r\nimport * as $time from \"../../../core/util/Time\";\r\nimport * as $type from \"../../../core/util/Type\";\r\n\r\nexport interface IGaplessDateAxisSettings<R extends AxisRenderer> extends IDateAxisSettings<R> {\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisDataItem extends IDateAxisDataItem {\r\n\r\n\t/**\r\n\t * An index of a data item.\r\n\t */\r\n\tindex?: number\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisPrivate extends IDateAxisPrivate {\r\n\r\n}\r\n\r\nexport interface IGaplessDateAxisEvents extends IDateAxisEvents {\r\n}\r\n\r\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\r\nexport class GaplessDateAxis<R extends AxisRenderer> extends DateAxis<R> {\r\n\tpublic static className: string = \"GaplessDateAxis\";\r\n\tpublic static classNames: Array<string> = DateAxis.classNames.concat([GaplessDateAxis.className]);\r\n\r\n\tdeclare public _settings: IGaplessDateAxisSettings<R>;\r\n\tdeclare public _privateSettings: IGaplessDateAxisPrivate;\r\n\tdeclare public _dataItemSettings: IGaplessDateAxisDataItem;\r\n\tdeclare public _events: IGaplessDateAxisEvents;\r\n\r\n\tprotected _frequency: number = 1;\r\n\r\n\tpublic _afterNew() {\r\n\t\tthis.valueFields.push(\"date\");\r\n\t\tsuper._afterNew();\r\n\t}\r\n\r\n\tprotected _dates: Array<number> = [];\r\n\r\n\tprotected _updateDates(date: number) {\r\n\t\tconst dates = this._dates;\r\n\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, date));\r\n\t\tif (!result.found) {\r\n\t\t\t$array.insertIndex(dates, result.index, date);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _updateAllDates() {\r\n\t\tthis._dates.length = 0;\r\n\r\n\t\t$array.each(this.series, (series) => {\r\n\t\t\tlet field = \"valueX\";\r\n\t\t\tif (series.get(\"yAxis\") == this) {\r\n\t\t\t\tfield = \"valueY\"\r\n\t\t\t}\r\n\t\t\t$array.each(series.dataItems, (dataItem) => {\r\n\t\t\t\tlet value = dataItem.get(field as any);\r\n\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\tif (dataItem.open) {\r\n\t\t\t\t\t\tthis._updateDates(dataItem.open![field]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Convers value to a relative position on axis.\r\n\t *\r\n\t * @param   value  Value\r\n\t * @return         Relative position\r\n\t */\r\n\tpublic valueToPosition(value: number): number {\r\n\t\tconst dates = this._dates;\r\n\t\tconst len = dates.length;\r\n\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, value));\r\n\t\tlet index = result.index;\r\n\r\n\t\tif (result.found) {\r\n\t\t\treturn index / len;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (index > 0) {\r\n\t\t\t\tindex -= 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet itemValue = dates[index];\r\n\r\n\t\t\tlet d = 0;\r\n\t\t\tif (itemValue > value) {\r\n\t\t\t\td = itemValue - value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\td = value - itemValue;\r\n\t\t\t}\r\n\r\n\t\t\treturn index / len + d / this.baseDuration() / len;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts numeric value from axis scale to index.\r\n\t * \r\n\t * @param  value  Value\r\n\t * @return        Index\r\n\t */\r\n\tpublic valueToIndex(value: number): number {\r\n\t\tconst dates = this._dates;\r\n\t\tconst result = $array.getSortedIndex(dates, (x) => $order.compare(x, value));\r\n\t\tlet index = result.index;\r\n\r\n\t\tif (result.found) {\r\n\t\t\treturn index;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (index > 0) {\r\n\t\t\t\tindex -= 1;\r\n\t\t\t}\r\n\r\n\t\t\treturn index;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a relative position to a corresponding numeric value from axis\r\n\t * scale.\r\n\t *\r\n\t * @param   position  Relative position\r\n\t * @return            Value\r\n\t */\r\n\tpublic positionToValue(position: number): number {\r\n\r\n\t\tlet len = this._dates.length;\r\n\t\tlet index = position * len;\r\n\t\tlet findex = Math.floor(index);\r\n\t\tif (findex < 0) {\r\n\t\t\tfindex = 0;\r\n\t\t}\r\n\r\n\t\tif (findex > len - 1) {\r\n\t\t\tfindex = len - 1\r\n\t\t}\r\n\r\n\t\treturn this._dates[findex] + (index - findex) * this.baseDuration();\r\n\t}\r\n\r\n\tprotected _fixZoomFactor() {\r\n\t\tthis.setPrivateRaw(\"maxZoomFactor\", this._dates.length);\r\n\t}\r\n\r\n\tprotected _prepareAxisItems() {\r\n\t\tlet startTime = this.getPrivate(\"selectionMin\", 0);\r\n\t\tlet endTime = this.getPrivate(\"selectionMax\", 0);\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\r\n\t\t\tif (this._seriesValuesDirty) {\r\n\t\t\t\tthis._seriesValuesDirty = false;\r\n\t\t\t\tthis._updateAllDates();\r\n\t\t\t}\r\n\r\n\t\t\tconst dates = this._dates;\r\n\t\t\tconst renderer = this.get(\"renderer\");\r\n\t\t\tconst len = dates.length;\r\n\r\n\t\t\tlet startIndex = this.valueToIndex(startTime);\r\n\t\t\tif (startIndex > 0) {\r\n\t\t\t\tstartIndex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet endIndex = this.valueToIndex(endTime);\r\n\t\t\tif (endIndex < len - 1) {\r\n\t\t\t\tendIndex++;\r\n\t\t\t}\r\n\t\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\r\n\t\t\tlet frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\t\tthis._frequency = frequency;\r\n\r\n\t\t\tfor (let j = 0, length = this.dataItems.length; j < length; j++) {\r\n\t\t\t\tthis.dataItems[j].hide();\r\n\t\t\t}\r\n\r\n\t\t\tlet realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\r\n\r\n\t\t\t// if all items are on axis\r\n\t\t\tlet gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\")!);\r\n\r\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\r\n\t\t\tlet intervalDuration = $time.getIntervalDuration(gridInterval);\r\n\r\n\t\t\tif (intervalDuration < this.baseDuration()) {\r\n\t\t\t\tgridInterval = { ...baseInterval };\r\n\t\t\t\tintervalDuration = $time.getIntervalDuration(gridInterval);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tthis._intervalDuration = intervalDuration;\r\n\r\n\t\t\tconst formats = this.get(\"dateFormats\")!;\r\n\r\n\t\t\tlet selectedItems: Array<number> = [];\r\n\t\t\tlet firstDate = new Date();\r\n\t\t\tif(this._dates[0]){\r\n\t\t\t\tfirstDate = new Date(this._dates[0]);\r\n\t\t\t}\r\n\r\n\t\t\tlet startDate = $time.round(new Date(this.getPrivate(\"min\", 0)), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone);\r\n\t\t\tlet value = $time.add(startDate, gridInterval.timeUnit, -1, this._root.utc).getTime();\r\n\t\t\t\r\n\t\t\tlet selectionMax = this.getPrivate(\"selectionMax\")\r\n\r\n\t\t\tlet previousPosition = -Infinity;\r\n\t\t\tlet minDifference = (this.get(\"end\", 1) - this.get(\"start\", 0)) / maxCount;\r\n\r\n\t\t\twhile (value <= selectionMax) {\r\n\t\t\t\tlet index = this.valueToIndex(value);\r\n\t\t\t\tlet realValue = this._dates[index];\r\n\r\n\r\n\r\n\t\t\t\tif(realValue < value){\r\n\t\t\t\t\tfor(let i = index, len = this._dates.length; i < len; i++){\r\n\t\t\t\t\t\tlet realValue = this._dates[i];\r\n\t\t\t\t\t\tif(realValue >= value){\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet position = this.valueToPosition(realValue);\r\n\t\t\t\tif (position - previousPosition >= minDifference * 0.95) {\r\n\t\t\t\t\t$array.move(selectedItems, index);\r\n\t\t\t\t\tpreviousPosition = position;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\r\n\t\t\t}\r\n\r\n\t\t\tif (selectedItems.length > 0) {\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tlet previousValue = -Infinity;\r\n\t\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n\r\n\t\t\t\t$array.each(selectedItems, (index) => {\r\n\t\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\r\n\t\t\t\t\tif (this.dataItems.length < i + 1) {\r\n\t\t\t\t\t\tdataItem = new DataItem<this[\"_dataItemSettings\"]>(this, undefined, {});\r\n\t\t\t\t\t\tthis._dataItems.push(dataItem);\r\n\t\t\t\t\t\tthis.processDataItem(dataItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tdataItem = this.dataItems[i];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet value = dates[index];\r\n\t\t\t\t\tlet date = new Date(value);\r\n\r\n\t\t\t\t\tlet endValue = value;\r\n\t\t\t\t\tif (i < selectedItems.length - 1) {\r\n\t\t\t\t\t\tendValue = dates[selectedItems[i + 1]];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tendValue += intervalDuration;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdataItem.setRaw(\"value\", value);\r\n\t\t\t\t\tdataItem.setRaw(\"endValue\", endValue);\r\n\t\t\t\t\tdataItem.setRaw(\"index\", i);\r\n\r\n\t\t\t\t\tif (index > startIndex - 100 && index < endIndex + 100) {\r\n\r\n\t\t\t\t\t\tlet format = formats[gridInterval.timeUnit];\r\n\r\n\t\t\t\t\t\tformat = formats[gridInterval.timeUnit];\r\n\t\t\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\r\n\t\t\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\r\n\t\t\t\t\t\t\t\tif ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\r\n\t\t\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis._createAssets(dataItem, []);\r\n\r\n\t\t\t\t\t\tconst label = dataItem.get(\"label\");\r\n\t\t\t\t\t\tif (label) {\r\n\t\t\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (dataItem.isHidden()) {\r\n\t\t\t\t\t\t\tdataItem.show();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis._prepareDataItem(dataItem, gridInterval.count);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tpreviousValue = value;\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\t$array.each(this.series, (series) => {\r\n\t\t\t\tif (series.inited) {\r\n\t\t\t\t\tseries._markDirtyAxes();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis._updateGhost();\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}