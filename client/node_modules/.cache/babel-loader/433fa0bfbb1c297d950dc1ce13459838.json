{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Disposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\n\nvar EventDispatcher =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   */\n  function EventDispatcher() {\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_killed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_iterating\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_enabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n\n  Object.defineProperty(EventDispatcher.prototype, \"isDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._disposed;\n    }\n  });\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._disposed) {\n        this._disposed = true;\n        var a = this._listeners;\n        this._iterating = 1;\n        this._listeners = null;\n        this._disabled = null;\n\n        try {\n          $array.each(a, function (x) {\n            x.disposer.dispose();\n          });\n        } finally {\n          this._killed = null;\n          this._iterating = null;\n        }\n      }\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListeners\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._listeners.length !== 0;\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListenersByType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      return $array.any(this._listeners, function (x) {\n        return (x.type === null || x.type === type) && !x.killed;\n      });\n    }\n  });\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = true;\n    }\n  });\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = false;\n    }\n  });\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      delete this._disabled[type];\n    }\n  });\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, amount) {\n      if (amount === void 0) {\n        amount = Infinity;\n      }\n\n      this._disabled[type] = amount;\n    }\n  });\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (listener) {\n      if (this._iterating === 0) {\n        var index = this._listeners.indexOf(listener);\n\n        if (index === -1) {\n          throw new Error(\"Invalid state: could not remove listener\");\n        }\n\n        this._listeners.splice(index, 1);\n      } else {\n        this._killed.push(listener);\n      }\n    }\n  });\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeExistingListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.once === once && // TODO is this correct ?\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"isEnabled\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      } // TODO is this check correct ?\n\n\n      return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n    }\n  });\n  /**\r\n   * Removes all listeners of a particular event type\r\n   *\r\n   * @param type  Listener's type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"removeType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.type === type) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"has\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      var index = $array.findIndex(this._listeners, function (info) {\n        return info.once !== true && // Ignoring \"once\" listeners\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context;\n      });\n      return index !== -1;\n    }\n  });\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_shouldDispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      var count = this._disabled[type];\n\n      if (!$type.isNumber(count)) {\n        return this._enabled;\n      } else {\n        if (count <= 1) {\n          delete this._disabled[type];\n        } else {\n          --this._disabled[type];\n        }\n\n        return false;\n      }\n    }\n  });\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_eachListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fn) {\n      var _this = this;\n\n      ++this._iterating;\n\n      try {\n        $array.each(this._listeners, fn);\n      } finally {\n        --this._iterating; // TODO should this be inside or outside the finally ?\n\n        if (this._iterating === 0 && this._killed.length !== 0) {\n          // Remove killed listeners\n          $array.each(this._killed, function (killed) {\n            _this._removeListener(killed);\n          });\n          this._killed.length = 0;\n        }\n      }\n    }\n  });\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, event) {\n      if (this._shouldDispatch(type)) {\n        // TODO check if it's faster to use an object of listeners rather than a single big array\n        // TODO if the function throws, maybe it should keep going ?\n        this._eachListener(function (listener) {\n          if (!listener.killed && (listener.type === null || listener.type === type)) {\n            listener.dispatch(type, event);\n          }\n        });\n      }\n    }\n  });\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n      if (this._shouldDispatch(type)) {\r\n          this._eachListener((listener) => {\r\n              // TODO check if it's faster to use an object of listeners rather than a single big array\r\n              if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                  // TODO if the function throws, maybe it should keep going ?\r\n                  // TODO dispatch during the update cycle, rather than using whenIdle\r\n                  $async.whenIdle(() => {\r\n                      if (!listener.killed) {\r\n                          listener.dispatch(type, event);\r\n                      }\r\n                  });\r\n              }\r\n          });\r\n      }\r\n  }*/\n\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context, shouldClone, dispatch) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._removeExistingListener(once, type, callback, context);\n\n      var info = {\n        type: type,\n        callback: callback,\n        context: context,\n        shouldClone: shouldClone,\n        dispatch: dispatch,\n        killed: false,\n        once: once,\n        disposer: new Disposer(function () {\n          info.killed = true;\n\n          _this._removeListener(info);\n        })\n      };\n\n      this._listeners.push(info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"onAll\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, null, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, type, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"once\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      var x = this._on(true, type, callback, context, shouldClone, function (_type, event) {\n        x.disposer.dispose();\n        callback.call(context, event);\n      }); // TODO maybe this should return a different Disposer ?\n\n\n      return x.disposer;\n    }\n  });\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"off\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      this._removeExistingListener(false, type, callback, context);\n    }\n  });\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO is this correct ?\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return EventDispatcher;\n}();\n\nexport { EventDispatcher };\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\n\nvar TargetedEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(TargetedEventDispatcher, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n\n\n  function TargetedEventDispatcher(target) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A target object which is originating events using this dispatcher.\r\n     */\n\n\n    Object.defineProperty(_this, \"target\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this.target = target;\n    return _this;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n\n  Object.defineProperty(TargetedEventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO very hacky\n        if (x.context === source.target) {\n          return;\n        } // TODO is this correct ?\n\n\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return TargetedEventDispatcher;\n}(EventDispatcher);\n\nexport { TargetedEventDispatcher };","map":{"version":3,"mappings":"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","names":["Disposer","MultiDisposer","$array","$type","Object","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","a","each","x","disposer","dispose","length","type","any","killed","amount","listener","index","indexOf","Error","splice","push","once","callback","context","_eachListener","info","undefined","hasListenersByType","findIndex","count","isNumber","fn","_this","_removeListener","event","_shouldDispatch","dispatch","shouldClone","_removeExistingListener","_on","_type","call","source","disposers","onAll","on","__extends","target","_super","EventDispatcher"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/EventDispatcher.ts"],"sourcesContent":["/**\n * Event Dispatcher module is used for registering listeners and dispatching\n * events across amCharts system.\n */\n\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Disposer, IDisposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport type Events<Target, T> = {\n\t[K in keyof T]: T[K] & { type: K, target: Target }\n};\n\n/**\n * A universal interface for event listeners.\n *\n * @ignore\n */\nexport interface EventListener {\n\tkilled: boolean;\n\tonce: boolean;\n\ttype: any | null;\n\tcallback: (event: any) => void;\n\tcontext: unknown;\n\tshouldClone: boolean;\n\tdispatch: (type: any, event: any) => void;\n\tdisposer: IDisposer;\n}\n\n/**\n * Universal Event Dispatcher.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\n */\nexport class EventDispatcher<T> implements IDisposer {\n\tprotected _listeners: Array<EventListener>;\n\tprotected _killed: Array<EventListener>;\n\tprotected _disabled: { [key in keyof T]?: number };\n\tprotected _iterating: number;\n\tprotected _enabled: boolean;\n\tprotected _disposed: boolean;\n\n\n\t/**\n\t * Constructor\n\t */\n\tconstructor() {\n\t\tthis._listeners = [];\n\t\tthis._killed = [];\n\t\tthis._disabled = {};\n\t\tthis._iterating = 0;\n\t\tthis._enabled = true;\n\t\tthis._disposed = false;\n\t}\n\n\t/**\n\t * Returns if this object has been already disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Dispose (destroy) this object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tconst a = this._listeners;\n\n\t\t\tthis._iterating = 1;\n\t\t\tthis._listeners = <any>null;\n\t\t\tthis._disabled = <any>null;\n\n\t\t\ttry {\n\t\t\t\t$array.each(a, (x) => {\n\t\t\t\t\tx.disposer.dispose();\n\t\t\t\t});\n\n\t\t\t} finally {\n\t\t\t\tthis._killed = <any>null;\n\t\t\t\tthis._iterating = <any>null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any listeners set.\n\t *\n\t * @return Has listeners?\n\t */\n\tpublic hasListeners(): boolean {\n\t\treturn this._listeners.length !== 0;\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any particular listeners set.\n\t *\n\t * @return Has particular event listeners?\n\t */\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\n\t}\n\n\t/**\n\t * Enable dispatching of events if they were previously disabled by\n\t * `disable()`.\n\t */\n\tpublic enable(): void {\n\t\tthis._enabled = true;\n\t}\n\n\t/**\n\t * Disable dispatching of events until re-enabled by `enable()`.\n\t */\n\tpublic disable(): void {\n\t\tthis._enabled = false;\n\t}\n\n\t/**\n\t * Enable dispatching particular event, if it was disabled before by\n\t * `disableType()`.\n\t *\n\t * @param type Event type\n\t */\n\tpublic enableType<Key extends keyof T>(type: Key): void {\n\t\tdelete this._disabled[type];\n\t}\n\n\t/**\n\t * Disable dispatching of events for a certain event type.\n\t *\n\t * Optionally, can set how many dispatches to skip before automatically\n\t * re-enabling the dispatching.\n\t *\n\t * @param type    Event type\n\t * @param amount  Number of event dispatches to skip\n\t */\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\n\t\tthis._disabled[type] = amount;\n\t}\n\n\t/**\n\t * Removes listener from dispatcher.\n\t *\n\t * Will throw an exception if such listener does not exists.\n\t *\n\t * @param listener Listener to remove\n\t */\n\tprotected _removeListener(listener: EventListener): void {\n\t\tif (this._iterating === 0) {\n\t\t\tconst index = this._listeners.indexOf(listener);\n\n\t\t\tif (index === -1) {\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\n\t\t\t}\n\n\t\t\tthis._listeners.splice(index, 1);\n\n\t\t} else {\n\t\t\tthis._killed.push(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Removes existing listener by certain parameters.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tprotected _removeExistingListener<C, Key extends keyof T>(once: boolean, type: Key | null, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.once === once && // TODO is this correct ?\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if dispatching for particular event type is enabled.\n\t *\n\t * @param type  Event type\n\t * @return Enabled?\n\t */\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\t// TODO is this check correct ?\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n\t}\n\n\t/**\n\t * Removes all listeners of a particular event type\n\t *\n\t * @param type  Listener's type\n\t */\n\tpublic removeType<Key extends keyof T>(type: Key): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.type === type) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if there's already a listener with specific parameters.\n\t *\n\t * @param type      Listener's type\n\t * @param callback  Callback function\n\t * @param context   Callback context\n\t * @return Has listener?\n\t */\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context;\n\t\t});\n\n\t\treturn index !== -1;\n\t}\n\n\t/**\n\t * Checks whether event of the particular type should be dispatched.\n\t *\n\t * @param type  Event type\n\t * @return Dispatch?\n\t */\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tconst count = this._disabled[type];\n\n\t\tif (!$type.isNumber(count)) {\n\t\t\treturn this._enabled;\n\n\t\t} else {\n\t\t\tif (count <= 1) {\n\t\t\t\tdelete this._disabled[type];\n\n\t\t\t} else {\n\t\t\t\t--this._disabled[type]!;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * [_eachListener description]\n\t *\n\t * All of this extra code is needed when a listener is removed while iterating\n\t *\n\t * @todo Description\n\t * @param fn [description]\n\t */\n\tprotected _eachListener(fn: (listener: EventListener) => void): void {\n\t\t++this._iterating;\n\n\t\ttry {\n\t\t\t$array.each(this._listeners, fn);\n\n\t\t} finally {\n\t\t\t--this._iterating;\n\n\t\t\t// TODO should this be inside or outside the finally ?\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\n\t\t\t\t// Remove killed listeners\n\t\t\t\t$array.each(this._killed, (killed) => {\n\t\t\t\t\tthis._removeListener(killed);\n\t\t\t\t});\n\n\t\t\t\tthis._killed.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches an event immediately without waiting for next cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Shelves the event to be dispatched within next update cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\t/*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\n\t\t\t\t\t$async.whenIdle(() => {\n\t\t\t\t\t\tif (!listener.killed) {\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}*/\n\n\t/**\n\t * Creates, catalogs and returns an [[EventListener]].\n\t *\n\t * Event listener can be disposed.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @param dispatch\n\t * @returns An event listener\n\t */\n\tprotected _on<C, Key extends keyof T>(once: boolean, type: Key | null, callback: any, context: C, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._removeExistingListener(once, type, callback, context);\n\n\t\tconst info: EventListener = {\n\t\t\ttype: type,\n\t\t\tcallback: callback,\n\t\t\tcontext: context,\n\t\t\tshouldClone: shouldClone,\n\t\t\tdispatch: <any>dispatch,\n\t\t\tkilled: false,\n\t\t\tonce: once,\n\t\t\tdisposer: new Disposer(() => {\n\t\t\t\tinfo.killed = true;\n\t\t\t\tthis._removeListener(info);\n\t\t\t})\n\t\t};\n\n\t\tthis._listeners.push(info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on **any** event.\n\t *\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic onAll<C, K extends keyof T>(callback: (this: C, event: T[K]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, null, callback, context, shouldClone, (_type, event) => (<any>callback).call(context, event as any)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler whenever series we put\n\t * event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type once.\n\t *\n\t * Once the event listener is invoked, it is automatically disposed.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler the first time series we\n\t * put event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n\t\t\tx.disposer.dispose();\n\t\t\tcallback.call(context, event)\n\t\t});\n\n\t\t// TODO maybe this should return a different Disposer ?\n\t\treturn x.disposer;\n\t}\n\n\t/**\n\t * Removes the event listener with specific parameters.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tthis._removeExistingListener(false, type, callback, context);\n\t}\n\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n\n/**\n * A version of the [[EventDispatcher]] that dispatches events for a specific\n * target object.\n *\n * @ignore\n */\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\n\n\t/**\n\t * A target object which is originating events using this dispatcher.\n\t */\n\tpublic target: Target;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param target Event dispatcher target\n\t */\n\tconstructor(target: Target) {\n\t\tsuper();\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO very hacky\n\t\t\tif (x.context === source.target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}