{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Sprite } from \"./Sprite\";\nimport { BlendMode } from \"./backend/Renderer\";\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\nexport var visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n/**\r\n * Base class used for drawing shapes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\n\nvar Graphics =\n/** @class */\nfunction (_super) {\n  __extends(Graphics, _super);\n\n  function Graphics() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_display\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(_this, \"_clear\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Graphics.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n        this.markDirtyBounds();\n      }\n\n      if (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"visible\") || this.isDirty(\"forceHidden\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n        this._clear = true;\n      }\n\n      if (this.isDirty(\"fillGradient\")) {\n        var gradient = this.get(\"fillGradient\");\n\n        if (gradient) {\n          this._display.isMeasured = true;\n          var gradientTarget = gradient.get(\"target\");\n\n          if (gradientTarget) {\n            this._disposers.push(gradientTarget.events.on(\"boundschanged\", function () {\n              _this._markDirtyKey(\"fill\");\n            }));\n\n            this._disposers.push(gradientTarget.events.on(\"positionchanged\", function () {\n              _this._markDirtyKey(\"fill\");\n            }));\n          }\n        }\n      }\n\n      if (this.isDirty(\"strokeGradient\")) {\n        var gradient = this.get(\"strokeGradient\");\n\n        if (gradient) {\n          this._display.isMeasured = true;\n          var gradientTarget = gradient.get(\"target\");\n\n          if (gradientTarget) {\n            this._disposers.push(gradientTarget.events.on(\"boundschanged\", function () {\n              _this._markDirtyKey(\"stroke\");\n            }));\n\n            this._disposers.push(gradientTarget.events.on(\"positionchanged\", function () {\n              _this._markDirtyKey(\"stroke\");\n            }));\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Graphics.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._changed.call(this);\n\n      if (this._clear) {\n        this.markDirtyLayer();\n\n        this._display.clear();\n\n        var strokeDasharray = this.get(\"strokeDasharray\");\n\n        if ($type.isNumber(strokeDasharray)) {\n          if (strokeDasharray < 0.5) {\n            strokeDasharray = [0];\n          } else {\n            strokeDasharray = [strokeDasharray];\n          }\n        }\n\n        this._display.setLineDash(strokeDasharray);\n\n        var strokeDashoffset = this.get(\"strokeDashoffset\");\n\n        if (strokeDashoffset) {\n          this._display.setLineDashOffset(strokeDashoffset);\n        }\n\n        var blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n        this._display.blendMode = blendMode;\n        var draw = this.get(\"draw\");\n\n        if (draw) {\n          draw(this._display, this);\n        }\n\n        var svgPath = this.get(\"svgPath\");\n\n        if (svgPath != null) {\n          this._display.svgPath(svgPath);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Graphics.prototype, \"_afterChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._afterChanged.call(this);\n\n      if (this._clear) {\n        var fill_1 = this.get(\"fill\");\n        var fillGradient = this.get(\"fillGradient\");\n        var fillPattern = this.get(\"fillPattern\");\n        var fillOpacity_1 = this.get(\"fillOpacity\");\n        var stroke_1 = this.get(\"stroke\");\n        var strokeGradient = this.get(\"strokeGradient\");\n        var strokePattern = this.get(\"strokePattern\");\n        var shadowColor = this.get(\"shadowColor\");\n        var shadowBlur = this.get(\"shadowBlur\");\n        var shadowOffsetX = this.get(\"shadowOffsetX\");\n        var shadowOffsetY = this.get(\"shadowOffsetY\");\n        var shadowOpacity = this.get(\"shadowOpacity\"); //const bounds = this._display.getLocalBounds();\n\n        if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n          this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n        }\n\n        if (fillPattern) {\n          var changed = false;\n\n          if (fill_1 && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n            fillPattern.set(\"fill\", fill_1);\n            fillPattern.set(\"fillInherited\", true);\n            changed = true;\n          }\n\n          if (stroke_1 && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n            fillPattern.set(\"color\", stroke_1);\n            fillPattern.set(\"colorInherited\", true);\n            changed = true;\n          }\n\n          if (changed) {\n            // @todo: is this OK?\n            fillPattern._changed();\n          }\n\n          var pattern = fillPattern.pattern;\n\n          if (pattern) {\n            this._display.beginFill(pattern, fillOpacity_1);\n\n            this._display.endFill();\n          }\n        } else if (fillGradient) {\n          if (fill_1) {\n            var stops = fillGradient.get(\"stops\", []);\n\n            if (stops.length) {\n              $array.each(stops, function (stop) {\n                if ((!stop.color || stop.colorInherited) && fill_1) {\n                  stop.color = fill_1;\n                  stop.colorInherited = true;\n                }\n\n                if (stop.opacity == null || stop.opacityInherited) {\n                  stop.opacity = fillOpacity_1;\n                  stop.opacityInherited = true;\n                }\n              });\n            }\n          }\n\n          var gradient = fillGradient.getFill(this);\n\n          if (gradient) {\n            this._display.beginFill(gradient, fillOpacity_1);\n\n            this._display.endFill();\n          }\n        } else if (fill_1) {\n          this._display.beginFill(fill_1, fillOpacity_1);\n\n          this._display.endFill();\n        }\n\n        if (stroke_1 || strokeGradient || strokePattern) {\n          var strokeOpacity_1 = this.get(\"strokeOpacity\");\n          var strokeWidth = this.get(\"strokeWidth\", 1);\n\n          if (strokePattern) {\n            var changed = false;\n\n            if (stroke_1 && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n              strokePattern.set(\"color\", stroke_1);\n              strokePattern.set(\"colorInherited\", true);\n              changed = true;\n            }\n\n            if (changed) {\n              // @todo: is this OK?\n              strokePattern._changed();\n            }\n\n            var pattern = strokePattern.pattern;\n\n            if (pattern) {\n              this._display.lineStyle(strokeWidth, pattern, strokeOpacity_1);\n\n              this._display.endStroke();\n            }\n          } else if (strokeGradient) {\n            var stops = strokeGradient.get(\"stops\", []);\n\n            if (stops.length) {\n              $array.each(stops, function (stop) {\n                if ((!stop.color || stop.colorInherited) && stroke_1) {\n                  stop.color = stroke_1;\n                  stop.colorInherited = true;\n                }\n\n                if (stop.opacity == null || stop.opacityInherited) {\n                  stop.opacity = strokeOpacity_1;\n                  stop.opacityInherited = true;\n                }\n              });\n            }\n\n            var gradient = strokeGradient.getFill(this);\n\n            if (gradient) {\n              this._display.lineStyle(strokeWidth, gradient, strokeOpacity_1);\n\n              this._display.endStroke();\n            }\n          } else if (stroke_1) {\n            this._display.lineStyle(strokeWidth, stroke_1, strokeOpacity_1);\n\n            this._display.endStroke();\n          }\n        }\n      }\n\n      this._clear = false;\n    }\n  });\n  Object.defineProperty(Graphics, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Graphics\"\n  });\n  Object.defineProperty(Graphics, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Sprite.classNames.concat([Graphics.className])\n  });\n  return Graphics;\n}(Sprite);\n\nexport { Graphics };","map":{"version":3,"mappings":"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","names":["Sprite","BlendMode","$type","$array","visualSettings","__extends","Object","_this","_root","_renderer","makeGraphics","_super","_beforeChanged","call","isDirty","markDirtyBounds","_clear","gradient","get","_display","isMeasured","gradientTarget","_disposers","push","events","on","_markDirtyKey","_changed","markDirtyLayer","clear","strokeDasharray","isNumber","setLineDash","strokeDashoffset","setLineDashOffset","blendMode","NORMAL","draw","svgPath","_afterChanged","fill_1","fillGradient","fillPattern","fillOpacity_1","stroke_1","strokeGradient","strokePattern","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowOpacity","shadow","changed","set","pattern","beginFill","endFill","stops","length","each","stop","color","colorInherited","opacity","opacityInherited","getFill","strokeOpacity_1","strokeWidth","lineStyle","endStroke","classNames","concat","Graphics","className"],"sourceRoot":"","sources":["../../../../../src/.internal/core/render/Graphics.ts"],"sourcesContent":["import type { Color } from \"../util/Color\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Gradient } from \"../render/gradients/Gradient\";\n\nimport { ISpriteSettings, ISpritePrivate, ISpriteEvents, Sprite } from \"./Sprite\";\nimport { IGraphics, BlendMode } from \"./backend/Renderer\";\n\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\n\n\nexport const visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n\nexport interface IGraphicsSettings extends ISpriteSettings {\n\n\t/**\n\t * Fill color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tfill?: Color;\n\n\t/**\n\t * Stroke (border or line) color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tstroke?: Color;\n\n\t/**\n\t * Fill pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tfillPattern?: Pattern;\n\n\t/**\n\t * Stroke (border or line) pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tstrokePattern?: Pattern;\n\n\t/**\n\t * Fill gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tfillGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tstrokeGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) dash settings.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDasharray?: number[] | number;\n\n\t/**\n\t * Stroke (border or line) dash offset.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDashoffset?: number;\n\n\t/**\n\t * Opacity of the fill. 0 - fully transparent; 1 - fully opaque.\n\t */\n\tfillOpacity?: number;\n\n\t/**\n\t * Opacity of the stroke (border or line). 0 - fully transparent; 1 - fully opaque.\n\t */\n\tstrokeOpacity?: number;\n\n\t/**\n\t * Width of the stroke (border or line) in pixels.\n\t */\n\tstrokeWidth?: number;\n\n\t/**\n\t * Drawing function.\n\t *\n\t * Must use renderer (`display` parameter) methods to draw.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/#Custom_draw_functions} for more info\n\t */\n\tdraw?: (display: IGraphics, graphics: Graphics) => void;\n\n\t/**\n\t * Rendering mode.\n\t *\n\t * @default BlendMode.NORMAL (\"source-over\")\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation} for more information\n\t * @ignore\n\t */\n\tblendMode?: BlendMode;\n\n\t/**\n\t * Draw a shape using an SVG path.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n\t/**\n\t * Color of the element's shadow.\n\t *\n\t * For this to work at least one of the following needs to be set as well:\n\t * `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowColor?: Color | null;\n\n\t/**\n\t * Blurriness of the the shadow.\n\t *\n\t * The bigger the number, the more blurry shadow will be.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowBlur?: number;\n\n\t/**\n\t * Horizontal shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetX?: number;\n\n\t/**\n\t * Vertical shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetY?: number;\n\n\t/**\n\t * Opacity of the shadow (0-1).\n\t *\n\t * If not set, will use the same as `fillOpacity` of the element.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOpacity?: number;\n\n}\n\nexport interface IGraphicsPrivate extends ISpritePrivate {\n}\n\nexport interface IGraphicsEvents extends ISpriteEvents {\n}\n\n/**\n * Base class used for drawing shapes.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n * @important\n */\nexport class Graphics extends Sprite {\n\n\tdeclare public _settings: IGraphicsSettings;\n\tdeclare public _privateSettings: IGraphicsPrivate;\n\tdeclare public _events: IGraphicsEvents;\n\n\tpublic _display: IGraphics = this._root._renderer.makeGraphics();\n\n\tprotected _clear = false;\n\n\tpublic static className: string = \"Graphics\";\n\tpublic static classNames: Array<string> = Sprite.classNames.concat([Graphics.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n\t\t\tthis.markDirtyBounds();\n\t\t}\n\n\t\tif (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"visible\") || this.isDirty(\"forceHidden\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\n\t\tif (this.isDirty(\"fillGradient\")) {\n\t\t\tconst gradient = this.get(\"fillGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(gradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"strokeGradient\")) {\n\t\t\tconst gradient = this.get(\"strokeGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\t\t\tthis.markDirtyLayer();\n\t\t\tthis._display.clear();\n\n\t\t\tlet strokeDasharray = this.get(\"strokeDasharray\");\n\t\t\tif ($type.isNumber(strokeDasharray)) {\n\t\t\t\tif (strokeDasharray < 0.5) {\n\t\t\t\t\tstrokeDasharray = [0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstrokeDasharray = [strokeDasharray]\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._display.setLineDash(strokeDasharray as number[]);\n\n\t\t\tconst strokeDashoffset = this.get(\"strokeDashoffset\");\n\t\t\tif (strokeDashoffset) {\n\t\t\t\tthis._display.setLineDashOffset(strokeDashoffset);\n\t\t\t}\n\n\t\t\tconst blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n\t\t\tthis._display.blendMode = blendMode;\n\n\t\t\tconst draw = this.get(\"draw\");\n\t\t\tif (draw) {\n\t\t\t\tdraw(this._display, this);\n\t\t\t}\n\n\t\t\tconst svgPath = this.get(\"svgPath\");\n\t\t\tif (svgPath != null) {\n\t\t\t\tthis._display.svgPath(svgPath!);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _afterChanged() {\n\t\tsuper._afterChanged();\n\n\t\tif (this._clear) {\n\t\t\tconst fill = this.get(\"fill\");\n\t\t\tconst fillGradient = this.get(\"fillGradient\");\n\t\t\tconst fillPattern = this.get(\"fillPattern\");\n\t\t\tconst fillOpacity = this.get(\"fillOpacity\");\n\n\t\t\tconst stroke = this.get(\"stroke\");\n\t\t\tconst strokeGradient = this.get(\"strokeGradient\");\n\t\t\tconst strokePattern = this.get(\"strokePattern\");\n\n\t\t\tconst shadowColor = this.get(\"shadowColor\");\n\t\t\tconst shadowBlur = this.get(\"shadowBlur\");\n\t\t\tconst shadowOffsetX = this.get(\"shadowOffsetX\");\n\t\t\tconst shadowOffsetY = this.get(\"shadowOffsetY\");\n\t\t\tconst shadowOpacity = this.get(\"shadowOpacity\");\n\n\t\t\t//const bounds = this._display.getLocalBounds();\n\n\t\t\tif (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n\t\t\t\tthis._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n\t\t\t}\n\n\t\t\tif (fillPattern) {\n\t\t\t\tlet changed = false;\n\t\t\t\tif (fill && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"fill\", fill);\n\t\t\t\t\tfillPattern.set(\"fillInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (stroke && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"color\", stroke);\n\t\t\t\t\tfillPattern.set(\"colorInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (changed) {\n\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\tfillPattern._changed();\n\t\t\t\t}\n\t\t\t\tconst pattern = fillPattern.pattern;\n\t\t\t\tif (pattern) {\n\t\t\t\t\tthis._display.beginFill(pattern, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fillGradient) {\n\t\t\t\tif (fill) {\n\t\t\t\t\tconst stops = fillGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && fill) {\n\t\t\t\t\t\t\t\tstop.color = fill;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = fillOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst gradient = fillGradient.getFill(this);\n\t\t\t\tif (gradient) {\n\t\t\t\t\tthis._display.beginFill(gradient, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fill) {\n\t\t\t\tthis._display.beginFill(fill, fillOpacity);\n\t\t\t\tthis._display.endFill();\n\t\t\t}\n\n\t\t\tif (stroke || strokeGradient || strokePattern) {\n\t\t\t\tconst strokeOpacity = this.get(\"strokeOpacity\");\n\t\t\t\tconst strokeWidth = this.get(\"strokeWidth\", 1);\n\n\t\t\t\tif (strokePattern) {\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tif (stroke && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n\t\t\t\t\t\tstrokePattern.set(\"color\", stroke);\n\t\t\t\t\t\tstrokePattern.set(\"colorInherited\", true);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\t\tstrokePattern._changed();\n\t\t\t\t\t}\n\t\t\t\t\tconst pattern = strokePattern.pattern;\n\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, pattern, strokeOpacity);\n\t\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strokeGradient) {\n\n\t\t\t\t\tconst stops = strokeGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && stroke) {\n\t\t\t\t\t\t\t\tstop.color = stroke;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = strokeOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gradient = strokeGradient.getFill(this);\n\t\t\t\t\tif (gradient) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, gradient, strokeOpacity);\n\t\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (stroke) {\n\t\t\t\t\tthis._display.lineStyle(strokeWidth, stroke, strokeOpacity);\n\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tthis._clear = false;\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}