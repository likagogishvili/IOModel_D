{"ast":null,"code":"import * as $type from \"./Type\";\nimport * as $object from \"./Object\";\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar JSONParser =\n/** @class */\nfunction () {\n  function JSONParser() {}\n  /**\r\n   * Parses JSON string.\r\n   *\r\n   * @param   input    JSON\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(JSONParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options);\n\n      try {\n        if ($type.isString(input)) {\n          var data = JSON.parse(input);\n\n          if (options.reverse && $type.isArray(data)) {\n            data.reverse();\n          }\n\n          return data;\n        } else if ($type.isArray(input) || $type.isObject(input)) {\n          return input;\n        } else {\n          throw \"Unable to parse JSON data\";\n        }\n      } catch (e) {\n        return undefined;\n      }\n    }\n  });\n  Object.defineProperty(JSONParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        reverse: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return JSONParser;\n}();\n\nexport { JSONParser };\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar CSVParser =\n/** @class */\nfunction () {\n  function CSVParser() {}\n  /**\r\n   * Parses CSV string.\r\n   *\r\n   * @param   input    CSV\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(CSVParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options); // Get CSV data as array\n\n      var data = this.CSVToArray(input, options.delimiter); // Init resuling array\n\n      var res = [],\n          cols = [],\n          col,\n          i; // Skip rows\n\n      for (i = 0; i < options.skipRows; i++) {\n        data.shift();\n      } // First row holds column names?\n\n\n      if (options.useColumnNames) {\n        cols = data.shift(); // Normalize column names\n\n        for (var x = 0; x < cols.length; x++) {\n          // trim\n          col = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\"; // Check for empty\n\n          if (\"\" === col) {\n            col = \"col\" + x;\n          }\n\n          cols[x] = col;\n        }\n      } // Iterate through the result set\n\n\n      var row;\n\n      while (true) {\n        row = options.reverse ? data.pop() : data.shift();\n\n        if (!row) {\n          break;\n        }\n\n        if (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n          continue;\n        }\n\n        var dataPoint = {};\n\n        for (i = 0; i < row.length; i++) {\n          col = undefined === cols[i] ? \"col\" + i : cols[i];\n          dataPoint[col] = row[i];\n        }\n\n        res.push(dataPoint);\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(CSVParser, \"CSVToArray\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (data, delimiter) {\n      // Check to see if the delimiter is defined. If not,\n      // then default to comma.\n      delimiter = delimiter || ','; // Create a regular expression to parse the CSV values.\n\n      var objPattern = new RegExp( // Delimiters.\n      \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n      \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n      \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n      // a default empty first row.\n\n      var arrData = [[]]; // Create an array to hold our individual pattern\n      // matching groups.\n\n      var arrMatches = null; // Keep looping over the regular expression matches\n      // until we can no longer find a match.\n\n      while (true) {\n        arrMatches = objPattern.exec(data);\n\n        if (!arrMatches) {\n          break;\n        } // Get the delimiter that was found.\n\n\n        var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n\n        if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n          // Since we have reached a new row of data,\n          // add an empty row to our data array.\n          arrData.push([]);\n        } // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n\n\n        var strMatchedValue = void 0;\n\n        if (arrMatches[2]) {\n          // We found a quoted value. When we capture\n          // this value, unescape any double quotes.\n          strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n        } else {\n          // We found a non-quoted value.\n          strMatchedValue = arrMatches[3];\n        } // Now that we have our value string, let's add\n        // it to the data array.\n\n\n        arrData[arrData.length - 1].push(strMatchedValue);\n      } // Return the parsed data.\n\n\n      return arrData;\n    }\n  });\n  Object.defineProperty(CSVParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        delimiter: \",\",\n        reverse: false,\n        skipRows: 0,\n        skipEmpty: true,\n        useColumnNames: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return CSVParser;\n}();\n\nexport { CSVParser };","map":{"version":3,"mappings":"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","names":["$type","$object","input","options","_applyDefaults","isString","data","JSON","parse","reverse","isArray","isObject","e","undefined","normalized","defaults","each","key","val","CSVToArray","delimiter","res","cols","col","i","skipRows","shift","useColumnNames","x","length","replace","row","pop","skipEmpty","dataPoint","push","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/DataParser.ts"],"sourcesContent":["import * as $type from \"./Type\"\nimport * as $object from \"./Object\"\n\nexport interface IJSONParserOptions {\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class JSONParser {\n\n\t/**\n\t * Parses JSON string.\n\t * \n\t * @param   input    JSON\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: IJSONParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\t\ttry {\n\t\t\tif ($type.isString(input)) {\n\t\t\t\tlet data  = JSON.parse(input);\n\t\t\t\tif (options.reverse && $type.isArray(data)) {\n\t\t\t\t\tdata.reverse();\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if ($type.isArray(input) || $type.isObject(input)) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\"Unable to parse JSON data\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected static _applyDefaults(options?: IJSONParserOptions): IJSONParserOptions {\n\t\tconst normalized: IJSONParserOptions = {};\n\t\tconst defaults = {\n\t\t\treverse: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\t}\n}\n\n\nexport interface ICSVParserOptions {\n\n\t/**\n\t * Delimiter used for columns.\n\t * \n\t * @default \",\"\n\t */\n\tdelimiter?: string;\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n\t/**\n\t * Skip first X rows.\n\t *\n\t * @default 0\n\t */\n\tskipRows?: number;\n\n\t/**\n\t * Skip empty rows.\n\t *\n\t * @default true\n\t */\n\tskipEmpty?: boolean;\n\n\t/**\n\t * Use the first row to name the columns.\n\t * \n\t * @default false\n\t */\n\tuseColumnNames?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class CSVParser {\n\n\t/**\n\t * Parses CSV string.\n\t * \n\t * @param   input    CSV\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: ICSVParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\n\t\t// Get CSV data as array\n\t\tlet data = this.CSVToArray(input, options.delimiter!);\n\n\t\t// Init resuling array\n\t\tlet res: any[] = [],\n\t\t\tcols: string[] = [],\n\t\t\tcol: string,\n\t\t\ti: number;\n\n\t\t// Skip rows\n\t\tfor (i = 0; i < options.skipRows!; i++) {\n\t\t\tdata.shift();\n\t\t}\n\n\t\t// First row holds column names?\n\t\tif (options.useColumnNames) {\n\t\t\tcols = data.shift();\n\n\t\t\t// Normalize column names\n\t\t\tfor (let x = 0; x < cols.length; x++) {\n\t\t\t\t// trim\n\t\t\t\tcol = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n\n\t\t\t\t// Check for empty\n\t\t\t\tif (\"\" === col) {\n\t\t\t\t\tcol = \"col\" + x;\n\t\t\t\t}\n\n\t\t\t\tcols[x] = col;\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the result set\n\t\tlet row;\n\t\twhile (true) {\n\t\t\trow = options.reverse ? data.pop() : data.shift();\n\n\t\t\tif (!row) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dataPoint: any = {};\n\t\t\tfor (i = 0; i < row.length; i++) {\n\t\t\t\tcol = undefined === cols[i] ? \"col\" + i : cols[i];\n\t\t\t\tdataPoint[col] = row[i];\n\t\t\t}\n\t\t\tres.push(dataPoint);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic static CSVToArray(data: string, delimiter: string): any[] {\n\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tdelimiter = (delimiter || ',');\n\n\t\t// Create a regular expression to parse the CSV values.\n\t\tlet objPattern = new RegExp(\n\t\t\t(\n\t\t\t\t// Delimiters.\n\t\t\t\t\"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n\t\t\t\t// Quoted fields.\n\t\t\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n\t\t\t\t// Standard fields.\n\t\t\t\t\"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"\n\t\t\t),\n\t\t\t\"gi\"\n\t\t);\n\n\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tlet arrData: any[] = [\n\t\t\t[]\n\t\t];\n\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tlet arrMatches = null;\n\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (true) {\n\t\t\tarrMatches = objPattern.exec(data);\n\n\t\t\tif (!arrMatches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get the delimiter that was found.\n\t\t\tlet strMatchedDelimiter = arrMatches[1];\n\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (\n\t\t\t\tstrMatchedDelimiter.length &&\n\t\t\t\t(strMatchedDelimiter !== delimiter)\n\t\t\t) {\n\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\n\t\t\t}\n\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tlet strMatchedValue;\n\t\t\tif (arrMatches[2]) {\n\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tstrMatchedValue = arrMatches[2].replace(\n\t\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"),\n\t\t\t\t\t\"\\\"\"\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tstrMatchedValue = arrMatches[3];\n\n\t\t\t}\n\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t}\n\n\tprotected static _applyDefaults(options?: ICSVParserOptions): ICSVParserOptions {\n\t\tconst normalized: ICSVParserOptions = {};\n\t\tconst defaults = {\n\t\t\tdelimiter: \",\",\n\t\t\treverse: false,\n\t\t\tskipRows: 0,\n\t\t\tskipEmpty: true,\n\t\t\tuseColumnNames: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\n\t}\n\n}"]},"metadata":{},"sourceType":"module"}