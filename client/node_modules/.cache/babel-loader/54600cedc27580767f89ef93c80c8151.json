{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { TargetedEventDispatcher } from \"./utils/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"./utils/Disposer\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $object from \"./utils/Object\";\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\n\nvar SpriteEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(SpriteEventDispatcher, _super);\n\n  function SpriteEventDispatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * [_interactionEvents description]\r\n     *\r\n     * @todo Description\r\n     */\n\n\n    _this._interactionEvents = new Dictionary();\n    return _this;\n  }\n  /**\r\n   * [_dispatchSpriteEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpriteEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_dispatchSpritePointEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpritePointEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target,\n        spritePoint: ev.point ? $utils.documentPointToSprite(ev.point, this.target) : undefined,\n        svgPoint: this.target.getSvgPoint(ev.point)\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_addInteractionObjectEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._addInteractionObjectEvent = function (type, callback, context, shouldClone) {\n    var _this = this;\n\n    var key = shouldClone + \"-\" + type;\n\n    var counter = this._interactionEvents.insertKeyIfEmpty(key, function () {\n      var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);\n\n      return new CounterDisposer(function () {\n        _this._interactionEvents.removeKey(key);\n\n        disposer.dispose();\n      });\n    });\n\n    return counter.increment();\n  };\n  /**\r\n   * [_on description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n\n    var disposers = [info.disposer];\n    /**\r\n     * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n     * triggering them on sprite\r\n     */\n\n    switch (type) {\n      case \"hit\":\n      case \"track\":\n      case \"doublehit\":\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));\n        break;\n\n      case \"rightclick\":\n      case \"down\": //case \"hold\":\n\n      case \"up\":\n      case \"drag\":\n      case \"dragged\":\n      case \"dragstart\":\n      case \"dragstop\":\n      case \"over\":\n      case \"out\":\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n      case \"resize\": //case \"rotate\":\n\n      case \"focus\":\n      case \"blur\":\n      case \"toggled\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));\n        break;\n    }\n    /**\r\n     * Set functional properties based on events. For example if we add a\r\n     * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n     * don't explicitly set \"draggable\"\r\n     */\n\n\n    switch (type) {\n      case \"hit\":\n      case \"doublehit\":\n      case \"rightclick\":\n      case \"down\":\n      case \"up\":\n        this.target.clickable = true;\n        break;\n\n      case \"toggled\":\n        this.target.togglable = true;\n        break;\n\n      case \"drag\":\n      case \"dragstart\":\n      case \"dragstop\":\n        this.target.draggable = true;\n        break;\n\n      case \"track\":\n        this.target.trackable = true;\n        break;\n\n      case \"resize\":\n        this.target.resizable = true;\n        break;\n\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n        this.target.swipeable = true;\n        break;\n\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        this.target.wheelable = true;\n        break;\n\n      case \"over\":\n        this.target.hoverable = true;\n\n      case \"out\":\n        this.target.hoverable = true;\n        break;\n\n      case \"focus\":\n      case \"blur\":\n        this.target.focusable = true;\n        break;\n    }\n\n    info.disposer = new MultiDisposer(disposers);\n    return info;\n  };\n\n  return SpriteEventDispatcher;\n}(TargetedEventDispatcher);\n\nexport { SpriteEventDispatcher };","map":{"version":3,"mappings":"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","names":["Dictionary","TargetedEventDispatcher","MultiDisposer","CounterDisposer","$utils","$object","__extends","_this","SpriteEventDispatcher","ev","target","disabled","isTemplate","events","isEnabled","type","imev","merge","dispatchImmediately","spritePoint","point","documentPointToSprite","undefined","svgPoint","getSvgPoint","callback","context","shouldClone","key","counter","_interactionEvents","insertKeyIfEmpty","disposer","interactions","on","removeKey","dispose","increment","once","dispatch","info","_super","_on","call","disposers","push","_addInteractionObjectEvent","_dispatchSpritePointEvent","_dispatchSpriteEvent","clickable","togglable","draggable","trackable","resizable","swipeable","wheelable","hoverable","focusable"],"sourceRoot":"","sources":["../../../../src/.internal/core/SpriteEvents.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { EventListener, TargetedEventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { InteractionObject, IInteractionObjectEvents } from \"./interaction/InteractionObject\";\r\nimport { IPointer } from \"./interaction/Pointer\";\r\nimport { MultiDisposer, IDisposer, CounterDisposer } from \"./utils/Disposer\";\r\nimport { IPoint } from \"./defs/IPoint\";\r\nimport * as $utils from \"./utils/Utils\";\r\nimport * as $object from \"./utils/Object\";\r\n\r\n/**\r\n * ============================================================================\r\n * RE-EXPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport { AMEvent };\r\n\r\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\r\nexport class SpriteEventDispatcher<T extends AMEvent<Sprite, ISpriteEvents>> extends TargetedEventDispatcher<Sprite, T> {\r\n\r\n\t/**\r\n\t * [_interactionEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _interactionEvents = new Dictionary<string, CounterDisposer>();\r\n\r\n\t/**\r\n\t * [_dispatchSpriteEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpriteEvent<Key extends keyof IInteractionObjectEvents>(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_dispatchSpritePointEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpritePointEvent<Key extends \"hit\" | \"track\">(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target,\r\n\t\t\t\tspritePoint: ev.point ? $utils.documentPointToSprite(ev.point, this.target) : undefined,\r\n\t\t\t\tsvgPoint: this.target.getSvgPoint(ev.point)\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_addInteractionObjectEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _addInteractionObjectEvent<C, Key extends keyof IInteractionObjectEvents>(type: Key, callback: (this: C, ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]) => void, context: C, shouldClone: boolean): IDisposer {\r\n\t\tconst key = shouldClone + \"-\" + type;\r\n\r\n\t\tconst counter = this._interactionEvents.insertKeyIfEmpty(key, () => {\r\n\t\t\tconst disposer = this.target.interactions.events.on(type, callback, context, shouldClone);\r\n\r\n\t\t\treturn new CounterDisposer(() => {\r\n\t\t\t\tthis._interactionEvents.removeKey(key);\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn counter.increment();\r\n\t}\r\n\r\n\t/**\r\n\t * [_on description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tconst info = super._on(once, type, callback, context, shouldClone, dispatch);\r\n\r\n\t\tconst disposers = [info.disposer];\r\n\r\n\t\t/**\r\n\t\t * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n\t\t * triggering them on sprite\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"track\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpritePointEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\t//case \"hold\":\r\n\t\t\tcase \"up\":\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragged\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\tcase \"over\":\r\n\t\t\tcase \"out\":\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\tcase \"resize\":\r\n\t\t\t//case \"rotate\":\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpriteEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Set functional properties based on events. For example if we add a\r\n\t\t * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n\t\t * don't explicitly set \"draggable\"\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\tcase \"up\":\r\n\t\t\t\tthis.target.clickable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tthis.target.togglable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\t\tthis.target.draggable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"track\":\r\n\t\t\t\tthis.target.trackable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"resize\":\r\n\t\t\t\tthis.target.resizable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\t\tthis.target.swipeable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tthis.target.wheelable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"over\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\tcase \"out\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\t\tthis.target.focusable = true;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tinfo.disposer = new MultiDisposer(disposers);\r\n\r\n\t\treturn info;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Defines a type of event that has a single point of reference.\r\n */\r\nexport type SpritePointerTypeEvent = {\r\n\r\n\t/**\r\n\t * Is event originated by touch pointer?\r\n\t */\r\n\ttouch: boolean;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains point information.\r\n */\r\nexport type SpritePointEvent = {\r\n\t/**\r\n\t * Event point in global (document) coordinates.\r\n\t */\r\n\tpoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point in local Sprite coordinates.\r\n\t */\r\n\tspritePoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point with chart (svg) coodinates.\r\n\t */\r\n\tsvgPoint: IPoint;\r\n};\r\n\r\n\r\n/**\r\n * Defines a type of event that has a related Pointer.\r\n */\r\nexport type SpritePointerEvent = {\r\n\r\n\t/**\r\n\t * Coordinates of the primary cursor position.\r\n\t */\r\n\tpointer: IPointer;\r\n\r\n};\r\n\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains mouse or touch\r\n * event.\r\n */\r\nexport type SpriteMouseTouchEvent = {\r\n\r\n\t/**\r\n\t * Original mouse/touch event.\r\n\t */\r\n\tevent: MouseEvent | TouchEvent;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains coordinate shift\r\n * information, such as drag events.\r\n */\r\nexport type SpriteShiftEvent = {\r\n\r\n\t/**\r\n\t * Shift in coordinates after dragging.\r\n\t */\r\n\tshift: IPoint;\r\n\r\n};\r\n\r\n/**\r\n * Defines available events available for [[Sprite]].\r\n */\r\nexport interface ISpriteEvents extends IInteractionObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when Sprite completes transition to a [[SpriteState]].\r\n\t */\r\n\ttransitionended: {};\r\n\r\n\t/**\r\n\t * Invoked when size of the Sprite changes.\r\n\t */\r\n\tsizechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when maximum available size of the Sprite changes, i.e. when the\r\n\t * size of parent container changes.\r\n\t */\r\n\tmaxsizechanged: {\r\n\t\tpreviousWidth: number,\r\n\t\tpreviousHeight: number\r\n\t};\r\n\r\n\t/**\r\n\t * @todo Description\r\n\t */\r\n\ttransformed: {\r\n\r\n\t\t/**\r\n\t\t * [string description]\r\n\t\t * @todo Needs description\r\n\t\t */\r\n\t\tdummyData?: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when position of the [[Sprite]] changes.\r\n\t */\r\n\tpositionchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is initialized.\r\n\t */\r\n\tinited: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] appears. Sprite appears when `sprite.appear()` method\r\n\t * is called and show animation is finished.\r\n\t */\r\n\tappeared: {};\r\n\r\n\t/**\r\n\t * Invoked when chart is shown if `am4core.options.queue = true` or/and `am4core.options.onlyShowOnViewport = true`.\r\n\t */\r\n\tremovedfromqueue: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is becomes ready, that is it has finished all\r\n\t * calculations and building itself.\r\n\t *\r\n\t * For [[Container]] object (and all those inheriting it, including charts)\r\n\t * this event will fire when all children become ready.\r\n\t */\r\n\tready: {};\r\n\r\n\t/**\r\n\t * Invoked before [[Sprite]] is validated.\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tbeforevalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is validated. (on init or after update)\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tvalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when visibility of the [[Sprite]] changes. (from visible to hidden,\r\n\t * and vice versa)\r\n\t */\r\n\tvisibilitychanged: {\r\n\t\tvisible: boolean;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when hidden [[Sprite]] is shown.\r\n\t */\r\n\tshown: {};\r\n\r\n\t/**\r\n\t * Invoked when visible [[Sprite]] is hidden.\r\n\t */\r\n\thidden: {};\r\n\r\n\t/**\r\n\t * Invoked when zIndex of a sprite is changed\r\n\t */\r\n\tzIndexChanged: {};\r\n\r\n\t/**\r\n\t * Invoked when property of the [[Sprite]] changes.\r\n\t */\r\n\tpropertychanged: {\r\n\r\n\t\t/**\r\n\t\t * Property key.\r\n\t\t */\r\n\t\tproperty: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when the global scale changed, meaning that scale of [[Sprite]]\r\n\t * or any of its ascendants changed.\r\n\t */\r\n\tglobalscalechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched.\r\n\t */\r\n\thit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched twice in rapid succession.\r\n\t */\r\n\tdoublehit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when pointer (mouse cursor or touch point) moves over `trackable`\r\n\t * [[Sprite]].\r\n\t */\r\n\ttrack:  SpritePointerTypeEvent & SpritePointEvent & SpritePointerEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel while over the [[Sprite]].\r\n\t */\r\n\twheel: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel upwards while over the [[Sprite]].\r\n\t */\r\n\twheelup: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel downwards while over the [[Sprite]].\r\n\t */\r\n\twheeldown: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel leftwards while over the [[Sprite]].\r\n\t */\r\n\twheelleft: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel rightwards while over the [[Sprite]].\r\n\t */\r\n\twheelright: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `togglable` Sprite is being toggled on and off. (its\r\n\t * `isActive` property is being changed)\r\n\t */\r\n\ttoggled: {};\r\n\r\n\t/**\r\n\t * Invoked just before Sprite is disposed.\r\n\t */\r\n\tbeforedisposed: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is disabled\r\n\t */\r\n\tdisabled: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is enabled\r\n\t */\r\n\tenabled: {};\r\n\r\n\t/**\r\n\t * Invoked when `draggable` object is being dragged. (using mouse, touch or\r\n\t * keyboard).\r\n\t *\r\n\t * This is simmilar but different then `\"drag\"` event in that it kicks in\r\n\t * after `\"drag\"` which modifies [[Sprite]] coordinates. This allows doing\r\n\t * own manipulations and corrections to element positions.\r\n\t */\r\n\tdragged: SpritePointerTypeEvent & SpriteShiftEvent & SpritePointEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original coordinates of the pointer's position when the dragging started.\r\n\t\t */\r\n\t\tstartPoint: IPoint,\r\n\r\n\t\t/**\r\n\t\t * An original JavaScript event that triggered dragging.\r\n\t\t */\r\n\t\tevent?: MouseEvent | TouchEvent | KeyboardEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when a sprite is added to a parent\r\n\t */\r\n\tparentset: {};\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}