{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { Color } from \"./Color\";\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\n\nvar ColorSet =\n/** @class */\nfunction (_super) {\n  __extends(ColorSet, _super);\n\n  function ColorSet() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } //protected _currentPass: number = 0;\n\n\n  Object.defineProperty(ColorSet.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Applying themes because color set will not have parent\n      _super.prototype._afterNewApplyThemes.call(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"generateColors\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\n      var pass = this.getPrivate(\"currentPass\");\n      var colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\n      if (!this.getPrivate(\"numColors\")) {\n        this.setPrivate(\"numColors\", colors.length);\n      } //const len = colors.length;\n\n\n      var len = this.getPrivate(\"numColors\"); //const start = len - this.getPrivate(\"numColors\")!;\n\n      var start = 0;\n      var passOptions = this.get(\"passOptions\");\n      var reuse = this.get(\"reuse\");\n\n      for (var i = start; i < len; i++) {\n        if (reuse) {\n          colors.push(colors[i]);\n        } else {\n          var hsl = colors[i].toHSL();\n          var h = hsl.h + (passOptions.hue || 0) * pass;\n\n          while (h > 1) h -= 1;\n\n          var s = hsl.s + (passOptions.saturation || 0) * pass; //if (s > 1) s -= Math.floor(s);\n\n          if (s > 1) s = 1;\n          if (s < 0) s = 0;\n          var l = hsl.l + (passOptions.lightness || 0) * pass; //if (l > 1) l -= Math.floor(l);\n\n          while (l > 1) l -= 1;\n\n          colors.push(Color.fromHSL(h, s, l));\n        }\n      }\n    }\n  });\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there's no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"getIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      var colors = this.get(\"colors\", []);\n      var saturation = this.get(\"saturation\");\n\n      if (index >= colors.length) {\n        this.generateColors();\n        return this.getIndex(index);\n      }\n\n      return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n    }\n  });\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"next\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n      this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n      return this.getIndex(currentStep);\n    }\n  });\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"reset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n    }\n  });\n  Object.defineProperty(ColorSet, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ColorSet\"\n  });\n  Object.defineProperty(ColorSet, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([ColorSet.className])\n  });\n  return ColorSet;\n}(Entity);\n\nexport { ColorSet };","map":{"version":3,"mappings":";AAAA,SAASA,MAAT,QAAwD,UAAxD;AACA,SAASC,KAAT,QAAsB,SAAtB;AAoFA;;;;;;AAKA;AAAA;AAAA;EAA8BC;;EAA9B;;EAyFC,CAzFD,CAOC;;;;;;;WAEA;MACC;MACAC,iBAAMC,oBAAN,CAA0BC,IAA1B,CAA0B,IAA1B;IACA;;EAED;;;;;;;;WAGA;MACC,KAAKC,UAAL,CAAgB,aAAhB,EAA+B,KAAKC,UAAL,CAAgB,aAAhB,EAA+B,CAA/B,IAAoC,CAAnE;MACA,IAAMC,IAAI,GAAG,KAAKD,UAAL,CAAgB,aAAhB,CAAb;MACA,IAAME,MAAM,GAAG,KAAKC,GAAL,CAAS,QAAT,EAAmB,CAAC,KAAKA,GAAL,CAAS,WAAT,EAAsBT,KAAK,CAACU,OAAN,CAAc,QAAd,CAAtB,CAAD,CAAnB,CAAf;;MACA,IAAI,CAAC,KAAKJ,UAAL,CAAgB,WAAhB,CAAL,EAAmC;QAClC,KAAKD,UAAL,CAAgB,WAAhB,EAA6BG,MAAM,CAACG,MAApC;MACA,CANF,CAOC;;;MACA,IAAMC,GAAG,GAAG,KAAKN,UAAL,CAAgB,WAAhB,CAAZ,CARD,CASC;;MACA,IAAMO,KAAK,GAAG,CAAd;MACA,IAAMC,WAAW,GAAG,KAAKL,GAAL,CAAS,aAAT,CAApB;MACA,IAAMM,KAAK,GAAG,KAAKN,GAAL,CAAS,OAAT,CAAd;;MACA,KAAK,IAAIO,CAAC,GAAGH,KAAb,EAAoBG,CAAC,GAAGJ,GAAxB,EAA6BI,CAAC,EAA9B,EAAkC;QACjC,IAAID,KAAJ,EAAW;UACVP,MAAM,CAACS,IAAP,CAAYT,MAAM,CAACQ,CAAD,CAAlB;QACA,CAFD,MAGK;UACJ,IAAME,GAAG,GAAGV,MAAM,CAACQ,CAAD,CAAN,CAAWG,KAAX,EAAZ;UACA,IAAIC,CAAC,GAAGF,GAAG,CAACE,CAAJ,GAAQ,CAACN,WAAW,CAACO,GAAZ,IAAmB,CAApB,IAAyBd,IAAzC;;UACA,OAAOa,CAAC,GAAG,CAAX,EAAcA,CAAC,IAAI,CAAL;;UAEd,IAAIE,CAAC,GAAGJ,GAAG,CAACI,CAAJ,GAAQ,CAACR,WAAW,CAACS,UAAZ,IAA0B,CAA3B,IAAgChB,IAAhD,CALI,CAMJ;;UACA,IAAIe,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAJ;UACX,IAAIA,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAJ;UAEX,IAAIE,CAAC,GAAGN,GAAG,CAACM,CAAJ,GAAQ,CAACV,WAAW,CAACW,SAAZ,IAAyB,CAA1B,IAA+BlB,IAA/C,CAVI,CAWJ;;UACA,OAAOiB,CAAC,GAAG,CAAX,EAAcA,CAAC,IAAI,CAAL;;UACdhB,MAAM,CAACS,IAAP,CAAYjB,KAAK,CAAC0B,OAAN,CAAcN,CAAd,EAAiBE,CAAjB,EAAoBE,CAApB,CAAZ;QACA;MACD;IACD;;EAED;;;;;;;;;;;;;WAQA,UAAgBG,KAAhB,EAA6B;MAC5B,IAAMnB,MAAM,GAAG,KAAKC,GAAL,CAAS,QAAT,EAAmB,EAAnB,CAAf;MACA,IAAMc,UAAU,GAAG,KAAKd,GAAL,CAAS,YAAT,CAAnB;;MACA,IAAIkB,KAAK,IAAInB,MAAM,CAACG,MAApB,EAA4B;QAC3B,KAAKiB,cAAL;QACA,OAAO,KAAKC,QAAL,CAAcF,KAAd,CAAP;MACA;;MAED,OAAOJ,UAAU,IAAI,IAAd,GAAqBvB,KAAK,CAAC8B,QAAN,CAAetB,MAAM,CAACmB,KAAD,CAArB,EAA8BJ,UAA9B,CAArB,GAAkEf,MAAM,CAACmB,KAAD,CAA/E;IACA;;EAED;;;;;;;;;;WAKA;MACC,IAAII,WAAW,GAAG,KAAKzB,UAAL,CAAgB,aAAhB,EAA+B,KAAKG,GAAL,CAAS,YAAT,EAAuB,CAAvB,CAA/B,CAAlB;MACA,KAAKJ,UAAL,CAAgB,aAAhB,EAA+B0B,WAAW,GAAG,KAAKtB,GAAL,CAAS,MAAT,EAAiB,CAAjB,CAA7C;MACA,OAAO,KAAKoB,QAAL,CAAcE,WAAd,CAAP;IACA;;EAED;;;;;;;;;WAIA;MACC,KAAK1B,UAAL,CAAgB,aAAhB,EAA+B,KAAKI,GAAL,CAAS,YAAT,EAAuB,CAAvB,CAA/B;IACA;;EAvFDuB;oBAAA;sBAAA;kBAAA;WAAkC;EAAlC;EACAA;oBAAA;sBAAA;kBAAA;WAA0CjC,MAAM,CAACkC,UAAP,CAAkBC,MAAlB,CAAyB,CAACC,QAAQ,CAACC,SAAV,CAAzB;EAA1C;EAuFD;AAAC,CAzFD,CAA8BrC,MAA9B;;SAAaoC","names":["Entity","Color","__extends","_super","_afterNewApplyThemes","call","setPrivate","getPrivate","pass","colors","get","fromHex","length","len","start","passOptions","reuse","i","push","hsl","toHSL","h","hue","s","saturation","l","lightness","fromHSL","index","generateColors","getIndex","saturate","currentStep","Object","classNames","concat","ColorSet","className"],"sourceRoot":"","sources":["../../../../../src/.internal/core/util/ColorSet.ts"],"sourcesContent":["import { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\";\nimport { Color } from \"./Color\";\n\n\nexport interface IColorSetSettings extends IEntitySettings {\n\n\t/**\n\t * List of colors in the set.\n\t */\n\tcolors?: Color[];\n\n\t/**\n\t * A step size when using `next()`.\n\t *\n\t * E.g. setting to `2` will make it return every second color in the list.\n\t *\n\t * @default 1\n\t */\n\tstep?: number;\n\n\t/**\n\t * Start iterating colors from specific index.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * If set to `true`, color set will reuse existing colors from the list\n\t * inestead of generating new ones.\n\t *\n\t * @default false\n\t */\n\treuse?: boolean;\n\n\t/**\n\t * A base color to generate new colors from if `colors` is not specified.\n\t * @type {[type]}\n\t */\n\tbaseColor?: Color;\n\n\t/**\n\t * A set of tranformation to apply to base list of colors when the set runs\n\t * out of colors and generates additional ones.\n\t */\n\tpassOptions?: IColorSetStepOptions;\n\n\t/**\n\t * If set, each returned color will be applied saturation.\n\t */\n\tsaturation?: number;\n\n\t// count?: number;\n}\n\nexport interface IColorSetPrivate extends IEntityPrivate {\n\n\tcurrentStep?: number;\n\tcurrentPass?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tnumColors?: number;\n\n}\n\nexport interface IColorSetStepOptions {\n\n\t/**\n\t * Value to add to \"hue\".\n\t */\n\thue?: number;\n\n\t/**\n\t * Value to add to \"saturation\".\n\t */\n\tsaturation?: number;\n\n\t/**\n\t * Value to add to \"lightness\".\n\t */\n\tlightness?: number;\n\n}\n\n\n/**\n * An object which holds list of colors and can generate new ones.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\n */\nexport class ColorSet extends Entity {\n\tpublic static className: string = \"ColorSet\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([ColorSet.className]);\n\n\tdeclare public _settings: IColorSetSettings;\n\tdeclare public _privateSettings: IColorSetPrivate;\n\n\t//protected _currentPass: number = 0;\n\n\tprotected _afterNew() {\n\t\t// Applying themes because color set will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic generateColors(): void {\n\t\tthis.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1)\n\t\tconst pass = this.getPrivate(\"currentPass\");\n\t\tconst colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\t\tif (!this.getPrivate(\"numColors\")) {\n\t\t\tthis.setPrivate(\"numColors\", colors.length);\n\t\t}\n\t\t//const len = colors.length;\n\t\tconst len = this.getPrivate(\"numColors\")!;\n\t\t//const start = len - this.getPrivate(\"numColors\")!;\n\t\tconst start = 0;\n\t\tconst passOptions = this.get(\"passOptions\")!;\n\t\tconst reuse = this.get(\"reuse\");\n\t\tfor (let i = start; i < len; i++) {\n\t\t\tif (reuse) {\n\t\t\t\tcolors.push(colors[i])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst hsl = colors[i]!.toHSL();\n\t\t\t\tlet h = hsl.h + (passOptions.hue || 0) * pass!;\n\t\t\t\twhile (h > 1) h -= 1;\n\n\t\t\t\tlet s = hsl.s + (passOptions.saturation || 0) * pass!;\n\t\t\t\t//if (s > 1) s -= Math.floor(s);\n\t\t\t\tif (s > 1) s = 1;\n\t\t\t\tif (s < 0) s = 0;\n\n\t\t\t\tlet l = hsl.l + (passOptions.lightness || 0) * pass!;\n\t\t\t\t//if (l > 1) l -= Math.floor(l);\n\t\t\t\twhile (l > 1) l -= 1;\n\t\t\t\tcolors.push(Color.fromHSL(h, s, l));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a [[Color]] at specific index.\n\t *\n\t * If there's no color at this index, a new color is generated.\n\t *\n\t * @param   index  Index\n\t * @return         Color\n\t */\n\tpublic getIndex(index: number): Color {\n\t\tconst colors = this.get(\"colors\", []);\n\t\tconst saturation = this.get(\"saturation\");\n\t\tif (index >= colors.length) {\n\t\t\tthis.generateColors();\n\t\t\treturn this.getIndex(index);\n\t\t}\n\n\t\treturn saturation != null ? Color.saturate(colors[index], saturation!) : colors[index];\n\t}\n\n\t/**\n\t * Returns next [[Color]] in the list.\n\t *\n\t * If the list is out of colors, new ones are generated dynamically.\n\t */\n\tpublic next() {\n\t\tlet currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t\tthis.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n\t\treturn this.getIndex(currentStep);\n\t}\n\n\t/**\n\t * Resets counter to the start of the list, so the next call for `next()` will\n\t * return the first color.\n\t */\n\tpublic reset() {\n\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}